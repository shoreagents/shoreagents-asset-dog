# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class AssetsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Assets]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Assets.prisma().query_raw(
            'SELECT * FROM Assets WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Assets
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Assets.prisma().query_first(
            'SELECT * FROM Assets WHERE assetTagId = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AssetsCreateInput,
        include: Optional[types.AssetsInclude] = None
    ) -> _PrismaModelT:
        """Create a new Assets record.

        Parameters
        ----------
        data
            Assets record data
        include
            Specifies which relations should be loaded on the returned Assets model

        Returns
        -------
        prisma.models.Assets
            The created Assets record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Assets record from just the required fields
        assets = await Assets.prisma().create(
            data={
                # data to create a Assets record
                'assetTagId': 'ggciceaie',
                'description': 'bbehjachib',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AssetsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Assets records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Assets record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Assets.prisma().create_many(
            data=[
                {
                    # data to create a Assets record
                    'assetTagId': 'cadfabfehe',
                    'description': 'dgiiaaijj',
                },
                {
                    # data to create a Assets record
                    'assetTagId': 'bfaiacjjfc',
                    'description': 'eigcfgbif',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AssetsWhereUniqueInput,
        include: Optional[types.AssetsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Assets record.

        Parameters
        ----------
        where
            Assets filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Assets model

        Returns
        -------
        prisma.models.Assets
            The deleted Assets record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assets = await Assets.prisma().delete(
            where={
                'id': 'bagcfbhiig',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AssetsWhereUniqueInput,
        include: Optional[types.AssetsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Assets record.

        Parameters
        ----------
        where
            Assets filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Assets model

        Returns
        -------
        prisma.models.Assets
            The found Assets record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assets = await Assets.prisma().find_unique(
            where={
                'id': 'cghideieh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AssetsWhereUniqueInput,
        include: Optional[types.AssetsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Assets record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Assets filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Assets model

        Returns
        -------
        prisma.models.Assets
            The found Assets record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assets = await Assets.prisma().find_unique_or_raise(
            where={
                'id': 'biabhbdai',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsWhereInput] = None,
        cursor: Optional[types.AssetsWhereUniqueInput] = None,
        include: Optional[types.AssetsInclude] = None,
        order: Optional[Union[types.AssetsOrderByInput, List[types.AssetsOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Assets records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Assets records returned
        skip
            Ignore the first N results
        where
            Assets filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Assets model
        order
            Order the returned Assets records by any field
        distinct
            Filter Assets records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Assets]
            The list of all Assets records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Assets records
        assets = await Assets.prisma().find_many(take=10)

        # find the first 5 Assets records ordered by the description field
        assets = await Assets.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsWhereInput] = None,
        cursor: Optional[types.AssetsWhereUniqueInput] = None,
        include: Optional[types.AssetsInclude] = None,
        order: Optional[Union[types.AssetsOrderByInput, List[types.AssetsOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Assets record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Assets filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Assets model
        order
            Order the returned Assets records by any field
        distinct
            Filter Assets records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Assets
            The first Assets record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Assets record ordered by the purchasedFrom field
        assets = await Assets.prisma().find_first(
            skip=1,
            order={
                'purchasedFrom': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsWhereInput] = None,
        cursor: Optional[types.AssetsWhereUniqueInput] = None,
        include: Optional[types.AssetsInclude] = None,
        order: Optional[Union[types.AssetsOrderByInput, List[types.AssetsOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Assets record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Assets filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Assets model
        order
            Order the returned Assets records by any field
        distinct
            Filter Assets records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Assets
            The first Assets record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Assets record ordered by the purchaseDate field
        assets = await Assets.prisma().find_first_or_raise(
            skip=1,
            order={
                'purchaseDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AssetsUpdateInput,
        where: types.AssetsWhereUniqueInput,
        include: Optional[types.AssetsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Assets record.

        Parameters
        ----------
        data
            Assets record data specifying what to update
        where
            Assets filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Assets model

        Returns
        -------
        prisma.models.Assets
            The updated Assets record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        assets = await Assets.prisma().update(
            where={
                'id': 'idghgaicb',
            },
            data={
                # data to update the Assets record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AssetsWhereUniqueInput,
        data: types.AssetsUpsertInput,
        include: Optional[types.AssetsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Assets filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Assets model

        Returns
        -------
        prisma.models.Assets
            The created or updated Assets record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assets = await Assets.prisma().upsert(
            where={
                'id': 'fjfddhigg',
            },
            data={
                'create': {
                    'id': 'fjfddhigg',
                    'assetTagId': 'bfaiacjjfc',
                    'description': 'eigcfgbif',
                },
                'update': {
                    'assetTagId': 'bfaiacjjfc',
                    'description': 'eigcfgbif',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AssetsUpdateManyMutationInput,
        where: types.AssetsWhereInput,
    ) -> int:
        """Update multiple Assets records

        Parameters
        ----------
        data
            Assets data to update the selected Assets records to
        where
            Filter to select the Assets records to update

        Returns
        -------
        int
            The total number of Assets records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Assets records
        total = await Assets.prisma().update_many(
            data={
                'brand': 'hjaecfifb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsWhereInput] = None,
        cursor: Optional[types.AssetsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Assets records present in the database

        Parameters
        ----------
        select
            Select the Assets fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Assets filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Assets.prisma().count()

        # results: prisma.types.AssetsCountAggregateOutput
        results = await Assets.prisma().count(
            select={
                '_all': True,
                'cost': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AssetsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsWhereInput] = None,
        cursor: Optional[types.AssetsWhereUniqueInput] = None,
    ) -> types.AssetsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AssetsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsWhereInput] = None,
        cursor: Optional[types.AssetsWhereUniqueInput] = None,
    ) -> Union[int, types.AssetsCountAggregateOutput]:
        """Count the number of Assets records present in the database

        Parameters
        ----------
        select
            Select the Assets fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Assets filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Assets.prisma().count()

        # results: prisma.types.AssetsCountAggregateOutput
        results = await Assets.prisma().count(
            select={
                '_all': True,
                'model': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AssetsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AssetsWhereInput] = None
    ) -> int:
        """Delete multiple Assets records.

        Parameters
        ----------
        where
            Optional Assets filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Assets records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Assets records
        total = await Assets.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AssetsScalarFieldKeys'],
        *,
        where: Optional['types.AssetsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AssetsAvgAggregateInput'] = None,
        sum: Optional['types.AssetsSumAggregateInput'] = None,
        min: Optional['types.AssetsMinAggregateInput'] = None,
        max: Optional['types.AssetsMaxAggregateInput'] = None,
        having: Optional['types.AssetsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AssetsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AssetsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AssetsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AssetsGroupByOutput']:
        """Group Assets records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Assets fields to group records by
        where
            Assets filter to select records
        take
            Limit the maximum number of Assets records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AssetsGroupByOutput]
            A list of dictionaries representing the Assets record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Assets records by serialNo values
        # and count how many records are in each group
        results = await Assets.prisma().group_by(
            ['serialNo'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AssetsImageActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AssetsImage]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AssetsImage.prisma().query_raw(
            'SELECT * FROM AssetsImage WHERE id = $1',
            'cbbbjbfcii',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AssetsImage
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AssetsImage.prisma().query_first(
            'SELECT * FROM AssetsImage WHERE assetTagId = $1',
            'bbejhfidcb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AssetsImageCreateInput,
        include: Optional[types.AssetsImageInclude] = None
    ) -> _PrismaModelT:
        """Create a new AssetsImage record.

        Parameters
        ----------
        data
            AssetsImage record data
        include
            Specifies which relations should be loaded on the returned AssetsImage model

        Returns
        -------
        prisma.models.AssetsImage
            The created AssetsImage record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AssetsImage record from just the required fields
        assetsimage = await AssetsImage.prisma().create(
            data={
                # data to create a AssetsImage record
                'assetTagId': 'bgeecijdgg',
                'imageUrl': 'bdiicjafbj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AssetsImageCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AssetsImage records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AssetsImage record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AssetsImage.prisma().create_many(
            data=[
                {
                    # data to create a AssetsImage record
                    'assetTagId': 'bgehebiafc',
                    'imageUrl': 'bghffegacj',
                },
                {
                    # data to create a AssetsImage record
                    'assetTagId': 'bhghchehcc',
                    'imageUrl': 'dcgchcbbf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AssetsImageWhereUniqueInput,
        include: Optional[types.AssetsImageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AssetsImage record.

        Parameters
        ----------
        where
            AssetsImage filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsImage model

        Returns
        -------
        prisma.models.AssetsImage
            The deleted AssetsImage record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsimage = await AssetsImage.prisma().delete(
            where={
                'id': 'bdedcabahc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AssetsImageWhereUniqueInput,
        include: Optional[types.AssetsImageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AssetsImage record.

        Parameters
        ----------
        where
            AssetsImage filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsImage model

        Returns
        -------
        prisma.models.AssetsImage
            The found AssetsImage record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsimage = await AssetsImage.prisma().find_unique(
            where={
                'id': 'ghfhiafcb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AssetsImageWhereUniqueInput,
        include: Optional[types.AssetsImageInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AssetsImage record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AssetsImage filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsImage model

        Returns
        -------
        prisma.models.AssetsImage
            The found AssetsImage record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsimage = await AssetsImage.prisma().find_unique_or_raise(
            where={
                'id': 'heejgedji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsImageWhereInput] = None,
        cursor: Optional[types.AssetsImageWhereUniqueInput] = None,
        include: Optional[types.AssetsImageInclude] = None,
        order: Optional[Union[types.AssetsImageOrderByInput, List[types.AssetsImageOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsImageScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AssetsImage records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AssetsImage records returned
        skip
            Ignore the first N results
        where
            AssetsImage filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsImage model
        order
            Order the returned AssetsImage records by any field
        distinct
            Filter AssetsImage records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AssetsImage]
            The list of all AssetsImage records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AssetsImage records
        assetsimages = await AssetsImage.prisma().find_many(take=10)

        # find the first 5 AssetsImage records ordered by the imageUrl field
        assetsimages = await AssetsImage.prisma().find_many(
            take=5,
            order={
                'imageUrl': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsImageWhereInput] = None,
        cursor: Optional[types.AssetsImageWhereUniqueInput] = None,
        include: Optional[types.AssetsImageInclude] = None,
        order: Optional[Union[types.AssetsImageOrderByInput, List[types.AssetsImageOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsImageScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AssetsImage record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsImage filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsImage model
        order
            Order the returned AssetsImage records by any field
        distinct
            Filter AssetsImage records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsImage
            The first AssetsImage record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsImage record ordered by the imageType field
        assetsimage = await AssetsImage.prisma().find_first(
            skip=1,
            order={
                'imageType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsImageWhereInput] = None,
        cursor: Optional[types.AssetsImageWhereUniqueInput] = None,
        include: Optional[types.AssetsImageInclude] = None,
        order: Optional[Union[types.AssetsImageOrderByInput, List[types.AssetsImageOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsImageScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AssetsImage record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsImage filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsImage model
        order
            Order the returned AssetsImage records by any field
        distinct
            Filter AssetsImage records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsImage
            The first AssetsImage record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsImage record ordered by the imageSize field
        assetsimage = await AssetsImage.prisma().find_first_or_raise(
            skip=1,
            order={
                'imageSize': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AssetsImageUpdateInput,
        where: types.AssetsImageWhereUniqueInput,
        include: Optional[types.AssetsImageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AssetsImage record.

        Parameters
        ----------
        data
            AssetsImage record data specifying what to update
        where
            AssetsImage filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AssetsImage model

        Returns
        -------
        prisma.models.AssetsImage
            The updated AssetsImage record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        assetsimage = await AssetsImage.prisma().update(
            where={
                'id': 'bjgjgibgbf',
            },
            data={
                # data to update the AssetsImage record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AssetsImageWhereUniqueInput,
        data: types.AssetsImageUpsertInput,
        include: Optional[types.AssetsImageInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AssetsImage filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AssetsImage model

        Returns
        -------
        prisma.models.AssetsImage
            The created or updated AssetsImage record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsimage = await AssetsImage.prisma().upsert(
            where={
                'id': 'bbbgbhfjge',
            },
            data={
                'create': {
                    'id': 'bbbgbhfjge',
                    'assetTagId': 'bhghchehcc',
                    'imageUrl': 'dcgchcbbf',
                },
                'update': {
                    'assetTagId': 'bhghchehcc',
                    'imageUrl': 'dcgchcbbf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AssetsImageUpdateManyMutationInput,
        where: types.AssetsImageWhereInput,
    ) -> int:
        """Update multiple AssetsImage records

        Parameters
        ----------
        data
            AssetsImage data to update the selected AssetsImage records to
        where
            Filter to select the AssetsImage records to update

        Returns
        -------
        int
            The total number of AssetsImage records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AssetsImage records
        total = await AssetsImage.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsImageWhereInput] = None,
        cursor: Optional[types.AssetsImageWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AssetsImage records present in the database

        Parameters
        ----------
        select
            Select the AssetsImage fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsImage filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsImageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsImage.prisma().count()

        # results: prisma.types.AssetsImageCountAggregateOutput
        results = await AssetsImage.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AssetsImageCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsImageWhereInput] = None,
        cursor: Optional[types.AssetsImageWhereUniqueInput] = None,
    ) -> types.AssetsImageCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AssetsImageCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsImageWhereInput] = None,
        cursor: Optional[types.AssetsImageWhereUniqueInput] = None,
    ) -> Union[int, types.AssetsImageCountAggregateOutput]:
        """Count the number of AssetsImage records present in the database

        Parameters
        ----------
        select
            Select the AssetsImage fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsImage filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsImageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsImage.prisma().count()

        # results: prisma.types.AssetsImageCountAggregateOutput
        results = await AssetsImage.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AssetsImageCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AssetsImageWhereInput] = None
    ) -> int:
        """Delete multiple AssetsImage records.

        Parameters
        ----------
        where
            Optional AssetsImage filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AssetsImage records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AssetsImage records
        total = await AssetsImage.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AssetsImageScalarFieldKeys'],
        *,
        where: Optional['types.AssetsImageWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AssetsImageAvgAggregateInput'] = None,
        sum: Optional['types.AssetsImageSumAggregateInput'] = None,
        min: Optional['types.AssetsImageMinAggregateInput'] = None,
        max: Optional['types.AssetsImageMaxAggregateInput'] = None,
        having: Optional['types.AssetsImageScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AssetsImageCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AssetsImageScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AssetsImageScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AssetsImageGroupByOutput']:
        """Group AssetsImage records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AssetsImage fields to group records by
        where
            AssetsImage filter to select records
        take
            Limit the maximum number of AssetsImage records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AssetsImageGroupByOutput]
            A list of dictionaries representing the AssetsImage record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AssetsImage records by assetTagId values
        # and count how many records are in each group
        results = await AssetsImage.prisma().group_by(
            ['assetTagId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AssetsDocumentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AssetsDocument]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AssetsDocument.prisma().query_raw(
            'SELECT * FROM AssetsDocument WHERE id = $1',
            'igbehcbab',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AssetsDocument
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AssetsDocument.prisma().query_first(
            'SELECT * FROM AssetsDocument WHERE assetTagId = $1',
            'bdadaadhag',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AssetsDocumentCreateInput,
        include: Optional[types.AssetsDocumentInclude] = None
    ) -> _PrismaModelT:
        """Create a new AssetsDocument record.

        Parameters
        ----------
        data
            AssetsDocument record data
        include
            Specifies which relations should be loaded on the returned AssetsDocument model

        Returns
        -------
        prisma.models.AssetsDocument
            The created AssetsDocument record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AssetsDocument record from just the required fields
        assetsdocument = await AssetsDocument.prisma().create(
            data={
                # data to create a AssetsDocument record
                'assetTagId': 'bgiggdidbf',
                'documentUrl': 'caaaedabfc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AssetsDocumentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AssetsDocument records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AssetsDocument record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AssetsDocument.prisma().create_many(
            data=[
                {
                    # data to create a AssetsDocument record
                    'assetTagId': 'bigibebcib',
                    'documentUrl': 'bigaiehgcc',
                },
                {
                    # data to create a AssetsDocument record
                    'assetTagId': 'beeifcbebf',
                    'documentUrl': 'bgcigfahea',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AssetsDocumentWhereUniqueInput,
        include: Optional[types.AssetsDocumentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AssetsDocument record.

        Parameters
        ----------
        where
            AssetsDocument filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsDocument model

        Returns
        -------
        prisma.models.AssetsDocument
            The deleted AssetsDocument record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsdocument = await AssetsDocument.prisma().delete(
            where={
                'id': 'bcejgaggif',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AssetsDocumentWhereUniqueInput,
        include: Optional[types.AssetsDocumentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AssetsDocument record.

        Parameters
        ----------
        where
            AssetsDocument filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsDocument model

        Returns
        -------
        prisma.models.AssetsDocument
            The found AssetsDocument record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsdocument = await AssetsDocument.prisma().find_unique(
            where={
                'id': 'idfjadbcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AssetsDocumentWhereUniqueInput,
        include: Optional[types.AssetsDocumentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AssetsDocument record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AssetsDocument filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsDocument model

        Returns
        -------
        prisma.models.AssetsDocument
            The found AssetsDocument record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsdocument = await AssetsDocument.prisma().find_unique_or_raise(
            where={
                'id': 'hgdhbjhhj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsDocumentWhereInput] = None,
        cursor: Optional[types.AssetsDocumentWhereUniqueInput] = None,
        include: Optional[types.AssetsDocumentInclude] = None,
        order: Optional[Union[types.AssetsDocumentOrderByInput, List[types.AssetsDocumentOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsDocumentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AssetsDocument records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AssetsDocument records returned
        skip
            Ignore the first N results
        where
            AssetsDocument filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsDocument model
        order
            Order the returned AssetsDocument records by any field
        distinct
            Filter AssetsDocument records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AssetsDocument]
            The list of all AssetsDocument records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AssetsDocument records
        assetsdocuments = await AssetsDocument.prisma().find_many(take=10)

        # find the first 5 AssetsDocument records ordered by the documentUrl field
        assetsdocuments = await AssetsDocument.prisma().find_many(
            take=5,
            order={
                'documentUrl': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsDocumentWhereInput] = None,
        cursor: Optional[types.AssetsDocumentWhereUniqueInput] = None,
        include: Optional[types.AssetsDocumentInclude] = None,
        order: Optional[Union[types.AssetsDocumentOrderByInput, List[types.AssetsDocumentOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsDocumentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AssetsDocument record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsDocument filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsDocument model
        order
            Order the returned AssetsDocument records by any field
        distinct
            Filter AssetsDocument records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsDocument
            The first AssetsDocument record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsDocument record ordered by the documentType field
        assetsdocument = await AssetsDocument.prisma().find_first(
            skip=1,
            order={
                'documentType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsDocumentWhereInput] = None,
        cursor: Optional[types.AssetsDocumentWhereUniqueInput] = None,
        include: Optional[types.AssetsDocumentInclude] = None,
        order: Optional[Union[types.AssetsDocumentOrderByInput, List[types.AssetsDocumentOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsDocumentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AssetsDocument record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsDocument filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsDocument model
        order
            Order the returned AssetsDocument records by any field
        distinct
            Filter AssetsDocument records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsDocument
            The first AssetsDocument record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsDocument record ordered by the documentSize field
        assetsdocument = await AssetsDocument.prisma().find_first_or_raise(
            skip=1,
            order={
                'documentSize': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AssetsDocumentUpdateInput,
        where: types.AssetsDocumentWhereUniqueInput,
        include: Optional[types.AssetsDocumentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AssetsDocument record.

        Parameters
        ----------
        data
            AssetsDocument record data specifying what to update
        where
            AssetsDocument filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AssetsDocument model

        Returns
        -------
        prisma.models.AssetsDocument
            The updated AssetsDocument record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        assetsdocument = await AssetsDocument.prisma().update(
            where={
                'id': 'ecjjjfbae',
            },
            data={
                # data to update the AssetsDocument record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AssetsDocumentWhereUniqueInput,
        data: types.AssetsDocumentUpsertInput,
        include: Optional[types.AssetsDocumentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AssetsDocument filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AssetsDocument model

        Returns
        -------
        prisma.models.AssetsDocument
            The created or updated AssetsDocument record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsdocument = await AssetsDocument.prisma().upsert(
            where={
                'id': 'bhhfibbigf',
            },
            data={
                'create': {
                    'id': 'bhhfibbigf',
                    'assetTagId': 'beeifcbebf',
                    'documentUrl': 'bgcigfahea',
                },
                'update': {
                    'assetTagId': 'beeifcbebf',
                    'documentUrl': 'bgcigfahea',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AssetsDocumentUpdateManyMutationInput,
        where: types.AssetsDocumentWhereInput,
    ) -> int:
        """Update multiple AssetsDocument records

        Parameters
        ----------
        data
            AssetsDocument data to update the selected AssetsDocument records to
        where
            Filter to select the AssetsDocument records to update

        Returns
        -------
        int
            The total number of AssetsDocument records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AssetsDocument records
        total = await AssetsDocument.prisma().update_many(
            data={
                'fileName': 'ijdbeffgg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsDocumentWhereInput] = None,
        cursor: Optional[types.AssetsDocumentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AssetsDocument records present in the database

        Parameters
        ----------
        select
            Select the AssetsDocument fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsDocument filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsDocumentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsDocument.prisma().count()

        # results: prisma.types.AssetsDocumentCountAggregateOutput
        results = await AssetsDocument.prisma().count(
            select={
                '_all': True,
                'mimeType': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AssetsDocumentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsDocumentWhereInput] = None,
        cursor: Optional[types.AssetsDocumentWhereUniqueInput] = None,
    ) -> types.AssetsDocumentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AssetsDocumentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsDocumentWhereInput] = None,
        cursor: Optional[types.AssetsDocumentWhereUniqueInput] = None,
    ) -> Union[int, types.AssetsDocumentCountAggregateOutput]:
        """Count the number of AssetsDocument records present in the database

        Parameters
        ----------
        select
            Select the AssetsDocument fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsDocument filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsDocumentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsDocument.prisma().count()

        # results: prisma.types.AssetsDocumentCountAggregateOutput
        results = await AssetsDocument.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AssetsDocumentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AssetsDocumentWhereInput] = None
    ) -> int:
        """Delete multiple AssetsDocument records.

        Parameters
        ----------
        where
            Optional AssetsDocument filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AssetsDocument records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AssetsDocument records
        total = await AssetsDocument.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AssetsDocumentScalarFieldKeys'],
        *,
        where: Optional['types.AssetsDocumentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AssetsDocumentAvgAggregateInput'] = None,
        sum: Optional['types.AssetsDocumentSumAggregateInput'] = None,
        min: Optional['types.AssetsDocumentMinAggregateInput'] = None,
        max: Optional['types.AssetsDocumentMaxAggregateInput'] = None,
        having: Optional['types.AssetsDocumentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AssetsDocumentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AssetsDocumentScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AssetsDocumentScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AssetsDocumentGroupByOutput']:
        """Group AssetsDocument records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AssetsDocument fields to group records by
        where
            AssetsDocument filter to select records
        take
            Limit the maximum number of AssetsDocument records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AssetsDocumentGroupByOutput]
            A list of dictionaries representing the AssetsDocument record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AssetsDocument records by updatedAt values
        # and count how many records are in each group
        results = await AssetsDocument.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CategoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Category]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Category.prisma().query_raw(
            'SELECT * FROM Category WHERE id = $1',
            'jjfeafhfj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Category
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Category.prisma().query_first(
            'SELECT * FROM Category WHERE name = $1',
            'cbachdgfce',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CategoryCreateInput,
        include: Optional[types.CategoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new Category record.

        Parameters
        ----------
        data
            Category record data
        include
            Specifies which relations should be loaded on the returned Category model

        Returns
        -------
        prisma.models.Category
            The created Category record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Category record from just the required fields
        category = await Category.prisma().create(
            data={
                # data to create a Category record
                'name': 'chbfcacbd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CategoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Category records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Category record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Category.prisma().create_many(
            data=[
                {
                    # data to create a Category record
                    'name': 'efggddide',
                },
                {
                    # data to create a Category record
                    'name': 'caficfigfb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CategoryWhereUniqueInput,
        include: Optional[types.CategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Category record.

        Parameters
        ----------
        where
            Category filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Category model

        Returns
        -------
        prisma.models.Category
            The deleted Category record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        category = await Category.prisma().delete(
            where={
                'id': 'bfidgijfjc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CategoryWhereUniqueInput,
        include: Optional[types.CategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Category record.

        Parameters
        ----------
        where
            Category filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Category model

        Returns
        -------
        prisma.models.Category
            The found Category record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        category = await Category.prisma().find_unique(
            where={
                'id': 'ihieecagf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CategoryWhereUniqueInput,
        include: Optional[types.CategoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Category record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Category filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Category model

        Returns
        -------
        prisma.models.Category
            The found Category record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        category = await Category.prisma().find_unique_or_raise(
            where={
                'id': 'bghfciaafe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CategoryWhereInput] = None,
        cursor: Optional[types.CategoryWhereUniqueInput] = None,
        include: Optional[types.CategoryInclude] = None,
        order: Optional[Union[types.CategoryOrderByInput, List[types.CategoryOrderByInput]]] = None,
        distinct: Optional[List[types.CategoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Category records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Category records returned
        skip
            Ignore the first N results
        where
            Category filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Category model
        order
            Order the returned Category records by any field
        distinct
            Filter Category records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Category]
            The list of all Category records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Category records
        categorys = await Category.prisma().find_many(take=10)

        # find the first 5 Category records ordered by the description field
        categorys = await Category.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CategoryWhereInput] = None,
        cursor: Optional[types.CategoryWhereUniqueInput] = None,
        include: Optional[types.CategoryInclude] = None,
        order: Optional[Union[types.CategoryOrderByInput, List[types.CategoryOrderByInput]]] = None,
        distinct: Optional[List[types.CategoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Category record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Category filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Category model
        order
            Order the returned Category records by any field
        distinct
            Filter Category records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Category
            The first Category record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Category record ordered by the createdAt field
        category = await Category.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CategoryWhereInput] = None,
        cursor: Optional[types.CategoryWhereUniqueInput] = None,
        include: Optional[types.CategoryInclude] = None,
        order: Optional[Union[types.CategoryOrderByInput, List[types.CategoryOrderByInput]]] = None,
        distinct: Optional[List[types.CategoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Category record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Category filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Category model
        order
            Order the returned Category records by any field
        distinct
            Filter Category records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Category
            The first Category record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Category record ordered by the updatedAt field
        category = await Category.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CategoryUpdateInput,
        where: types.CategoryWhereUniqueInput,
        include: Optional[types.CategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Category record.

        Parameters
        ----------
        data
            Category record data specifying what to update
        where
            Category filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Category model

        Returns
        -------
        prisma.models.Category
            The updated Category record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        category = await Category.prisma().update(
            where={
                'id': 'bgchfhgceh',
            },
            data={
                # data to update the Category record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CategoryWhereUniqueInput,
        data: types.CategoryUpsertInput,
        include: Optional[types.CategoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Category filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Category model

        Returns
        -------
        prisma.models.Category
            The created or updated Category record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        category = await Category.prisma().upsert(
            where={
                'id': 'cafeiaccbc',
            },
            data={
                'create': {
                    'id': 'cafeiaccbc',
                    'name': 'caficfigfb',
                },
                'update': {
                    'name': 'caficfigfb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CategoryUpdateManyMutationInput,
        where: types.CategoryWhereInput,
    ) -> int:
        """Update multiple Category records

        Parameters
        ----------
        data
            Category data to update the selected Category records to
        where
            Filter to select the Category records to update

        Returns
        -------
        int
            The total number of Category records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Category records
        total = await Category.prisma().update_many(
            data={
                'id': 'gaddfhfh'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CategoryWhereInput] = None,
        cursor: Optional[types.CategoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Category records present in the database

        Parameters
        ----------
        select
            Select the Category fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Category filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CategoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Category.prisma().count()

        # results: prisma.types.CategoryCountAggregateOutput
        results = await Category.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CategoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CategoryWhereInput] = None,
        cursor: Optional[types.CategoryWhereUniqueInput] = None,
    ) -> types.CategoryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CategoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CategoryWhereInput] = None,
        cursor: Optional[types.CategoryWhereUniqueInput] = None,
    ) -> Union[int, types.CategoryCountAggregateOutput]:
        """Count the number of Category records present in the database

        Parameters
        ----------
        select
            Select the Category fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Category filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CategoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Category.prisma().count()

        # results: prisma.types.CategoryCountAggregateOutput
        results = await Category.prisma().count(
            select={
                '_all': True,
                'description': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CategoryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CategoryWhereInput] = None
    ) -> int:
        """Delete multiple Category records.

        Parameters
        ----------
        where
            Optional Category filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Category records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Category records
        total = await Category.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CategoryScalarFieldKeys'],
        *,
        where: Optional['types.CategoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CategoryAvgAggregateInput'] = None,
        sum: Optional['types.CategorySumAggregateInput'] = None,
        min: Optional['types.CategoryMinAggregateInput'] = None,
        max: Optional['types.CategoryMaxAggregateInput'] = None,
        having: Optional['types.CategoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CategoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CategoryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CategoryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CategoryGroupByOutput']:
        """Group Category records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Category fields to group records by
        where
            Category filter to select records
        take
            Limit the maximum number of Category records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CategoryGroupByOutput]
            A list of dictionaries representing the Category record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Category records by createdAt values
        # and count how many records are in each group
        results = await Category.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SubCategoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.SubCategory]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await SubCategory.prisma().query_raw(
            'SELECT * FROM SubCategory WHERE id = $1',
            'gieegcbeg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.SubCategory
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await SubCategory.prisma().query_first(
            'SELECT * FROM SubCategory WHERE name = $1',
            'bgcffadich',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SubCategoryCreateInput,
        include: Optional[types.SubCategoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new SubCategory record.

        Parameters
        ----------
        data
            SubCategory record data
        include
            Specifies which relations should be loaded on the returned SubCategory model

        Returns
        -------
        prisma.models.SubCategory
            The created SubCategory record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a SubCategory record from just the required fields
        subcategory = await SubCategory.prisma().create(
            data={
                # data to create a SubCategory record
                'name': 'fcbichhci',
                'categoryId': 'bcggadccgf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SubCategoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple SubCategory records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of SubCategory record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await SubCategory.prisma().create_many(
            data=[
                {
                    # data to create a SubCategory record
                    'name': 'jdcfdcgc',
                    'categoryId': 'cafdaehjid',
                },
                {
                    # data to create a SubCategory record
                    'name': 'gifdddbia',
                    'categoryId': 'bchehecef',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SubCategoryWhereUniqueInput,
        include: Optional[types.SubCategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single SubCategory record.

        Parameters
        ----------
        where
            SubCategory filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned SubCategory model

        Returns
        -------
        prisma.models.SubCategory
            The deleted SubCategory record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        subcategory = await SubCategory.prisma().delete(
            where={
                'id': 'jeijcbhfe',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SubCategoryWhereUniqueInput,
        include: Optional[types.SubCategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique SubCategory record.

        Parameters
        ----------
        where
            SubCategory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SubCategory model

        Returns
        -------
        prisma.models.SubCategory
            The found SubCategory record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        subcategory = await SubCategory.prisma().find_unique(
            where={
                'id': 'bjgejjabff',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SubCategoryWhereUniqueInput,
        include: Optional[types.SubCategoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique SubCategory record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            SubCategory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SubCategory model

        Returns
        -------
        prisma.models.SubCategory
            The found SubCategory record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        subcategory = await SubCategory.prisma().find_unique_or_raise(
            where={
                'id': 'bcciijbibg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SubCategoryWhereInput] = None,
        cursor: Optional[types.SubCategoryWhereUniqueInput] = None,
        include: Optional[types.SubCategoryInclude] = None,
        order: Optional[Union[types.SubCategoryOrderByInput, List[types.SubCategoryOrderByInput]]] = None,
        distinct: Optional[List[types.SubCategoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple SubCategory records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of SubCategory records returned
        skip
            Ignore the first N results
        where
            SubCategory filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SubCategory model
        order
            Order the returned SubCategory records by any field
        distinct
            Filter SubCategory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.SubCategory]
            The list of all SubCategory records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 SubCategory records
        subcategorys = await SubCategory.prisma().find_many(take=10)

        # find the first 5 SubCategory records ordered by the description field
        subcategorys = await SubCategory.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SubCategoryWhereInput] = None,
        cursor: Optional[types.SubCategoryWhereUniqueInput] = None,
        include: Optional[types.SubCategoryInclude] = None,
        order: Optional[Union[types.SubCategoryOrderByInput, List[types.SubCategoryOrderByInput]]] = None,
        distinct: Optional[List[types.SubCategoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single SubCategory record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SubCategory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SubCategory model
        order
            Order the returned SubCategory records by any field
        distinct
            Filter SubCategory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SubCategory
            The first SubCategory record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SubCategory record ordered by the categoryId field
        subcategory = await SubCategory.prisma().find_first(
            skip=1,
            order={
                'categoryId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SubCategoryWhereInput] = None,
        cursor: Optional[types.SubCategoryWhereUniqueInput] = None,
        include: Optional[types.SubCategoryInclude] = None,
        order: Optional[Union[types.SubCategoryOrderByInput, List[types.SubCategoryOrderByInput]]] = None,
        distinct: Optional[List[types.SubCategoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single SubCategory record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SubCategory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SubCategory model
        order
            Order the returned SubCategory records by any field
        distinct
            Filter SubCategory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SubCategory
            The first SubCategory record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SubCategory record ordered by the createdAt field
        subcategory = await SubCategory.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SubCategoryUpdateInput,
        where: types.SubCategoryWhereUniqueInput,
        include: Optional[types.SubCategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single SubCategory record.

        Parameters
        ----------
        data
            SubCategory record data specifying what to update
        where
            SubCategory filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned SubCategory model

        Returns
        -------
        prisma.models.SubCategory
            The updated SubCategory record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        subcategory = await SubCategory.prisma().update(
            where={
                'id': 'cffcachfd',
            },
            data={
                # data to update the SubCategory record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SubCategoryWhereUniqueInput,
        data: types.SubCategoryUpsertInput,
        include: Optional[types.SubCategoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            SubCategory filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned SubCategory model

        Returns
        -------
        prisma.models.SubCategory
            The created or updated SubCategory record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        subcategory = await SubCategory.prisma().upsert(
            where={
                'id': 'bccdfhdigc',
            },
            data={
                'create': {
                    'id': 'bccdfhdigc',
                    'name': 'gifdddbia',
                    'categoryId': 'bchehecef',
                },
                'update': {
                    'name': 'gifdddbia',
                    'categoryId': 'bchehecef',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SubCategoryUpdateManyMutationInput,
        where: types.SubCategoryWhereInput,
    ) -> int:
        """Update multiple SubCategory records

        Parameters
        ----------
        data
            SubCategory data to update the selected SubCategory records to
        where
            Filter to select the SubCategory records to update

        Returns
        -------
        int
            The total number of SubCategory records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all SubCategory records
        total = await SubCategory.prisma().update_many(
            data={
                'updatedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SubCategoryWhereInput] = None,
        cursor: Optional[types.SubCategoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of SubCategory records present in the database

        Parameters
        ----------
        select
            Select the SubCategory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SubCategory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SubCategoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SubCategory.prisma().count()

        # results: prisma.types.SubCategoryCountAggregateOutput
        results = await SubCategory.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SubCategoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SubCategoryWhereInput] = None,
        cursor: Optional[types.SubCategoryWhereUniqueInput] = None,
    ) -> types.SubCategoryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SubCategoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SubCategoryWhereInput] = None,
        cursor: Optional[types.SubCategoryWhereUniqueInput] = None,
    ) -> Union[int, types.SubCategoryCountAggregateOutput]:
        """Count the number of SubCategory records present in the database

        Parameters
        ----------
        select
            Select the SubCategory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SubCategory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SubCategoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SubCategory.prisma().count()

        # results: prisma.types.SubCategoryCountAggregateOutput
        results = await SubCategory.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SubCategoryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SubCategoryWhereInput] = None
    ) -> int:
        """Delete multiple SubCategory records.

        Parameters
        ----------
        where
            Optional SubCategory filter to find the records to be deleted

        Returns
        -------
        int
            The total number of SubCategory records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all SubCategory records
        total = await SubCategory.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SubCategoryScalarFieldKeys'],
        *,
        where: Optional['types.SubCategoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SubCategoryAvgAggregateInput'] = None,
        sum: Optional['types.SubCategorySumAggregateInput'] = None,
        min: Optional['types.SubCategoryMinAggregateInput'] = None,
        max: Optional['types.SubCategoryMaxAggregateInput'] = None,
        having: Optional['types.SubCategoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SubCategoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SubCategoryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SubCategoryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SubCategoryGroupByOutput']:
        """Group SubCategory records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar SubCategory fields to group records by
        where
            SubCategory filter to select records
        take
            Limit the maximum number of SubCategory records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SubCategoryGroupByOutput]
            A list of dictionaries representing the SubCategory record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group SubCategory records by description values
        # and count how many records are in each group
        results = await SubCategory.prisma().group_by(
            ['description'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class EmployeeUserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.EmployeeUser]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await EmployeeUser.prisma().query_raw(
            'SELECT * FROM EmployeeUser WHERE id = $1',
            'febcgjbfj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.EmployeeUser
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await EmployeeUser.prisma().query_first(
            'SELECT * FROM EmployeeUser WHERE name = $1',
            'bageiegghg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EmployeeUserCreateInput,
        include: Optional[types.EmployeeUserInclude] = None
    ) -> _PrismaModelT:
        """Create a new EmployeeUser record.

        Parameters
        ----------
        data
            EmployeeUser record data
        include
            Specifies which relations should be loaded on the returned EmployeeUser model

        Returns
        -------
        prisma.models.EmployeeUser
            The created EmployeeUser record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a EmployeeUser record from just the required fields
        employeeuser = await EmployeeUser.prisma().create(
            data={
                # data to create a EmployeeUser record
                'name': 'faidicegb',
                'email': 'bacecgfhbe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EmployeeUserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple EmployeeUser records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of EmployeeUser record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await EmployeeUser.prisma().create_many(
            data=[
                {
                    # data to create a EmployeeUser record
                    'name': 'ihcahiead',
                    'email': 'biheheiajg',
                },
                {
                    # data to create a EmployeeUser record
                    'name': 'jbgijghgb',
                    'email': 'hgjcghfbi',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EmployeeUserWhereUniqueInput,
        include: Optional[types.EmployeeUserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single EmployeeUser record.

        Parameters
        ----------
        where
            EmployeeUser filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned EmployeeUser model

        Returns
        -------
        prisma.models.EmployeeUser
            The deleted EmployeeUser record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        employeeuser = await EmployeeUser.prisma().delete(
            where={
                'id': 'icadbcehj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EmployeeUserWhereUniqueInput,
        include: Optional[types.EmployeeUserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique EmployeeUser record.

        Parameters
        ----------
        where
            EmployeeUser filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmployeeUser model

        Returns
        -------
        prisma.models.EmployeeUser
            The found EmployeeUser record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        employeeuser = await EmployeeUser.prisma().find_unique(
            where={
                'id': 'jchciaee',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EmployeeUserWhereUniqueInput,
        include: Optional[types.EmployeeUserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique EmployeeUser record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            EmployeeUser filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmployeeUser model

        Returns
        -------
        prisma.models.EmployeeUser
            The found EmployeeUser record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        employeeuser = await EmployeeUser.prisma().find_unique_or_raise(
            where={
                'id': 'deeificjd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmployeeUserWhereInput] = None,
        cursor: Optional[types.EmployeeUserWhereUniqueInput] = None,
        include: Optional[types.EmployeeUserInclude] = None,
        order: Optional[Union[types.EmployeeUserOrderByInput, List[types.EmployeeUserOrderByInput]]] = None,
        distinct: Optional[List[types.EmployeeUserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple EmployeeUser records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of EmployeeUser records returned
        skip
            Ignore the first N results
        where
            EmployeeUser filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmployeeUser model
        order
            Order the returned EmployeeUser records by any field
        distinct
            Filter EmployeeUser records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.EmployeeUser]
            The list of all EmployeeUser records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 EmployeeUser records
        employeeusers = await EmployeeUser.prisma().find_many(take=10)

        # find the first 5 EmployeeUser records ordered by the email field
        employeeusers = await EmployeeUser.prisma().find_many(
            take=5,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmployeeUserWhereInput] = None,
        cursor: Optional[types.EmployeeUserWhereUniqueInput] = None,
        include: Optional[types.EmployeeUserInclude] = None,
        order: Optional[Union[types.EmployeeUserOrderByInput, List[types.EmployeeUserOrderByInput]]] = None,
        distinct: Optional[List[types.EmployeeUserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single EmployeeUser record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmployeeUser filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmployeeUser model
        order
            Order the returned EmployeeUser records by any field
        distinct
            Filter EmployeeUser records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmployeeUser
            The first EmployeeUser record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmployeeUser record ordered by the department field
        employeeuser = await EmployeeUser.prisma().find_first(
            skip=1,
            order={
                'department': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmployeeUserWhereInput] = None,
        cursor: Optional[types.EmployeeUserWhereUniqueInput] = None,
        include: Optional[types.EmployeeUserInclude] = None,
        order: Optional[Union[types.EmployeeUserOrderByInput, List[types.EmployeeUserOrderByInput]]] = None,
        distinct: Optional[List[types.EmployeeUserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single EmployeeUser record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmployeeUser filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmployeeUser model
        order
            Order the returned EmployeeUser records by any field
        distinct
            Filter EmployeeUser records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmployeeUser
            The first EmployeeUser record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmployeeUser record ordered by the createdAt field
        employeeuser = await EmployeeUser.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EmployeeUserUpdateInput,
        where: types.EmployeeUserWhereUniqueInput,
        include: Optional[types.EmployeeUserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single EmployeeUser record.

        Parameters
        ----------
        data
            EmployeeUser record data specifying what to update
        where
            EmployeeUser filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned EmployeeUser model

        Returns
        -------
        prisma.models.EmployeeUser
            The updated EmployeeUser record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        employeeuser = await EmployeeUser.prisma().update(
            where={
                'id': 'bbcbhebbda',
            },
            data={
                # data to update the EmployeeUser record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EmployeeUserWhereUniqueInput,
        data: types.EmployeeUserUpsertInput,
        include: Optional[types.EmployeeUserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            EmployeeUser filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned EmployeeUser model

        Returns
        -------
        prisma.models.EmployeeUser
            The created or updated EmployeeUser record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        employeeuser = await EmployeeUser.prisma().upsert(
            where={
                'id': 'bejfijgcfb',
            },
            data={
                'create': {
                    'id': 'bejfijgcfb',
                    'name': 'jbgijghgb',
                    'email': 'hgjcghfbi',
                },
                'update': {
                    'name': 'jbgijghgb',
                    'email': 'hgjcghfbi',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EmployeeUserUpdateManyMutationInput,
        where: types.EmployeeUserWhereInput,
    ) -> int:
        """Update multiple EmployeeUser records

        Parameters
        ----------
        data
            EmployeeUser data to update the selected EmployeeUser records to
        where
            Filter to select the EmployeeUser records to update

        Returns
        -------
        int
            The total number of EmployeeUser records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all EmployeeUser records
        total = await EmployeeUser.prisma().update_many(
            data={
                'updatedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmployeeUserWhereInput] = None,
        cursor: Optional[types.EmployeeUserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of EmployeeUser records present in the database

        Parameters
        ----------
        select
            Select the EmployeeUser fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmployeeUser filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmployeeUserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmployeeUser.prisma().count()

        # results: prisma.types.EmployeeUserCountAggregateOutput
        results = await EmployeeUser.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EmployeeUserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmployeeUserWhereInput] = None,
        cursor: Optional[types.EmployeeUserWhereUniqueInput] = None,
    ) -> types.EmployeeUserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EmployeeUserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmployeeUserWhereInput] = None,
        cursor: Optional[types.EmployeeUserWhereUniqueInput] = None,
    ) -> Union[int, types.EmployeeUserCountAggregateOutput]:
        """Count the number of EmployeeUser records present in the database

        Parameters
        ----------
        select
            Select the EmployeeUser fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmployeeUser filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmployeeUserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmployeeUser.prisma().count()

        # results: prisma.types.EmployeeUserCountAggregateOutput
        results = await EmployeeUser.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EmployeeUserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EmployeeUserWhereInput] = None
    ) -> int:
        """Delete multiple EmployeeUser records.

        Parameters
        ----------
        where
            Optional EmployeeUser filter to find the records to be deleted

        Returns
        -------
        int
            The total number of EmployeeUser records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all EmployeeUser records
        total = await EmployeeUser.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EmployeeUserScalarFieldKeys'],
        *,
        where: Optional['types.EmployeeUserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EmployeeUserAvgAggregateInput'] = None,
        sum: Optional['types.EmployeeUserSumAggregateInput'] = None,
        min: Optional['types.EmployeeUserMinAggregateInput'] = None,
        max: Optional['types.EmployeeUserMaxAggregateInput'] = None,
        having: Optional['types.EmployeeUserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EmployeeUserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EmployeeUserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.EmployeeUserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.EmployeeUserGroupByOutput']:
        """Group EmployeeUser records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar EmployeeUser fields to group records by
        where
            EmployeeUser filter to select records
        take
            Limit the maximum number of EmployeeUser records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EmployeeUserGroupByOutput]
            A list of dictionaries representing the EmployeeUser record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group EmployeeUser records by email values
        # and count how many records are in each group
        results = await EmployeeUser.prisma().group_by(
            ['email'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AssetsCheckoutActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AssetsCheckout]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AssetsCheckout.prisma().query_raw(
            'SELECT * FROM AssetsCheckout WHERE id = $1',
            'caifcbgii',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AssetsCheckout
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AssetsCheckout.prisma().query_first(
            'SELECT * FROM AssetsCheckout WHERE assetId = $1',
            'igaibbfgj',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AssetsCheckoutCreateInput,
        include: Optional[types.AssetsCheckoutInclude] = None
    ) -> _PrismaModelT:
        """Create a new AssetsCheckout record.

        Parameters
        ----------
        data
            AssetsCheckout record data
        include
            Specifies which relations should be loaded on the returned AssetsCheckout model

        Returns
        -------
        prisma.models.AssetsCheckout
            The created AssetsCheckout record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AssetsCheckout record from just the required fields
        assetscheckout = await AssetsCheckout.prisma().create(
            data={
                # data to create a AssetsCheckout record
                'assetId': 'bggajdcbbi',
                'checkoutDate': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AssetsCheckoutCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AssetsCheckout records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AssetsCheckout record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AssetsCheckout.prisma().create_many(
            data=[
                {
                    # data to create a AssetsCheckout record
                    'assetId': 'fcfhgbjed',
                    'checkoutDate': datetime.datetime.utcnow(),
                },
                {
                    # data to create a AssetsCheckout record
                    'assetId': 'hdgcajhjg',
                    'checkoutDate': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AssetsCheckoutWhereUniqueInput,
        include: Optional[types.AssetsCheckoutInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AssetsCheckout record.

        Parameters
        ----------
        where
            AssetsCheckout filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsCheckout model

        Returns
        -------
        prisma.models.AssetsCheckout
            The deleted AssetsCheckout record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetscheckout = await AssetsCheckout.prisma().delete(
            where={
                'id': 'ejdjahicb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AssetsCheckoutWhereUniqueInput,
        include: Optional[types.AssetsCheckoutInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AssetsCheckout record.

        Parameters
        ----------
        where
            AssetsCheckout filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsCheckout model

        Returns
        -------
        prisma.models.AssetsCheckout
            The found AssetsCheckout record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetscheckout = await AssetsCheckout.prisma().find_unique(
            where={
                'id': 'gdjgigfgc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AssetsCheckoutWhereUniqueInput,
        include: Optional[types.AssetsCheckoutInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AssetsCheckout record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AssetsCheckout filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsCheckout model

        Returns
        -------
        prisma.models.AssetsCheckout
            The found AssetsCheckout record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetscheckout = await AssetsCheckout.prisma().find_unique_or_raise(
            where={
                'id': 'gfeaahdeh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsCheckoutWhereInput] = None,
        cursor: Optional[types.AssetsCheckoutWhereUniqueInput] = None,
        include: Optional[types.AssetsCheckoutInclude] = None,
        order: Optional[Union[types.AssetsCheckoutOrderByInput, List[types.AssetsCheckoutOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsCheckoutScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AssetsCheckout records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AssetsCheckout records returned
        skip
            Ignore the first N results
        where
            AssetsCheckout filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsCheckout model
        order
            Order the returned AssetsCheckout records by any field
        distinct
            Filter AssetsCheckout records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AssetsCheckout]
            The list of all AssetsCheckout records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AssetsCheckout records
        assetscheckouts = await AssetsCheckout.prisma().find_many(take=10)

        # find the first 5 AssetsCheckout records ordered by the employeeUserId field
        assetscheckouts = await AssetsCheckout.prisma().find_many(
            take=5,
            order={
                'employeeUserId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsCheckoutWhereInput] = None,
        cursor: Optional[types.AssetsCheckoutWhereUniqueInput] = None,
        include: Optional[types.AssetsCheckoutInclude] = None,
        order: Optional[Union[types.AssetsCheckoutOrderByInput, List[types.AssetsCheckoutOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsCheckoutScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AssetsCheckout record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsCheckout filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsCheckout model
        order
            Order the returned AssetsCheckout records by any field
        distinct
            Filter AssetsCheckout records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsCheckout
            The first AssetsCheckout record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsCheckout record ordered by the checkoutDate field
        assetscheckout = await AssetsCheckout.prisma().find_first(
            skip=1,
            order={
                'checkoutDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsCheckoutWhereInput] = None,
        cursor: Optional[types.AssetsCheckoutWhereUniqueInput] = None,
        include: Optional[types.AssetsCheckoutInclude] = None,
        order: Optional[Union[types.AssetsCheckoutOrderByInput, List[types.AssetsCheckoutOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsCheckoutScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AssetsCheckout record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsCheckout filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsCheckout model
        order
            Order the returned AssetsCheckout records by any field
        distinct
            Filter AssetsCheckout records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsCheckout
            The first AssetsCheckout record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsCheckout record ordered by the expectedReturnDate field
        assetscheckout = await AssetsCheckout.prisma().find_first_or_raise(
            skip=1,
            order={
                'expectedReturnDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AssetsCheckoutUpdateInput,
        where: types.AssetsCheckoutWhereUniqueInput,
        include: Optional[types.AssetsCheckoutInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AssetsCheckout record.

        Parameters
        ----------
        data
            AssetsCheckout record data specifying what to update
        where
            AssetsCheckout filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AssetsCheckout model

        Returns
        -------
        prisma.models.AssetsCheckout
            The updated AssetsCheckout record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        assetscheckout = await AssetsCheckout.prisma().update(
            where={
                'id': 'bjafcgbffc',
            },
            data={
                # data to update the AssetsCheckout record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AssetsCheckoutWhereUniqueInput,
        data: types.AssetsCheckoutUpsertInput,
        include: Optional[types.AssetsCheckoutInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AssetsCheckout filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AssetsCheckout model

        Returns
        -------
        prisma.models.AssetsCheckout
            The created or updated AssetsCheckout record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetscheckout = await AssetsCheckout.prisma().upsert(
            where={
                'id': 'hihegjif',
            },
            data={
                'create': {
                    'id': 'hihegjif',
                    'assetId': 'hdgcajhjg',
                    'checkoutDate': datetime.datetime.utcnow(),
                },
                'update': {
                    'assetId': 'hdgcajhjg',
                    'checkoutDate': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AssetsCheckoutUpdateManyMutationInput,
        where: types.AssetsCheckoutWhereInput,
    ) -> int:
        """Update multiple AssetsCheckout records

        Parameters
        ----------
        data
            AssetsCheckout data to update the selected AssetsCheckout records to
        where
            Filter to select the AssetsCheckout records to update

        Returns
        -------
        int
            The total number of AssetsCheckout records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AssetsCheckout records
        total = await AssetsCheckout.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsCheckoutWhereInput] = None,
        cursor: Optional[types.AssetsCheckoutWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AssetsCheckout records present in the database

        Parameters
        ----------
        select
            Select the AssetsCheckout fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsCheckout filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsCheckoutCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsCheckout.prisma().count()

        # results: prisma.types.AssetsCheckoutCountAggregateOutput
        results = await AssetsCheckout.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AssetsCheckoutCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsCheckoutWhereInput] = None,
        cursor: Optional[types.AssetsCheckoutWhereUniqueInput] = None,
    ) -> types.AssetsCheckoutCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AssetsCheckoutCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsCheckoutWhereInput] = None,
        cursor: Optional[types.AssetsCheckoutWhereUniqueInput] = None,
    ) -> Union[int, types.AssetsCheckoutCountAggregateOutput]:
        """Count the number of AssetsCheckout records present in the database

        Parameters
        ----------
        select
            Select the AssetsCheckout fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsCheckout filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsCheckoutCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsCheckout.prisma().count()

        # results: prisma.types.AssetsCheckoutCountAggregateOutput
        results = await AssetsCheckout.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AssetsCheckoutCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AssetsCheckoutWhereInput] = None
    ) -> int:
        """Delete multiple AssetsCheckout records.

        Parameters
        ----------
        where
            Optional AssetsCheckout filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AssetsCheckout records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AssetsCheckout records
        total = await AssetsCheckout.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AssetsCheckoutScalarFieldKeys'],
        *,
        where: Optional['types.AssetsCheckoutWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AssetsCheckoutAvgAggregateInput'] = None,
        sum: Optional['types.AssetsCheckoutSumAggregateInput'] = None,
        min: Optional['types.AssetsCheckoutMinAggregateInput'] = None,
        max: Optional['types.AssetsCheckoutMaxAggregateInput'] = None,
        having: Optional['types.AssetsCheckoutScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AssetsCheckoutCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AssetsCheckoutScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AssetsCheckoutScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AssetsCheckoutGroupByOutput']:
        """Group AssetsCheckout records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AssetsCheckout fields to group records by
        where
            AssetsCheckout filter to select records
        take
            Limit the maximum number of AssetsCheckout records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AssetsCheckoutGroupByOutput]
            A list of dictionaries representing the AssetsCheckout record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AssetsCheckout records by assetId values
        # and count how many records are in each group
        results = await AssetsCheckout.prisma().group_by(
            ['assetId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AssetsCheckinActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AssetsCheckin]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AssetsCheckin.prisma().query_raw(
            'SELECT * FROM AssetsCheckin WHERE id = $1',
            'bdjidcidac',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AssetsCheckin
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AssetsCheckin.prisma().query_first(
            'SELECT * FROM AssetsCheckin WHERE assetId = $1',
            'ifgaaagff',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AssetsCheckinCreateInput,
        include: Optional[types.AssetsCheckinInclude] = None
    ) -> _PrismaModelT:
        """Create a new AssetsCheckin record.

        Parameters
        ----------
        data
            AssetsCheckin record data
        include
            Specifies which relations should be loaded on the returned AssetsCheckin model

        Returns
        -------
        prisma.models.AssetsCheckin
            The created AssetsCheckin record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AssetsCheckin record from just the required fields
        assetscheckin = await AssetsCheckin.prisma().create(
            data={
                # data to create a AssetsCheckin record
                'assetId': 'befcddgjce',
                'checkoutId': 'bfhdbjjgfd',
                'employeeUserId': 'cabdjadaji',
                'checkinDate': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AssetsCheckinCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AssetsCheckin records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AssetsCheckin record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AssetsCheckin.prisma().create_many(
            data=[
                {
                    # data to create a AssetsCheckin record
                    'assetId': 'faajgfadf',
                    'checkoutId': 'biaagcedjc',
                    'employeeUserId': 'cahhaghecf',
                    'checkinDate': datetime.datetime.utcnow(),
                },
                {
                    # data to create a AssetsCheckin record
                    'assetId': 'bghcbbcidi',
                    'checkoutId': 'jcgghhgdj',
                    'employeeUserId': 'beehgcebbg',
                    'checkinDate': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AssetsCheckinWhereUniqueInput,
        include: Optional[types.AssetsCheckinInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AssetsCheckin record.

        Parameters
        ----------
        where
            AssetsCheckin filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsCheckin model

        Returns
        -------
        prisma.models.AssetsCheckin
            The deleted AssetsCheckin record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetscheckin = await AssetsCheckin.prisma().delete(
            where={
                'id': 'bhdiaidiaf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AssetsCheckinWhereUniqueInput,
        include: Optional[types.AssetsCheckinInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AssetsCheckin record.

        Parameters
        ----------
        where
            AssetsCheckin filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsCheckin model

        Returns
        -------
        prisma.models.AssetsCheckin
            The found AssetsCheckin record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetscheckin = await AssetsCheckin.prisma().find_unique(
            where={
                'id': 'deajegcfi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AssetsCheckinWhereUniqueInput,
        include: Optional[types.AssetsCheckinInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AssetsCheckin record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AssetsCheckin filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsCheckin model

        Returns
        -------
        prisma.models.AssetsCheckin
            The found AssetsCheckin record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetscheckin = await AssetsCheckin.prisma().find_unique_or_raise(
            where={
                'id': 'gabahhhjf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsCheckinWhereInput] = None,
        cursor: Optional[types.AssetsCheckinWhereUniqueInput] = None,
        include: Optional[types.AssetsCheckinInclude] = None,
        order: Optional[Union[types.AssetsCheckinOrderByInput, List[types.AssetsCheckinOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsCheckinScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AssetsCheckin records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AssetsCheckin records returned
        skip
            Ignore the first N results
        where
            AssetsCheckin filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsCheckin model
        order
            Order the returned AssetsCheckin records by any field
        distinct
            Filter AssetsCheckin records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AssetsCheckin]
            The list of all AssetsCheckin records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AssetsCheckin records
        assetscheckins = await AssetsCheckin.prisma().find_many(take=10)

        # find the first 5 AssetsCheckin records ordered by the checkoutId field
        assetscheckins = await AssetsCheckin.prisma().find_many(
            take=5,
            order={
                'checkoutId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsCheckinWhereInput] = None,
        cursor: Optional[types.AssetsCheckinWhereUniqueInput] = None,
        include: Optional[types.AssetsCheckinInclude] = None,
        order: Optional[Union[types.AssetsCheckinOrderByInput, List[types.AssetsCheckinOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsCheckinScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AssetsCheckin record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsCheckin filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsCheckin model
        order
            Order the returned AssetsCheckin records by any field
        distinct
            Filter AssetsCheckin records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsCheckin
            The first AssetsCheckin record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsCheckin record ordered by the employeeUserId field
        assetscheckin = await AssetsCheckin.prisma().find_first(
            skip=1,
            order={
                'employeeUserId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsCheckinWhereInput] = None,
        cursor: Optional[types.AssetsCheckinWhereUniqueInput] = None,
        include: Optional[types.AssetsCheckinInclude] = None,
        order: Optional[Union[types.AssetsCheckinOrderByInput, List[types.AssetsCheckinOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsCheckinScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AssetsCheckin record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsCheckin filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsCheckin model
        order
            Order the returned AssetsCheckin records by any field
        distinct
            Filter AssetsCheckin records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsCheckin
            The first AssetsCheckin record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsCheckin record ordered by the checkinDate field
        assetscheckin = await AssetsCheckin.prisma().find_first_or_raise(
            skip=1,
            order={
                'checkinDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AssetsCheckinUpdateInput,
        where: types.AssetsCheckinWhereUniqueInput,
        include: Optional[types.AssetsCheckinInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AssetsCheckin record.

        Parameters
        ----------
        data
            AssetsCheckin record data specifying what to update
        where
            AssetsCheckin filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AssetsCheckin model

        Returns
        -------
        prisma.models.AssetsCheckin
            The updated AssetsCheckin record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        assetscheckin = await AssetsCheckin.prisma().update(
            where={
                'id': 'cjagadcjg',
            },
            data={
                # data to update the AssetsCheckin record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AssetsCheckinWhereUniqueInput,
        data: types.AssetsCheckinUpsertInput,
        include: Optional[types.AssetsCheckinInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AssetsCheckin filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AssetsCheckin model

        Returns
        -------
        prisma.models.AssetsCheckin
            The created or updated AssetsCheckin record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetscheckin = await AssetsCheckin.prisma().upsert(
            where={
                'id': 'bifficggej',
            },
            data={
                'create': {
                    'id': 'bifficggej',
                    'assetId': 'bghcbbcidi',
                    'checkoutId': 'jcgghhgdj',
                    'employeeUserId': 'beehgcebbg',
                    'checkinDate': datetime.datetime.utcnow(),
                },
                'update': {
                    'assetId': 'bghcbbcidi',
                    'checkoutId': 'jcgghhgdj',
                    'employeeUserId': 'beehgcebbg',
                    'checkinDate': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AssetsCheckinUpdateManyMutationInput,
        where: types.AssetsCheckinWhereInput,
    ) -> int:
        """Update multiple AssetsCheckin records

        Parameters
        ----------
        data
            AssetsCheckin data to update the selected AssetsCheckin records to
        where
            Filter to select the AssetsCheckin records to update

        Returns
        -------
        int
            The total number of AssetsCheckin records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AssetsCheckin records
        total = await AssetsCheckin.prisma().update_many(
            data={
                'condition': 'bgbbaajbic'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsCheckinWhereInput] = None,
        cursor: Optional[types.AssetsCheckinWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AssetsCheckin records present in the database

        Parameters
        ----------
        select
            Select the AssetsCheckin fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsCheckin filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsCheckinCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsCheckin.prisma().count()

        # results: prisma.types.AssetsCheckinCountAggregateOutput
        results = await AssetsCheckin.prisma().count(
            select={
                '_all': True,
                'notes': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AssetsCheckinCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsCheckinWhereInput] = None,
        cursor: Optional[types.AssetsCheckinWhereUniqueInput] = None,
    ) -> types.AssetsCheckinCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AssetsCheckinCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsCheckinWhereInput] = None,
        cursor: Optional[types.AssetsCheckinWhereUniqueInput] = None,
    ) -> Union[int, types.AssetsCheckinCountAggregateOutput]:
        """Count the number of AssetsCheckin records present in the database

        Parameters
        ----------
        select
            Select the AssetsCheckin fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsCheckin filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsCheckinCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsCheckin.prisma().count()

        # results: prisma.types.AssetsCheckinCountAggregateOutput
        results = await AssetsCheckin.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AssetsCheckinCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AssetsCheckinWhereInput] = None
    ) -> int:
        """Delete multiple AssetsCheckin records.

        Parameters
        ----------
        where
            Optional AssetsCheckin filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AssetsCheckin records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AssetsCheckin records
        total = await AssetsCheckin.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AssetsCheckinScalarFieldKeys'],
        *,
        where: Optional['types.AssetsCheckinWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AssetsCheckinAvgAggregateInput'] = None,
        sum: Optional['types.AssetsCheckinSumAggregateInput'] = None,
        min: Optional['types.AssetsCheckinMinAggregateInput'] = None,
        max: Optional['types.AssetsCheckinMaxAggregateInput'] = None,
        having: Optional['types.AssetsCheckinScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AssetsCheckinCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AssetsCheckinScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AssetsCheckinScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AssetsCheckinGroupByOutput']:
        """Group AssetsCheckin records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AssetsCheckin fields to group records by
        where
            AssetsCheckin filter to select records
        take
            Limit the maximum number of AssetsCheckin records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AssetsCheckinGroupByOutput]
            A list of dictionaries representing the AssetsCheckin record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AssetsCheckin records by updatedAt values
        # and count how many records are in each group
        results = await AssetsCheckin.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AssetsMoveActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AssetsMove]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AssetsMove.prisma().query_raw(
            'SELECT * FROM AssetsMove WHERE id = $1',
            'eegghdhjb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AssetsMove
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AssetsMove.prisma().query_first(
            'SELECT * FROM AssetsMove WHERE assetId = $1',
            'daafgidjg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AssetsMoveCreateInput,
        include: Optional[types.AssetsMoveInclude] = None
    ) -> _PrismaModelT:
        """Create a new AssetsMove record.

        Parameters
        ----------
        data
            AssetsMove record data
        include
            Specifies which relations should be loaded on the returned AssetsMove model

        Returns
        -------
        prisma.models.AssetsMove
            The created AssetsMove record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AssetsMove record from just the required fields
        assetsmove = await AssetsMove.prisma().create(
            data={
                # data to create a AssetsMove record
                'assetId': 'gdcgcgagj',
                'moveType': 'bhceabbgja',
                'moveDate': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AssetsMoveCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AssetsMove records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AssetsMove record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AssetsMove.prisma().create_many(
            data=[
                {
                    # data to create a AssetsMove record
                    'assetId': 'ehabfhegh',
                    'moveType': 'bcajcajjbc',
                    'moveDate': datetime.datetime.utcnow(),
                },
                {
                    # data to create a AssetsMove record
                    'assetId': 'bfdgheeegf',
                    'moveType': 'ececbijji',
                    'moveDate': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AssetsMoveWhereUniqueInput,
        include: Optional[types.AssetsMoveInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AssetsMove record.

        Parameters
        ----------
        where
            AssetsMove filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsMove model

        Returns
        -------
        prisma.models.AssetsMove
            The deleted AssetsMove record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsmove = await AssetsMove.prisma().delete(
            where={
                'id': 'cbcfgdcdhf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AssetsMoveWhereUniqueInput,
        include: Optional[types.AssetsMoveInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AssetsMove record.

        Parameters
        ----------
        where
            AssetsMove filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsMove model

        Returns
        -------
        prisma.models.AssetsMove
            The found AssetsMove record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsmove = await AssetsMove.prisma().find_unique(
            where={
                'id': 'fdgjfbhia',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AssetsMoveWhereUniqueInput,
        include: Optional[types.AssetsMoveInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AssetsMove record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AssetsMove filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsMove model

        Returns
        -------
        prisma.models.AssetsMove
            The found AssetsMove record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsmove = await AssetsMove.prisma().find_unique_or_raise(
            where={
                'id': 'jcehcdchh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsMoveWhereInput] = None,
        cursor: Optional[types.AssetsMoveWhereUniqueInput] = None,
        include: Optional[types.AssetsMoveInclude] = None,
        order: Optional[Union[types.AssetsMoveOrderByInput, List[types.AssetsMoveOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsMoveScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AssetsMove records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AssetsMove records returned
        skip
            Ignore the first N results
        where
            AssetsMove filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsMove model
        order
            Order the returned AssetsMove records by any field
        distinct
            Filter AssetsMove records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AssetsMove]
            The list of all AssetsMove records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AssetsMove records
        assetsmoves = await AssetsMove.prisma().find_many(take=10)

        # find the first 5 AssetsMove records ordered by the moveType field
        assetsmoves = await AssetsMove.prisma().find_many(
            take=5,
            order={
                'moveType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsMoveWhereInput] = None,
        cursor: Optional[types.AssetsMoveWhereUniqueInput] = None,
        include: Optional[types.AssetsMoveInclude] = None,
        order: Optional[Union[types.AssetsMoveOrderByInput, List[types.AssetsMoveOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsMoveScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AssetsMove record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsMove filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsMove model
        order
            Order the returned AssetsMove records by any field
        distinct
            Filter AssetsMove records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsMove
            The first AssetsMove record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsMove record ordered by the moveDate field
        assetsmove = await AssetsMove.prisma().find_first(
            skip=1,
            order={
                'moveDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsMoveWhereInput] = None,
        cursor: Optional[types.AssetsMoveWhereUniqueInput] = None,
        include: Optional[types.AssetsMoveInclude] = None,
        order: Optional[Union[types.AssetsMoveOrderByInput, List[types.AssetsMoveOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsMoveScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AssetsMove record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsMove filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsMove model
        order
            Order the returned AssetsMove records by any field
        distinct
            Filter AssetsMove records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsMove
            The first AssetsMove record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsMove record ordered by the employeeUserId field
        assetsmove = await AssetsMove.prisma().find_first_or_raise(
            skip=1,
            order={
                'employeeUserId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AssetsMoveUpdateInput,
        where: types.AssetsMoveWhereUniqueInput,
        include: Optional[types.AssetsMoveInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AssetsMove record.

        Parameters
        ----------
        data
            AssetsMove record data specifying what to update
        where
            AssetsMove filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AssetsMove model

        Returns
        -------
        prisma.models.AssetsMove
            The updated AssetsMove record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        assetsmove = await AssetsMove.prisma().update(
            where={
                'id': 'bgcbjdhjcc',
            },
            data={
                # data to update the AssetsMove record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AssetsMoveWhereUniqueInput,
        data: types.AssetsMoveUpsertInput,
        include: Optional[types.AssetsMoveInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AssetsMove filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AssetsMove model

        Returns
        -------
        prisma.models.AssetsMove
            The created or updated AssetsMove record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsmove = await AssetsMove.prisma().upsert(
            where={
                'id': 'bieiidcabj',
            },
            data={
                'create': {
                    'id': 'bieiidcabj',
                    'assetId': 'bfdgheeegf',
                    'moveType': 'ececbijji',
                    'moveDate': datetime.datetime.utcnow(),
                },
                'update': {
                    'assetId': 'bfdgheeegf',
                    'moveType': 'ececbijji',
                    'moveDate': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AssetsMoveUpdateManyMutationInput,
        where: types.AssetsMoveWhereInput,
    ) -> int:
        """Update multiple AssetsMove records

        Parameters
        ----------
        data
            AssetsMove data to update the selected AssetsMove records to
        where
            Filter to select the AssetsMove records to update

        Returns
        -------
        int
            The total number of AssetsMove records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AssetsMove records
        total = await AssetsMove.prisma().update_many(
            data={
                'reason': 'bjcbfcieaa'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsMoveWhereInput] = None,
        cursor: Optional[types.AssetsMoveWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AssetsMove records present in the database

        Parameters
        ----------
        select
            Select the AssetsMove fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsMove filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsMoveCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsMove.prisma().count()

        # results: prisma.types.AssetsMoveCountAggregateOutput
        results = await AssetsMove.prisma().count(
            select={
                '_all': True,
                'notes': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AssetsMoveCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsMoveWhereInput] = None,
        cursor: Optional[types.AssetsMoveWhereUniqueInput] = None,
    ) -> types.AssetsMoveCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AssetsMoveCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsMoveWhereInput] = None,
        cursor: Optional[types.AssetsMoveWhereUniqueInput] = None,
    ) -> Union[int, types.AssetsMoveCountAggregateOutput]:
        """Count the number of AssetsMove records present in the database

        Parameters
        ----------
        select
            Select the AssetsMove fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsMove filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsMoveCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsMove.prisma().count()

        # results: prisma.types.AssetsMoveCountAggregateOutput
        results = await AssetsMove.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AssetsMoveCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AssetsMoveWhereInput] = None
    ) -> int:
        """Delete multiple AssetsMove records.

        Parameters
        ----------
        where
            Optional AssetsMove filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AssetsMove records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AssetsMove records
        total = await AssetsMove.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AssetsMoveScalarFieldKeys'],
        *,
        where: Optional['types.AssetsMoveWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AssetsMoveAvgAggregateInput'] = None,
        sum: Optional['types.AssetsMoveSumAggregateInput'] = None,
        min: Optional['types.AssetsMoveMinAggregateInput'] = None,
        max: Optional['types.AssetsMoveMaxAggregateInput'] = None,
        having: Optional['types.AssetsMoveScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AssetsMoveCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AssetsMoveScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AssetsMoveScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AssetsMoveGroupByOutput']:
        """Group AssetsMove records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AssetsMove fields to group records by
        where
            AssetsMove filter to select records
        take
            Limit the maximum number of AssetsMove records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AssetsMoveGroupByOutput]
            A list of dictionaries representing the AssetsMove record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AssetsMove records by updatedAt values
        # and count how many records are in each group
        results = await AssetsMove.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AssetsReserveActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AssetsReserve]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AssetsReserve.prisma().query_raw(
            'SELECT * FROM AssetsReserve WHERE id = $1',
            'cbaaechiej',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AssetsReserve
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AssetsReserve.prisma().query_first(
            'SELECT * FROM AssetsReserve WHERE assetId = $1',
            'iejbeaaeg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AssetsReserveCreateInput,
        include: Optional[types.AssetsReserveInclude] = None
    ) -> _PrismaModelT:
        """Create a new AssetsReserve record.

        Parameters
        ----------
        data
            AssetsReserve record data
        include
            Specifies which relations should be loaded on the returned AssetsReserve model

        Returns
        -------
        prisma.models.AssetsReserve
            The created AssetsReserve record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AssetsReserve record from just the required fields
        assetsreserve = await AssetsReserve.prisma().create(
            data={
                # data to create a AssetsReserve record
                'assetId': 'jcibfcbhf',
                'reservationType': 'chdadcaga',
                'reservationDate': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AssetsReserveCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AssetsReserve records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AssetsReserve record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AssetsReserve.prisma().create_many(
            data=[
                {
                    # data to create a AssetsReserve record
                    'assetId': 'jicieifbh',
                    'reservationType': 'fbahdheji',
                    'reservationDate': datetime.datetime.utcnow(),
                },
                {
                    # data to create a AssetsReserve record
                    'assetId': 'cbbheiicgh',
                    'reservationType': 'beabjeejdg',
                    'reservationDate': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AssetsReserveWhereUniqueInput,
        include: Optional[types.AssetsReserveInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AssetsReserve record.

        Parameters
        ----------
        where
            AssetsReserve filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsReserve model

        Returns
        -------
        prisma.models.AssetsReserve
            The deleted AssetsReserve record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsreserve = await AssetsReserve.prisma().delete(
            where={
                'id': 'bcjhgahffd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AssetsReserveWhereUniqueInput,
        include: Optional[types.AssetsReserveInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AssetsReserve record.

        Parameters
        ----------
        where
            AssetsReserve filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsReserve model

        Returns
        -------
        prisma.models.AssetsReserve
            The found AssetsReserve record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsreserve = await AssetsReserve.prisma().find_unique(
            where={
                'id': 'fbjeiiffa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AssetsReserveWhereUniqueInput,
        include: Optional[types.AssetsReserveInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AssetsReserve record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AssetsReserve filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsReserve model

        Returns
        -------
        prisma.models.AssetsReserve
            The found AssetsReserve record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsreserve = await AssetsReserve.prisma().find_unique_or_raise(
            where={
                'id': 'jhgidcgbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsReserveWhereInput] = None,
        cursor: Optional[types.AssetsReserveWhereUniqueInput] = None,
        include: Optional[types.AssetsReserveInclude] = None,
        order: Optional[Union[types.AssetsReserveOrderByInput, List[types.AssetsReserveOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsReserveScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AssetsReserve records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AssetsReserve records returned
        skip
            Ignore the first N results
        where
            AssetsReserve filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsReserve model
        order
            Order the returned AssetsReserve records by any field
        distinct
            Filter AssetsReserve records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AssetsReserve]
            The list of all AssetsReserve records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AssetsReserve records
        assetsreserves = await AssetsReserve.prisma().find_many(take=10)

        # find the first 5 AssetsReserve records ordered by the reservationType field
        assetsreserves = await AssetsReserve.prisma().find_many(
            take=5,
            order={
                'reservationType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsReserveWhereInput] = None,
        cursor: Optional[types.AssetsReserveWhereUniqueInput] = None,
        include: Optional[types.AssetsReserveInclude] = None,
        order: Optional[Union[types.AssetsReserveOrderByInput, List[types.AssetsReserveOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsReserveScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AssetsReserve record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsReserve filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsReserve model
        order
            Order the returned AssetsReserve records by any field
        distinct
            Filter AssetsReserve records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsReserve
            The first AssetsReserve record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsReserve record ordered by the reservationDate field
        assetsreserve = await AssetsReserve.prisma().find_first(
            skip=1,
            order={
                'reservationDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsReserveWhereInput] = None,
        cursor: Optional[types.AssetsReserveWhereUniqueInput] = None,
        include: Optional[types.AssetsReserveInclude] = None,
        order: Optional[Union[types.AssetsReserveOrderByInput, List[types.AssetsReserveOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsReserveScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AssetsReserve record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsReserve filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsReserve model
        order
            Order the returned AssetsReserve records by any field
        distinct
            Filter AssetsReserve records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsReserve
            The first AssetsReserve record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsReserve record ordered by the purpose field
        assetsreserve = await AssetsReserve.prisma().find_first_or_raise(
            skip=1,
            order={
                'purpose': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AssetsReserveUpdateInput,
        where: types.AssetsReserveWhereUniqueInput,
        include: Optional[types.AssetsReserveInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AssetsReserve record.

        Parameters
        ----------
        data
            AssetsReserve record data specifying what to update
        where
            AssetsReserve filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AssetsReserve model

        Returns
        -------
        prisma.models.AssetsReserve
            The updated AssetsReserve record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        assetsreserve = await AssetsReserve.prisma().update(
            where={
                'id': 'bgjgecfejc',
            },
            data={
                # data to update the AssetsReserve record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AssetsReserveWhereUniqueInput,
        data: types.AssetsReserveUpsertInput,
        include: Optional[types.AssetsReserveInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AssetsReserve filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AssetsReserve model

        Returns
        -------
        prisma.models.AssetsReserve
            The created or updated AssetsReserve record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsreserve = await AssetsReserve.prisma().upsert(
            where={
                'id': 'bgjcgchib',
            },
            data={
                'create': {
                    'id': 'bgjcgchib',
                    'assetId': 'cbbheiicgh',
                    'reservationType': 'beabjeejdg',
                    'reservationDate': datetime.datetime.utcnow(),
                },
                'update': {
                    'assetId': 'cbbheiicgh',
                    'reservationType': 'beabjeejdg',
                    'reservationDate': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AssetsReserveUpdateManyMutationInput,
        where: types.AssetsReserveWhereInput,
    ) -> int:
        """Update multiple AssetsReserve records

        Parameters
        ----------
        data
            AssetsReserve data to update the selected AssetsReserve records to
        where
            Filter to select the AssetsReserve records to update

        Returns
        -------
        int
            The total number of AssetsReserve records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AssetsReserve records
        total = await AssetsReserve.prisma().update_many(
            data={
                'notes': 'bacdaibgfa'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsReserveWhereInput] = None,
        cursor: Optional[types.AssetsReserveWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AssetsReserve records present in the database

        Parameters
        ----------
        select
            Select the AssetsReserve fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsReserve filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsReserveCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsReserve.prisma().count()

        # results: prisma.types.AssetsReserveCountAggregateOutput
        results = await AssetsReserve.prisma().count(
            select={
                '_all': True,
                'employeeUserId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AssetsReserveCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsReserveWhereInput] = None,
        cursor: Optional[types.AssetsReserveWhereUniqueInput] = None,
    ) -> types.AssetsReserveCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AssetsReserveCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsReserveWhereInput] = None,
        cursor: Optional[types.AssetsReserveWhereUniqueInput] = None,
    ) -> Union[int, types.AssetsReserveCountAggregateOutput]:
        """Count the number of AssetsReserve records present in the database

        Parameters
        ----------
        select
            Select the AssetsReserve fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsReserve filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsReserveCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsReserve.prisma().count()

        # results: prisma.types.AssetsReserveCountAggregateOutput
        results = await AssetsReserve.prisma().count(
            select={
                '_all': True,
                'department': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AssetsReserveCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AssetsReserveWhereInput] = None
    ) -> int:
        """Delete multiple AssetsReserve records.

        Parameters
        ----------
        where
            Optional AssetsReserve filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AssetsReserve records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AssetsReserve records
        total = await AssetsReserve.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AssetsReserveScalarFieldKeys'],
        *,
        where: Optional['types.AssetsReserveWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AssetsReserveAvgAggregateInput'] = None,
        sum: Optional['types.AssetsReserveSumAggregateInput'] = None,
        min: Optional['types.AssetsReserveMinAggregateInput'] = None,
        max: Optional['types.AssetsReserveMaxAggregateInput'] = None,
        having: Optional['types.AssetsReserveScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AssetsReserveCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AssetsReserveScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AssetsReserveScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AssetsReserveGroupByOutput']:
        """Group AssetsReserve records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AssetsReserve fields to group records by
        where
            AssetsReserve filter to select records
        take
            Limit the maximum number of AssetsReserve records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AssetsReserveGroupByOutput]
            A list of dictionaries representing the AssetsReserve record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AssetsReserve records by createdAt values
        # and count how many records are in each group
        results = await AssetsReserve.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AssetsLeaseActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AssetsLease]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AssetsLease.prisma().query_raw(
            'SELECT * FROM AssetsLease WHERE id = $1',
            'dchgibach',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AssetsLease
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AssetsLease.prisma().query_first(
            'SELECT * FROM AssetsLease WHERE assetId = $1',
            'fchheijjc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AssetsLeaseCreateInput,
        include: Optional[types.AssetsLeaseInclude] = None
    ) -> _PrismaModelT:
        """Create a new AssetsLease record.

        Parameters
        ----------
        data
            AssetsLease record data
        include
            Specifies which relations should be loaded on the returned AssetsLease model

        Returns
        -------
        prisma.models.AssetsLease
            The created AssetsLease record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AssetsLease record from just the required fields
        assetslease = await AssetsLease.prisma().create(
            data={
                # data to create a AssetsLease record
                'assetId': 'cacjdfhejh',
                'lessee': 'bdbifjhbbi',
                'leaseStartDate': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AssetsLeaseCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AssetsLease records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AssetsLease record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AssetsLease.prisma().create_many(
            data=[
                {
                    # data to create a AssetsLease record
                    'assetId': 'cbccbbcdfb',
                    'lessee': 'bacejedaca',
                    'leaseStartDate': datetime.datetime.utcnow(),
                },
                {
                    # data to create a AssetsLease record
                    'assetId': 'bhbhdahfaj',
                    'lessee': 'bfjibceaec',
                    'leaseStartDate': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AssetsLeaseWhereUniqueInput,
        include: Optional[types.AssetsLeaseInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AssetsLease record.

        Parameters
        ----------
        where
            AssetsLease filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsLease model

        Returns
        -------
        prisma.models.AssetsLease
            The deleted AssetsLease record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetslease = await AssetsLease.prisma().delete(
            where={
                'id': 'ibhgcdbgd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AssetsLeaseWhereUniqueInput,
        include: Optional[types.AssetsLeaseInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AssetsLease record.

        Parameters
        ----------
        where
            AssetsLease filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsLease model

        Returns
        -------
        prisma.models.AssetsLease
            The found AssetsLease record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetslease = await AssetsLease.prisma().find_unique(
            where={
                'id': 'badaffhddg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AssetsLeaseWhereUniqueInput,
        include: Optional[types.AssetsLeaseInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AssetsLease record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AssetsLease filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsLease model

        Returns
        -------
        prisma.models.AssetsLease
            The found AssetsLease record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetslease = await AssetsLease.prisma().find_unique_or_raise(
            where={
                'id': 'bbdbfcfihd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsLeaseWhereInput] = None,
        cursor: Optional[types.AssetsLeaseWhereUniqueInput] = None,
        include: Optional[types.AssetsLeaseInclude] = None,
        order: Optional[Union[types.AssetsLeaseOrderByInput, List[types.AssetsLeaseOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsLeaseScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AssetsLease records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AssetsLease records returned
        skip
            Ignore the first N results
        where
            AssetsLease filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsLease model
        order
            Order the returned AssetsLease records by any field
        distinct
            Filter AssetsLease records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AssetsLease]
            The list of all AssetsLease records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AssetsLease records
        assetsleases = await AssetsLease.prisma().find_many(take=10)

        # find the first 5 AssetsLease records ordered by the lessee field
        assetsleases = await AssetsLease.prisma().find_many(
            take=5,
            order={
                'lessee': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsLeaseWhereInput] = None,
        cursor: Optional[types.AssetsLeaseWhereUniqueInput] = None,
        include: Optional[types.AssetsLeaseInclude] = None,
        order: Optional[Union[types.AssetsLeaseOrderByInput, List[types.AssetsLeaseOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsLeaseScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AssetsLease record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsLease filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsLease model
        order
            Order the returned AssetsLease records by any field
        distinct
            Filter AssetsLease records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsLease
            The first AssetsLease record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsLease record ordered by the leaseStartDate field
        assetslease = await AssetsLease.prisma().find_first(
            skip=1,
            order={
                'leaseStartDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsLeaseWhereInput] = None,
        cursor: Optional[types.AssetsLeaseWhereUniqueInput] = None,
        include: Optional[types.AssetsLeaseInclude] = None,
        order: Optional[Union[types.AssetsLeaseOrderByInput, List[types.AssetsLeaseOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsLeaseScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AssetsLease record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsLease filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsLease model
        order
            Order the returned AssetsLease records by any field
        distinct
            Filter AssetsLease records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsLease
            The first AssetsLease record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsLease record ordered by the leaseEndDate field
        assetslease = await AssetsLease.prisma().find_first_or_raise(
            skip=1,
            order={
                'leaseEndDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AssetsLeaseUpdateInput,
        where: types.AssetsLeaseWhereUniqueInput,
        include: Optional[types.AssetsLeaseInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AssetsLease record.

        Parameters
        ----------
        data
            AssetsLease record data specifying what to update
        where
            AssetsLease filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AssetsLease model

        Returns
        -------
        prisma.models.AssetsLease
            The updated AssetsLease record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        assetslease = await AssetsLease.prisma().update(
            where={
                'id': 'cbagggbji',
            },
            data={
                # data to update the AssetsLease record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AssetsLeaseWhereUniqueInput,
        data: types.AssetsLeaseUpsertInput,
        include: Optional[types.AssetsLeaseInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AssetsLease filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AssetsLease model

        Returns
        -------
        prisma.models.AssetsLease
            The created or updated AssetsLease record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetslease = await AssetsLease.prisma().upsert(
            where={
                'id': 'bchgafhjed',
            },
            data={
                'create': {
                    'id': 'bchgafhjed',
                    'assetId': 'bhbhdahfaj',
                    'lessee': 'bfjibceaec',
                    'leaseStartDate': datetime.datetime.utcnow(),
                },
                'update': {
                    'assetId': 'bhbhdahfaj',
                    'lessee': 'bfjibceaec',
                    'leaseStartDate': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AssetsLeaseUpdateManyMutationInput,
        where: types.AssetsLeaseWhereInput,
    ) -> int:
        """Update multiple AssetsLease records

        Parameters
        ----------
        data
            AssetsLease data to update the selected AssetsLease records to
        where
            Filter to select the AssetsLease records to update

        Returns
        -------
        int
            The total number of AssetsLease records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AssetsLease records
        total = await AssetsLease.prisma().update_many(
            data={
                'conditions': 'heffgjdei'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsLeaseWhereInput] = None,
        cursor: Optional[types.AssetsLeaseWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AssetsLease records present in the database

        Parameters
        ----------
        select
            Select the AssetsLease fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsLease filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsLeaseCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsLease.prisma().count()

        # results: prisma.types.AssetsLeaseCountAggregateOutput
        results = await AssetsLease.prisma().count(
            select={
                '_all': True,
                'notes': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AssetsLeaseCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsLeaseWhereInput] = None,
        cursor: Optional[types.AssetsLeaseWhereUniqueInput] = None,
    ) -> types.AssetsLeaseCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AssetsLeaseCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsLeaseWhereInput] = None,
        cursor: Optional[types.AssetsLeaseWhereUniqueInput] = None,
    ) -> Union[int, types.AssetsLeaseCountAggregateOutput]:
        """Count the number of AssetsLease records present in the database

        Parameters
        ----------
        select
            Select the AssetsLease fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsLease filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsLeaseCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsLease.prisma().count()

        # results: prisma.types.AssetsLeaseCountAggregateOutput
        results = await AssetsLease.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AssetsLeaseCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AssetsLeaseWhereInput] = None
    ) -> int:
        """Delete multiple AssetsLease records.

        Parameters
        ----------
        where
            Optional AssetsLease filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AssetsLease records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AssetsLease records
        total = await AssetsLease.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AssetsLeaseScalarFieldKeys'],
        *,
        where: Optional['types.AssetsLeaseWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AssetsLeaseAvgAggregateInput'] = None,
        sum: Optional['types.AssetsLeaseSumAggregateInput'] = None,
        min: Optional['types.AssetsLeaseMinAggregateInput'] = None,
        max: Optional['types.AssetsLeaseMaxAggregateInput'] = None,
        having: Optional['types.AssetsLeaseScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AssetsLeaseCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AssetsLeaseScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AssetsLeaseScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AssetsLeaseGroupByOutput']:
        """Group AssetsLease records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AssetsLease fields to group records by
        where
            AssetsLease filter to select records
        take
            Limit the maximum number of AssetsLease records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AssetsLeaseGroupByOutput]
            A list of dictionaries representing the AssetsLease record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AssetsLease records by updatedAt values
        # and count how many records are in each group
        results = await AssetsLease.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AssetsLeaseReturnActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AssetsLeaseReturn]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AssetsLeaseReturn.prisma().query_raw(
            'SELECT * FROM AssetsLeaseReturn WHERE id = $1',
            'dahihgbeb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AssetsLeaseReturn
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AssetsLeaseReturn.prisma().query_first(
            'SELECT * FROM AssetsLeaseReturn WHERE assetId = $1',
            'bgheaejbcc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AssetsLeaseReturnCreateInput,
        include: Optional[types.AssetsLeaseReturnInclude] = None
    ) -> _PrismaModelT:
        """Create a new AssetsLeaseReturn record.

        Parameters
        ----------
        data
            AssetsLeaseReturn record data
        include
            Specifies which relations should be loaded on the returned AssetsLeaseReturn model

        Returns
        -------
        prisma.models.AssetsLeaseReturn
            The created AssetsLeaseReturn record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AssetsLeaseReturn record from just the required fields
        assetsleasereturn = await AssetsLeaseReturn.prisma().create(
            data={
                # data to create a AssetsLeaseReturn record
                'assetId': 'bfcgifeged',
                'leaseId': 'jfiahhbae',
                'returnDate': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AssetsLeaseReturnCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AssetsLeaseReturn records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AssetsLeaseReturn record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AssetsLeaseReturn.prisma().create_many(
            data=[
                {
                    # data to create a AssetsLeaseReturn record
                    'assetId': 'bfbdafajcb',
                    'leaseId': 'caeghehde',
                    'returnDate': datetime.datetime.utcnow(),
                },
                {
                    # data to create a AssetsLeaseReturn record
                    'assetId': 'caghgfbggd',
                    'leaseId': 'bbidjbbjaa',
                    'returnDate': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AssetsLeaseReturnWhereUniqueInput,
        include: Optional[types.AssetsLeaseReturnInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AssetsLeaseReturn record.

        Parameters
        ----------
        where
            AssetsLeaseReturn filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsLeaseReturn model

        Returns
        -------
        prisma.models.AssetsLeaseReturn
            The deleted AssetsLeaseReturn record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsleasereturn = await AssetsLeaseReturn.prisma().delete(
            where={
                'id': 'bfijhaejdd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AssetsLeaseReturnWhereUniqueInput,
        include: Optional[types.AssetsLeaseReturnInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AssetsLeaseReturn record.

        Parameters
        ----------
        where
            AssetsLeaseReturn filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsLeaseReturn model

        Returns
        -------
        prisma.models.AssetsLeaseReturn
            The found AssetsLeaseReturn record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsleasereturn = await AssetsLeaseReturn.prisma().find_unique(
            where={
                'id': 'bcedehfiji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AssetsLeaseReturnWhereUniqueInput,
        include: Optional[types.AssetsLeaseReturnInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AssetsLeaseReturn record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AssetsLeaseReturn filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsLeaseReturn model

        Returns
        -------
        prisma.models.AssetsLeaseReturn
            The found AssetsLeaseReturn record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsleasereturn = await AssetsLeaseReturn.prisma().find_unique_or_raise(
            where={
                'id': 'bdgjicijhb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsLeaseReturnWhereInput] = None,
        cursor: Optional[types.AssetsLeaseReturnWhereUniqueInput] = None,
        include: Optional[types.AssetsLeaseReturnInclude] = None,
        order: Optional[Union[types.AssetsLeaseReturnOrderByInput, List[types.AssetsLeaseReturnOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsLeaseReturnScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AssetsLeaseReturn records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AssetsLeaseReturn records returned
        skip
            Ignore the first N results
        where
            AssetsLeaseReturn filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsLeaseReturn model
        order
            Order the returned AssetsLeaseReturn records by any field
        distinct
            Filter AssetsLeaseReturn records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AssetsLeaseReturn]
            The list of all AssetsLeaseReturn records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AssetsLeaseReturn records
        assetsleasereturns = await AssetsLeaseReturn.prisma().find_many(take=10)

        # find the first 5 AssetsLeaseReturn records ordered by the leaseId field
        assetsleasereturns = await AssetsLeaseReturn.prisma().find_many(
            take=5,
            order={
                'leaseId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsLeaseReturnWhereInput] = None,
        cursor: Optional[types.AssetsLeaseReturnWhereUniqueInput] = None,
        include: Optional[types.AssetsLeaseReturnInclude] = None,
        order: Optional[Union[types.AssetsLeaseReturnOrderByInput, List[types.AssetsLeaseReturnOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsLeaseReturnScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AssetsLeaseReturn record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsLeaseReturn filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsLeaseReturn model
        order
            Order the returned AssetsLeaseReturn records by any field
        distinct
            Filter AssetsLeaseReturn records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsLeaseReturn
            The first AssetsLeaseReturn record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsLeaseReturn record ordered by the returnDate field
        assetsleasereturn = await AssetsLeaseReturn.prisma().find_first(
            skip=1,
            order={
                'returnDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsLeaseReturnWhereInput] = None,
        cursor: Optional[types.AssetsLeaseReturnWhereUniqueInput] = None,
        include: Optional[types.AssetsLeaseReturnInclude] = None,
        order: Optional[Union[types.AssetsLeaseReturnOrderByInput, List[types.AssetsLeaseReturnOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsLeaseReturnScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AssetsLeaseReturn record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsLeaseReturn filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsLeaseReturn model
        order
            Order the returned AssetsLeaseReturn records by any field
        distinct
            Filter AssetsLeaseReturn records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsLeaseReturn
            The first AssetsLeaseReturn record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsLeaseReturn record ordered by the condition field
        assetsleasereturn = await AssetsLeaseReturn.prisma().find_first_or_raise(
            skip=1,
            order={
                'condition': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AssetsLeaseReturnUpdateInput,
        where: types.AssetsLeaseReturnWhereUniqueInput,
        include: Optional[types.AssetsLeaseReturnInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AssetsLeaseReturn record.

        Parameters
        ----------
        data
            AssetsLeaseReturn record data specifying what to update
        where
            AssetsLeaseReturn filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AssetsLeaseReturn model

        Returns
        -------
        prisma.models.AssetsLeaseReturn
            The updated AssetsLeaseReturn record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        assetsleasereturn = await AssetsLeaseReturn.prisma().update(
            where={
                'id': 'bghifjdeia',
            },
            data={
                # data to update the AssetsLeaseReturn record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AssetsLeaseReturnWhereUniqueInput,
        data: types.AssetsLeaseReturnUpsertInput,
        include: Optional[types.AssetsLeaseReturnInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AssetsLeaseReturn filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AssetsLeaseReturn model

        Returns
        -------
        prisma.models.AssetsLeaseReturn
            The created or updated AssetsLeaseReturn record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsleasereturn = await AssetsLeaseReturn.prisma().upsert(
            where={
                'id': 'eadfcbbcb',
            },
            data={
                'create': {
                    'id': 'eadfcbbcb',
                    'assetId': 'caghgfbggd',
                    'leaseId': 'bbidjbbjaa',
                    'returnDate': datetime.datetime.utcnow(),
                },
                'update': {
                    'assetId': 'caghgfbggd',
                    'leaseId': 'bbidjbbjaa',
                    'returnDate': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AssetsLeaseReturnUpdateManyMutationInput,
        where: types.AssetsLeaseReturnWhereInput,
    ) -> int:
        """Update multiple AssetsLeaseReturn records

        Parameters
        ----------
        data
            AssetsLeaseReturn data to update the selected AssetsLeaseReturn records to
        where
            Filter to select the AssetsLeaseReturn records to update

        Returns
        -------
        int
            The total number of AssetsLeaseReturn records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AssetsLeaseReturn records
        total = await AssetsLeaseReturn.prisma().update_many(
            data={
                'notes': 'geihgahba'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsLeaseReturnWhereInput] = None,
        cursor: Optional[types.AssetsLeaseReturnWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AssetsLeaseReturn records present in the database

        Parameters
        ----------
        select
            Select the AssetsLeaseReturn fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsLeaseReturn filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsLeaseReturnCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsLeaseReturn.prisma().count()

        # results: prisma.types.AssetsLeaseReturnCountAggregateOutput
        results = await AssetsLeaseReturn.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AssetsLeaseReturnCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsLeaseReturnWhereInput] = None,
        cursor: Optional[types.AssetsLeaseReturnWhereUniqueInput] = None,
    ) -> types.AssetsLeaseReturnCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AssetsLeaseReturnCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsLeaseReturnWhereInput] = None,
        cursor: Optional[types.AssetsLeaseReturnWhereUniqueInput] = None,
    ) -> Union[int, types.AssetsLeaseReturnCountAggregateOutput]:
        """Count the number of AssetsLeaseReturn records present in the database

        Parameters
        ----------
        select
            Select the AssetsLeaseReturn fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsLeaseReturn filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsLeaseReturnCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsLeaseReturn.prisma().count()

        # results: prisma.types.AssetsLeaseReturnCountAggregateOutput
        results = await AssetsLeaseReturn.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AssetsLeaseReturnCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AssetsLeaseReturnWhereInput] = None
    ) -> int:
        """Delete multiple AssetsLeaseReturn records.

        Parameters
        ----------
        where
            Optional AssetsLeaseReturn filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AssetsLeaseReturn records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AssetsLeaseReturn records
        total = await AssetsLeaseReturn.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AssetsLeaseReturnScalarFieldKeys'],
        *,
        where: Optional['types.AssetsLeaseReturnWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AssetsLeaseReturnAvgAggregateInput'] = None,
        sum: Optional['types.AssetsLeaseReturnSumAggregateInput'] = None,
        min: Optional['types.AssetsLeaseReturnMinAggregateInput'] = None,
        max: Optional['types.AssetsLeaseReturnMaxAggregateInput'] = None,
        having: Optional['types.AssetsLeaseReturnScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AssetsLeaseReturnCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AssetsLeaseReturnScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AssetsLeaseReturnScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AssetsLeaseReturnGroupByOutput']:
        """Group AssetsLeaseReturn records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AssetsLeaseReturn fields to group records by
        where
            AssetsLeaseReturn filter to select records
        take
            Limit the maximum number of AssetsLeaseReturn records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AssetsLeaseReturnGroupByOutput]
            A list of dictionaries representing the AssetsLeaseReturn record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AssetsLeaseReturn records by id values
        # and count how many records are in each group
        results = await AssetsLeaseReturn.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AssetsDisposeActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AssetsDispose]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AssetsDispose.prisma().query_raw(
            'SELECT * FROM AssetsDispose WHERE id = $1',
            'gahdcdhbj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AssetsDispose
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AssetsDispose.prisma().query_first(
            'SELECT * FROM AssetsDispose WHERE assetId = $1',
            'begiijahea',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AssetsDisposeCreateInput,
        include: Optional[types.AssetsDisposeInclude] = None
    ) -> _PrismaModelT:
        """Create a new AssetsDispose record.

        Parameters
        ----------
        data
            AssetsDispose record data
        include
            Specifies which relations should be loaded on the returned AssetsDispose model

        Returns
        -------
        prisma.models.AssetsDispose
            The created AssetsDispose record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AssetsDispose record from just the required fields
        assetsdispose = await AssetsDispose.prisma().create(
            data={
                # data to create a AssetsDispose record
                'assetId': 'gcjadjaaf',
                'disposeDate': datetime.datetime.utcnow(),
                'disposalMethod': 'bcbebgiaic',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AssetsDisposeCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AssetsDispose records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AssetsDispose record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AssetsDispose.prisma().create_many(
            data=[
                {
                    # data to create a AssetsDispose record
                    'assetId': 'ijigbdcbj',
                    'disposeDate': datetime.datetime.utcnow(),
                    'disposalMethod': 'gfidhicai',
                },
                {
                    # data to create a AssetsDispose record
                    'assetId': 'jfegcaafh',
                    'disposeDate': datetime.datetime.utcnow(),
                    'disposalMethod': 'bcbeiajjfa',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AssetsDisposeWhereUniqueInput,
        include: Optional[types.AssetsDisposeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AssetsDispose record.

        Parameters
        ----------
        where
            AssetsDispose filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsDispose model

        Returns
        -------
        prisma.models.AssetsDispose
            The deleted AssetsDispose record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsdispose = await AssetsDispose.prisma().delete(
            where={
                'id': 'baehicaajf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AssetsDisposeWhereUniqueInput,
        include: Optional[types.AssetsDisposeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AssetsDispose record.

        Parameters
        ----------
        where
            AssetsDispose filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsDispose model

        Returns
        -------
        prisma.models.AssetsDispose
            The found AssetsDispose record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsdispose = await AssetsDispose.prisma().find_unique(
            where={
                'id': 'bdachdeiga',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AssetsDisposeWhereUniqueInput,
        include: Optional[types.AssetsDisposeInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AssetsDispose record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AssetsDispose filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsDispose model

        Returns
        -------
        prisma.models.AssetsDispose
            The found AssetsDispose record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsdispose = await AssetsDispose.prisma().find_unique_or_raise(
            where={
                'id': 'ijdafccef',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsDisposeWhereInput] = None,
        cursor: Optional[types.AssetsDisposeWhereUniqueInput] = None,
        include: Optional[types.AssetsDisposeInclude] = None,
        order: Optional[Union[types.AssetsDisposeOrderByInput, List[types.AssetsDisposeOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsDisposeScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AssetsDispose records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AssetsDispose records returned
        skip
            Ignore the first N results
        where
            AssetsDispose filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsDispose model
        order
            Order the returned AssetsDispose records by any field
        distinct
            Filter AssetsDispose records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AssetsDispose]
            The list of all AssetsDispose records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AssetsDispose records
        assetsdisposes = await AssetsDispose.prisma().find_many(take=10)

        # find the first 5 AssetsDispose records ordered by the disposeDate field
        assetsdisposes = await AssetsDispose.prisma().find_many(
            take=5,
            order={
                'disposeDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsDisposeWhereInput] = None,
        cursor: Optional[types.AssetsDisposeWhereUniqueInput] = None,
        include: Optional[types.AssetsDisposeInclude] = None,
        order: Optional[Union[types.AssetsDisposeOrderByInput, List[types.AssetsDisposeOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsDisposeScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AssetsDispose record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsDispose filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsDispose model
        order
            Order the returned AssetsDispose records by any field
        distinct
            Filter AssetsDispose records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsDispose
            The first AssetsDispose record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsDispose record ordered by the disposalMethod field
        assetsdispose = await AssetsDispose.prisma().find_first(
            skip=1,
            order={
                'disposalMethod': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsDisposeWhereInput] = None,
        cursor: Optional[types.AssetsDisposeWhereUniqueInput] = None,
        include: Optional[types.AssetsDisposeInclude] = None,
        order: Optional[Union[types.AssetsDisposeOrderByInput, List[types.AssetsDisposeOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsDisposeScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AssetsDispose record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsDispose filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsDispose model
        order
            Order the returned AssetsDispose records by any field
        distinct
            Filter AssetsDispose records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsDispose
            The first AssetsDispose record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsDispose record ordered by the disposeReason field
        assetsdispose = await AssetsDispose.prisma().find_first_or_raise(
            skip=1,
            order={
                'disposeReason': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AssetsDisposeUpdateInput,
        where: types.AssetsDisposeWhereUniqueInput,
        include: Optional[types.AssetsDisposeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AssetsDispose record.

        Parameters
        ----------
        data
            AssetsDispose record data specifying what to update
        where
            AssetsDispose filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AssetsDispose model

        Returns
        -------
        prisma.models.AssetsDispose
            The updated AssetsDispose record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        assetsdispose = await AssetsDispose.prisma().update(
            where={
                'id': 'ciaaiddag',
            },
            data={
                # data to update the AssetsDispose record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AssetsDisposeWhereUniqueInput,
        data: types.AssetsDisposeUpsertInput,
        include: Optional[types.AssetsDisposeInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AssetsDispose filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AssetsDispose model

        Returns
        -------
        prisma.models.AssetsDispose
            The created or updated AssetsDispose record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsdispose = await AssetsDispose.prisma().upsert(
            where={
                'id': 'fejggijff',
            },
            data={
                'create': {
                    'id': 'fejggijff',
                    'assetId': 'jfegcaafh',
                    'disposeDate': datetime.datetime.utcnow(),
                    'disposalMethod': 'bcbeiajjfa',
                },
                'update': {
                    'assetId': 'jfegcaafh',
                    'disposeDate': datetime.datetime.utcnow(),
                    'disposalMethod': 'bcbeiajjfa',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AssetsDisposeUpdateManyMutationInput,
        where: types.AssetsDisposeWhereInput,
    ) -> int:
        """Update multiple AssetsDispose records

        Parameters
        ----------
        data
            AssetsDispose data to update the selected AssetsDispose records to
        where
            Filter to select the AssetsDispose records to update

        Returns
        -------
        int
            The total number of AssetsDispose records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AssetsDispose records
        total = await AssetsDispose.prisma().update_many(
            data={
                'disposeValue': Decimal('76790008.209829')
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsDisposeWhereInput] = None,
        cursor: Optional[types.AssetsDisposeWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AssetsDispose records present in the database

        Parameters
        ----------
        select
            Select the AssetsDispose fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsDispose filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsDisposeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsDispose.prisma().count()

        # results: prisma.types.AssetsDisposeCountAggregateOutput
        results = await AssetsDispose.prisma().count(
            select={
                '_all': True,
                'notes': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AssetsDisposeCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsDisposeWhereInput] = None,
        cursor: Optional[types.AssetsDisposeWhereUniqueInput] = None,
    ) -> types.AssetsDisposeCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AssetsDisposeCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsDisposeWhereInput] = None,
        cursor: Optional[types.AssetsDisposeWhereUniqueInput] = None,
    ) -> Union[int, types.AssetsDisposeCountAggregateOutput]:
        """Count the number of AssetsDispose records present in the database

        Parameters
        ----------
        select
            Select the AssetsDispose fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsDispose filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsDisposeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsDispose.prisma().count()

        # results: prisma.types.AssetsDisposeCountAggregateOutput
        results = await AssetsDispose.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AssetsDisposeCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AssetsDisposeWhereInput] = None
    ) -> int:
        """Delete multiple AssetsDispose records.

        Parameters
        ----------
        where
            Optional AssetsDispose filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AssetsDispose records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AssetsDispose records
        total = await AssetsDispose.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AssetsDisposeScalarFieldKeys'],
        *,
        where: Optional['types.AssetsDisposeWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AssetsDisposeAvgAggregateInput'] = None,
        sum: Optional['types.AssetsDisposeSumAggregateInput'] = None,
        min: Optional['types.AssetsDisposeMinAggregateInput'] = None,
        max: Optional['types.AssetsDisposeMaxAggregateInput'] = None,
        having: Optional['types.AssetsDisposeScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AssetsDisposeCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AssetsDisposeScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AssetsDisposeScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AssetsDisposeGroupByOutput']:
        """Group AssetsDispose records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AssetsDispose fields to group records by
        where
            AssetsDispose filter to select records
        take
            Limit the maximum number of AssetsDispose records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AssetsDisposeGroupByOutput]
            A list of dictionaries representing the AssetsDispose record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AssetsDispose records by updatedAt values
        # and count how many records are in each group
        results = await AssetsDispose.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AssetsMaintenanceActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AssetsMaintenance]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AssetsMaintenance.prisma().query_raw(
            'SELECT * FROM AssetsMaintenance WHERE id = $1',
            'cefjaadec',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AssetsMaintenance
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AssetsMaintenance.prisma().query_first(
            'SELECT * FROM AssetsMaintenance WHERE assetId = $1',
            'ibbigdigd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AssetsMaintenanceCreateInput,
        include: Optional[types.AssetsMaintenanceInclude] = None
    ) -> _PrismaModelT:
        """Create a new AssetsMaintenance record.

        Parameters
        ----------
        data
            AssetsMaintenance record data
        include
            Specifies which relations should be loaded on the returned AssetsMaintenance model

        Returns
        -------
        prisma.models.AssetsMaintenance
            The created AssetsMaintenance record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AssetsMaintenance record from just the required fields
        assetsmaintenance = await AssetsMaintenance.prisma().create(
            data={
                # data to create a AssetsMaintenance record
                'assetId': 'bdiiiabbii',
                'title': 'hfcfhhadh',
                'status': 'bbihggdcji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AssetsMaintenanceCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AssetsMaintenance records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AssetsMaintenance record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AssetsMaintenance.prisma().create_many(
            data=[
                {
                    # data to create a AssetsMaintenance record
                    'assetId': 'hgjgibdgd',
                    'title': 'bcbecjfice',
                    'status': 'bacbebhjjd',
                },
                {
                    # data to create a AssetsMaintenance record
                    'assetId': 'dfbfaddhe',
                    'title': 'bdcbbieibf',
                    'status': 'dgjhdcggi',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AssetsMaintenanceWhereUniqueInput,
        include: Optional[types.AssetsMaintenanceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AssetsMaintenance record.

        Parameters
        ----------
        where
            AssetsMaintenance filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsMaintenance model

        Returns
        -------
        prisma.models.AssetsMaintenance
            The deleted AssetsMaintenance record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsmaintenance = await AssetsMaintenance.prisma().delete(
            where={
                'id': 'bbjbcdfabd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AssetsMaintenanceWhereUniqueInput,
        include: Optional[types.AssetsMaintenanceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AssetsMaintenance record.

        Parameters
        ----------
        where
            AssetsMaintenance filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsMaintenance model

        Returns
        -------
        prisma.models.AssetsMaintenance
            The found AssetsMaintenance record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsmaintenance = await AssetsMaintenance.prisma().find_unique(
            where={
                'id': 'gchfgbcec',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AssetsMaintenanceWhereUniqueInput,
        include: Optional[types.AssetsMaintenanceInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AssetsMaintenance record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AssetsMaintenance filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsMaintenance model

        Returns
        -------
        prisma.models.AssetsMaintenance
            The found AssetsMaintenance record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsmaintenance = await AssetsMaintenance.prisma().find_unique_or_raise(
            where={
                'id': 'bihcjfcjah',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsMaintenanceWhereInput] = None,
        cursor: Optional[types.AssetsMaintenanceWhereUniqueInput] = None,
        include: Optional[types.AssetsMaintenanceInclude] = None,
        order: Optional[Union[types.AssetsMaintenanceOrderByInput, List[types.AssetsMaintenanceOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsMaintenanceScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AssetsMaintenance records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AssetsMaintenance records returned
        skip
            Ignore the first N results
        where
            AssetsMaintenance filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsMaintenance model
        order
            Order the returned AssetsMaintenance records by any field
        distinct
            Filter AssetsMaintenance records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AssetsMaintenance]
            The list of all AssetsMaintenance records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AssetsMaintenance records
        assetsmaintenances = await AssetsMaintenance.prisma().find_many(take=10)

        # find the first 5 AssetsMaintenance records ordered by the title field
        assetsmaintenances = await AssetsMaintenance.prisma().find_many(
            take=5,
            order={
                'title': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsMaintenanceWhereInput] = None,
        cursor: Optional[types.AssetsMaintenanceWhereUniqueInput] = None,
        include: Optional[types.AssetsMaintenanceInclude] = None,
        order: Optional[Union[types.AssetsMaintenanceOrderByInput, List[types.AssetsMaintenanceOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsMaintenanceScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AssetsMaintenance record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsMaintenance filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsMaintenance model
        order
            Order the returned AssetsMaintenance records by any field
        distinct
            Filter AssetsMaintenance records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsMaintenance
            The first AssetsMaintenance record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsMaintenance record ordered by the details field
        assetsmaintenance = await AssetsMaintenance.prisma().find_first(
            skip=1,
            order={
                'details': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsMaintenanceWhereInput] = None,
        cursor: Optional[types.AssetsMaintenanceWhereUniqueInput] = None,
        include: Optional[types.AssetsMaintenanceInclude] = None,
        order: Optional[Union[types.AssetsMaintenanceOrderByInput, List[types.AssetsMaintenanceOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsMaintenanceScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AssetsMaintenance record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsMaintenance filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsMaintenance model
        order
            Order the returned AssetsMaintenance records by any field
        distinct
            Filter AssetsMaintenance records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsMaintenance
            The first AssetsMaintenance record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsMaintenance record ordered by the dueDate field
        assetsmaintenance = await AssetsMaintenance.prisma().find_first_or_raise(
            skip=1,
            order={
                'dueDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AssetsMaintenanceUpdateInput,
        where: types.AssetsMaintenanceWhereUniqueInput,
        include: Optional[types.AssetsMaintenanceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AssetsMaintenance record.

        Parameters
        ----------
        data
            AssetsMaintenance record data specifying what to update
        where
            AssetsMaintenance filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AssetsMaintenance model

        Returns
        -------
        prisma.models.AssetsMaintenance
            The updated AssetsMaintenance record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        assetsmaintenance = await AssetsMaintenance.prisma().update(
            where={
                'id': 'bhjdcicaii',
            },
            data={
                # data to update the AssetsMaintenance record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AssetsMaintenanceWhereUniqueInput,
        data: types.AssetsMaintenanceUpsertInput,
        include: Optional[types.AssetsMaintenanceInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AssetsMaintenance filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AssetsMaintenance model

        Returns
        -------
        prisma.models.AssetsMaintenance
            The created or updated AssetsMaintenance record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsmaintenance = await AssetsMaintenance.prisma().upsert(
            where={
                'id': 'bibedjhcej',
            },
            data={
                'create': {
                    'id': 'bibedjhcej',
                    'assetId': 'dfbfaddhe',
                    'title': 'bdcbbieibf',
                    'status': 'dgjhdcggi',
                },
                'update': {
                    'assetId': 'dfbfaddhe',
                    'title': 'bdcbbieibf',
                    'status': 'dgjhdcggi',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AssetsMaintenanceUpdateManyMutationInput,
        where: types.AssetsMaintenanceWhereInput,
    ) -> int:
        """Update multiple AssetsMaintenance records

        Parameters
        ----------
        data
            AssetsMaintenance data to update the selected AssetsMaintenance records to
        where
            Filter to select the AssetsMaintenance records to update

        Returns
        -------
        int
            The total number of AssetsMaintenance records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AssetsMaintenance records
        total = await AssetsMaintenance.prisma().update_many(
            data={
                'maintenanceBy': 'bjcdajabfa'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsMaintenanceWhereInput] = None,
        cursor: Optional[types.AssetsMaintenanceWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AssetsMaintenance records present in the database

        Parameters
        ----------
        select
            Select the AssetsMaintenance fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsMaintenance filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsMaintenanceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsMaintenance.prisma().count()

        # results: prisma.types.AssetsMaintenanceCountAggregateOutput
        results = await AssetsMaintenance.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AssetsMaintenanceCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsMaintenanceWhereInput] = None,
        cursor: Optional[types.AssetsMaintenanceWhereUniqueInput] = None,
    ) -> types.AssetsMaintenanceCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AssetsMaintenanceCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsMaintenanceWhereInput] = None,
        cursor: Optional[types.AssetsMaintenanceWhereUniqueInput] = None,
    ) -> Union[int, types.AssetsMaintenanceCountAggregateOutput]:
        """Count the number of AssetsMaintenance records present in the database

        Parameters
        ----------
        select
            Select the AssetsMaintenance fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsMaintenance filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsMaintenanceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsMaintenance.prisma().count()

        # results: prisma.types.AssetsMaintenanceCountAggregateOutput
        results = await AssetsMaintenance.prisma().count(
            select={
                '_all': True,
                'dateCompleted': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AssetsMaintenanceCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AssetsMaintenanceWhereInput] = None
    ) -> int:
        """Delete multiple AssetsMaintenance records.

        Parameters
        ----------
        where
            Optional AssetsMaintenance filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AssetsMaintenance records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AssetsMaintenance records
        total = await AssetsMaintenance.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AssetsMaintenanceScalarFieldKeys'],
        *,
        where: Optional['types.AssetsMaintenanceWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AssetsMaintenanceAvgAggregateInput'] = None,
        sum: Optional['types.AssetsMaintenanceSumAggregateInput'] = None,
        min: Optional['types.AssetsMaintenanceMinAggregateInput'] = None,
        max: Optional['types.AssetsMaintenanceMaxAggregateInput'] = None,
        having: Optional['types.AssetsMaintenanceScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AssetsMaintenanceCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AssetsMaintenanceScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AssetsMaintenanceScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AssetsMaintenanceGroupByOutput']:
        """Group AssetsMaintenance records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AssetsMaintenance fields to group records by
        where
            AssetsMaintenance filter to select records
        take
            Limit the maximum number of AssetsMaintenance records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AssetsMaintenanceGroupByOutput]
            A list of dictionaries representing the AssetsMaintenance record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AssetsMaintenance records by dateCancelled values
        # and count how many records are in each group
        results = await AssetsMaintenance.prisma().group_by(
            ['dateCancelled'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class MaintenanceInventoryItemActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.MaintenanceInventoryItem]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await MaintenanceInventoryItem.prisma().query_raw(
            'SELECT * FROM MaintenanceInventoryItem WHERE id = $1',
            'bchhceeeff',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.MaintenanceInventoryItem
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await MaintenanceInventoryItem.prisma().query_first(
            'SELECT * FROM MaintenanceInventoryItem WHERE maintenanceId = $1',
            'bbgaifhdaa',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.MaintenanceInventoryItemCreateInput,
        include: Optional[types.MaintenanceInventoryItemInclude] = None
    ) -> _PrismaModelT:
        """Create a new MaintenanceInventoryItem record.

        Parameters
        ----------
        data
            MaintenanceInventoryItem record data
        include
            Specifies which relations should be loaded on the returned MaintenanceInventoryItem model

        Returns
        -------
        prisma.models.MaintenanceInventoryItem
            The created MaintenanceInventoryItem record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a MaintenanceInventoryItem record from just the required fields
        maintenanceinventoryitem = await MaintenanceInventoryItem.prisma().create(
            data={
                # data to create a MaintenanceInventoryItem record
                'maintenanceId': 'dgbcdaegb',
                'inventoryItemId': 'beagfbbjig',
                'quantity': Decimal('1482877891.56662'),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.MaintenanceInventoryItemCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple MaintenanceInventoryItem records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of MaintenanceInventoryItem record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await MaintenanceInventoryItem.prisma().create_many(
            data=[
                {
                    # data to create a MaintenanceInventoryItem record
                    'maintenanceId': 'ccjbbjigf',
                    'inventoryItemId': 'bhfaabbaha',
                    'quantity': Decimal('410943775.90902'),
                },
                {
                    # data to create a MaintenanceInventoryItem record
                    'maintenanceId': 'hffgbabgf',
                    'inventoryItemId': 'biacbiieja',
                    'quantity': Decimal('294916155.56407'),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.MaintenanceInventoryItemWhereUniqueInput,
        include: Optional[types.MaintenanceInventoryItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single MaintenanceInventoryItem record.

        Parameters
        ----------
        where
            MaintenanceInventoryItem filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned MaintenanceInventoryItem model

        Returns
        -------
        prisma.models.MaintenanceInventoryItem
            The deleted MaintenanceInventoryItem record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        maintenanceinventoryitem = await MaintenanceInventoryItem.prisma().delete(
            where={
                'id': 'diageigcf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.MaintenanceInventoryItemWhereUniqueInput,
        include: Optional[types.MaintenanceInventoryItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique MaintenanceInventoryItem record.

        Parameters
        ----------
        where
            MaintenanceInventoryItem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned MaintenanceInventoryItem model

        Returns
        -------
        prisma.models.MaintenanceInventoryItem
            The found MaintenanceInventoryItem record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        maintenanceinventoryitem = await MaintenanceInventoryItem.prisma().find_unique(
            where={
                'id': 'badagbgeha',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.MaintenanceInventoryItemWhereUniqueInput,
        include: Optional[types.MaintenanceInventoryItemInclude] = None
    ) -> _PrismaModelT:
        """Find a unique MaintenanceInventoryItem record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            MaintenanceInventoryItem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned MaintenanceInventoryItem model

        Returns
        -------
        prisma.models.MaintenanceInventoryItem
            The found MaintenanceInventoryItem record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        maintenanceinventoryitem = await MaintenanceInventoryItem.prisma().find_unique_or_raise(
            where={
                'id': 'ibgebbjch',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MaintenanceInventoryItemWhereInput] = None,
        cursor: Optional[types.MaintenanceInventoryItemWhereUniqueInput] = None,
        include: Optional[types.MaintenanceInventoryItemInclude] = None,
        order: Optional[Union[types.MaintenanceInventoryItemOrderByInput, List[types.MaintenanceInventoryItemOrderByInput]]] = None,
        distinct: Optional[List[types.MaintenanceInventoryItemScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple MaintenanceInventoryItem records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of MaintenanceInventoryItem records returned
        skip
            Ignore the first N results
        where
            MaintenanceInventoryItem filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned MaintenanceInventoryItem model
        order
            Order the returned MaintenanceInventoryItem records by any field
        distinct
            Filter MaintenanceInventoryItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.MaintenanceInventoryItem]
            The list of all MaintenanceInventoryItem records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 MaintenanceInventoryItem records
        maintenanceinventoryitems = await MaintenanceInventoryItem.prisma().find_many(take=10)

        # find the first 5 MaintenanceInventoryItem records ordered by the inventoryItemId field
        maintenanceinventoryitems = await MaintenanceInventoryItem.prisma().find_many(
            take=5,
            order={
                'inventoryItemId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MaintenanceInventoryItemWhereInput] = None,
        cursor: Optional[types.MaintenanceInventoryItemWhereUniqueInput] = None,
        include: Optional[types.MaintenanceInventoryItemInclude] = None,
        order: Optional[Union[types.MaintenanceInventoryItemOrderByInput, List[types.MaintenanceInventoryItemOrderByInput]]] = None,
        distinct: Optional[List[types.MaintenanceInventoryItemScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single MaintenanceInventoryItem record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            MaintenanceInventoryItem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned MaintenanceInventoryItem model
        order
            Order the returned MaintenanceInventoryItem records by any field
        distinct
            Filter MaintenanceInventoryItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.MaintenanceInventoryItem
            The first MaintenanceInventoryItem record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second MaintenanceInventoryItem record ordered by the quantity field
        maintenanceinventoryitem = await MaintenanceInventoryItem.prisma().find_first(
            skip=1,
            order={
                'quantity': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MaintenanceInventoryItemWhereInput] = None,
        cursor: Optional[types.MaintenanceInventoryItemWhereUniqueInput] = None,
        include: Optional[types.MaintenanceInventoryItemInclude] = None,
        order: Optional[Union[types.MaintenanceInventoryItemOrderByInput, List[types.MaintenanceInventoryItemOrderByInput]]] = None,
        distinct: Optional[List[types.MaintenanceInventoryItemScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single MaintenanceInventoryItem record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            MaintenanceInventoryItem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned MaintenanceInventoryItem model
        order
            Order the returned MaintenanceInventoryItem records by any field
        distinct
            Filter MaintenanceInventoryItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.MaintenanceInventoryItem
            The first MaintenanceInventoryItem record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second MaintenanceInventoryItem record ordered by the unitCost field
        maintenanceinventoryitem = await MaintenanceInventoryItem.prisma().find_first_or_raise(
            skip=1,
            order={
                'unitCost': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.MaintenanceInventoryItemUpdateInput,
        where: types.MaintenanceInventoryItemWhereUniqueInput,
        include: Optional[types.MaintenanceInventoryItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single MaintenanceInventoryItem record.

        Parameters
        ----------
        data
            MaintenanceInventoryItem record data specifying what to update
        where
            MaintenanceInventoryItem filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned MaintenanceInventoryItem model

        Returns
        -------
        prisma.models.MaintenanceInventoryItem
            The updated MaintenanceInventoryItem record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        maintenanceinventoryitem = await MaintenanceInventoryItem.prisma().update(
            where={
                'id': 'baieajjiee',
            },
            data={
                # data to update the MaintenanceInventoryItem record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.MaintenanceInventoryItemWhereUniqueInput,
        data: types.MaintenanceInventoryItemUpsertInput,
        include: Optional[types.MaintenanceInventoryItemInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            MaintenanceInventoryItem filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned MaintenanceInventoryItem model

        Returns
        -------
        prisma.models.MaintenanceInventoryItem
            The created or updated MaintenanceInventoryItem record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        maintenanceinventoryitem = await MaintenanceInventoryItem.prisma().upsert(
            where={
                'id': 'bahjhaccfd',
            },
            data={
                'create': {
                    'id': 'bahjhaccfd',
                    'maintenanceId': 'hffgbabgf',
                    'inventoryItemId': 'biacbiieja',
                    'quantity': Decimal('294916155.56407'),
                },
                'update': {
                    'maintenanceId': 'hffgbabgf',
                    'inventoryItemId': 'biacbiieja',
                    'quantity': Decimal('294916155.56407'),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.MaintenanceInventoryItemUpdateManyMutationInput,
        where: types.MaintenanceInventoryItemWhereInput,
    ) -> int:
        """Update multiple MaintenanceInventoryItem records

        Parameters
        ----------
        data
            MaintenanceInventoryItem data to update the selected MaintenanceInventoryItem records to
        where
            Filter to select the MaintenanceInventoryItem records to update

        Returns
        -------
        int
            The total number of MaintenanceInventoryItem records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all MaintenanceInventoryItem records
        total = await MaintenanceInventoryItem.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MaintenanceInventoryItemWhereInput] = None,
        cursor: Optional[types.MaintenanceInventoryItemWhereUniqueInput] = None,
    ) -> int:
        """Count the number of MaintenanceInventoryItem records present in the database

        Parameters
        ----------
        select
            Select the MaintenanceInventoryItem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            MaintenanceInventoryItem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MaintenanceInventoryItemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await MaintenanceInventoryItem.prisma().count()

        # results: prisma.types.MaintenanceInventoryItemCountAggregateOutput
        results = await MaintenanceInventoryItem.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.MaintenanceInventoryItemCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MaintenanceInventoryItemWhereInput] = None,
        cursor: Optional[types.MaintenanceInventoryItemWhereUniqueInput] = None,
    ) -> types.MaintenanceInventoryItemCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.MaintenanceInventoryItemCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MaintenanceInventoryItemWhereInput] = None,
        cursor: Optional[types.MaintenanceInventoryItemWhereUniqueInput] = None,
    ) -> Union[int, types.MaintenanceInventoryItemCountAggregateOutput]:
        """Count the number of MaintenanceInventoryItem records present in the database

        Parameters
        ----------
        select
            Select the MaintenanceInventoryItem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            MaintenanceInventoryItem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MaintenanceInventoryItemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await MaintenanceInventoryItem.prisma().count()

        # results: prisma.types.MaintenanceInventoryItemCountAggregateOutput
        results = await MaintenanceInventoryItem.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.MaintenanceInventoryItemCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.MaintenanceInventoryItemWhereInput] = None
    ) -> int:
        """Delete multiple MaintenanceInventoryItem records.

        Parameters
        ----------
        where
            Optional MaintenanceInventoryItem filter to find the records to be deleted

        Returns
        -------
        int
            The total number of MaintenanceInventoryItem records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all MaintenanceInventoryItem records
        total = await MaintenanceInventoryItem.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.MaintenanceInventoryItemScalarFieldKeys'],
        *,
        where: Optional['types.MaintenanceInventoryItemWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.MaintenanceInventoryItemAvgAggregateInput'] = None,
        sum: Optional['types.MaintenanceInventoryItemSumAggregateInput'] = None,
        min: Optional['types.MaintenanceInventoryItemMinAggregateInput'] = None,
        max: Optional['types.MaintenanceInventoryItemMaxAggregateInput'] = None,
        having: Optional['types.MaintenanceInventoryItemScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.MaintenanceInventoryItemCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.MaintenanceInventoryItemScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.MaintenanceInventoryItemScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.MaintenanceInventoryItemGroupByOutput']:
        """Group MaintenanceInventoryItem records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar MaintenanceInventoryItem fields to group records by
        where
            MaintenanceInventoryItem filter to select records
        take
            Limit the maximum number of MaintenanceInventoryItem records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.MaintenanceInventoryItemGroupByOutput]
            A list of dictionaries representing the MaintenanceInventoryItem record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group MaintenanceInventoryItem records by maintenanceId values
        # and count how many records are in each group
        results = await MaintenanceInventoryItem.prisma().group_by(
            ['maintenanceId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AssetsAuditHistoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AssetsAuditHistory]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AssetsAuditHistory.prisma().query_raw(
            'SELECT * FROM AssetsAuditHistory WHERE id = $1',
            'hffhfabhi',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AssetsAuditHistory
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AssetsAuditHistory.prisma().query_first(
            'SELECT * FROM AssetsAuditHistory WHERE assetId = $1',
            'bbcigiadhb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AssetsAuditHistoryCreateInput,
        include: Optional[types.AssetsAuditHistoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new AssetsAuditHistory record.

        Parameters
        ----------
        data
            AssetsAuditHistory record data
        include
            Specifies which relations should be loaded on the returned AssetsAuditHistory model

        Returns
        -------
        prisma.models.AssetsAuditHistory
            The created AssetsAuditHistory record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AssetsAuditHistory record from just the required fields
        assetsaudithistory = await AssetsAuditHistory.prisma().create(
            data={
                # data to create a AssetsAuditHistory record
                'assetId': 'cfjagbbae',
                'auditType': 'bbbfhdidef',
                'auditDate': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AssetsAuditHistoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AssetsAuditHistory records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AssetsAuditHistory record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AssetsAuditHistory.prisma().create_many(
            data=[
                {
                    # data to create a AssetsAuditHistory record
                    'assetId': 'bdadhibhec',
                    'auditType': 'bfhdjaiejf',
                    'auditDate': datetime.datetime.utcnow(),
                },
                {
                    # data to create a AssetsAuditHistory record
                    'assetId': 'bbjfijjadg',
                    'auditType': 'hdjacbehh',
                    'auditDate': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AssetsAuditHistoryWhereUniqueInput,
        include: Optional[types.AssetsAuditHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AssetsAuditHistory record.

        Parameters
        ----------
        where
            AssetsAuditHistory filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsAuditHistory model

        Returns
        -------
        prisma.models.AssetsAuditHistory
            The deleted AssetsAuditHistory record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsaudithistory = await AssetsAuditHistory.prisma().delete(
            where={
                'id': 'bhcccbeaba',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AssetsAuditHistoryWhereUniqueInput,
        include: Optional[types.AssetsAuditHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AssetsAuditHistory record.

        Parameters
        ----------
        where
            AssetsAuditHistory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsAuditHistory model

        Returns
        -------
        prisma.models.AssetsAuditHistory
            The found AssetsAuditHistory record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsaudithistory = await AssetsAuditHistory.prisma().find_unique(
            where={
                'id': 'bcgjbdgjdj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AssetsAuditHistoryWhereUniqueInput,
        include: Optional[types.AssetsAuditHistoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AssetsAuditHistory record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AssetsAuditHistory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsAuditHistory model

        Returns
        -------
        prisma.models.AssetsAuditHistory
            The found AssetsAuditHistory record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsaudithistory = await AssetsAuditHistory.prisma().find_unique_or_raise(
            where={
                'id': 'fhdbhifae',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsAuditHistoryWhereInput] = None,
        cursor: Optional[types.AssetsAuditHistoryWhereUniqueInput] = None,
        include: Optional[types.AssetsAuditHistoryInclude] = None,
        order: Optional[Union[types.AssetsAuditHistoryOrderByInput, List[types.AssetsAuditHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsAuditHistoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AssetsAuditHistory records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AssetsAuditHistory records returned
        skip
            Ignore the first N results
        where
            AssetsAuditHistory filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsAuditHistory model
        order
            Order the returned AssetsAuditHistory records by any field
        distinct
            Filter AssetsAuditHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AssetsAuditHistory]
            The list of all AssetsAuditHistory records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AssetsAuditHistory records
        assetsaudithistorys = await AssetsAuditHistory.prisma().find_many(take=10)

        # find the first 5 AssetsAuditHistory records ordered by the auditType field
        assetsaudithistorys = await AssetsAuditHistory.prisma().find_many(
            take=5,
            order={
                'auditType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsAuditHistoryWhereInput] = None,
        cursor: Optional[types.AssetsAuditHistoryWhereUniqueInput] = None,
        include: Optional[types.AssetsAuditHistoryInclude] = None,
        order: Optional[Union[types.AssetsAuditHistoryOrderByInput, List[types.AssetsAuditHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsAuditHistoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AssetsAuditHistory record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsAuditHistory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsAuditHistory model
        order
            Order the returned AssetsAuditHistory records by any field
        distinct
            Filter AssetsAuditHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsAuditHistory
            The first AssetsAuditHistory record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsAuditHistory record ordered by the auditDate field
        assetsaudithistory = await AssetsAuditHistory.prisma().find_first(
            skip=1,
            order={
                'auditDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsAuditHistoryWhereInput] = None,
        cursor: Optional[types.AssetsAuditHistoryWhereUniqueInput] = None,
        include: Optional[types.AssetsAuditHistoryInclude] = None,
        order: Optional[Union[types.AssetsAuditHistoryOrderByInput, List[types.AssetsAuditHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsAuditHistoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AssetsAuditHistory record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsAuditHistory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsAuditHistory model
        order
            Order the returned AssetsAuditHistory records by any field
        distinct
            Filter AssetsAuditHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsAuditHistory
            The first AssetsAuditHistory record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsAuditHistory record ordered by the notes field
        assetsaudithistory = await AssetsAuditHistory.prisma().find_first_or_raise(
            skip=1,
            order={
                'notes': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AssetsAuditHistoryUpdateInput,
        where: types.AssetsAuditHistoryWhereUniqueInput,
        include: Optional[types.AssetsAuditHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AssetsAuditHistory record.

        Parameters
        ----------
        data
            AssetsAuditHistory record data specifying what to update
        where
            AssetsAuditHistory filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AssetsAuditHistory model

        Returns
        -------
        prisma.models.AssetsAuditHistory
            The updated AssetsAuditHistory record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        assetsaudithistory = await AssetsAuditHistory.prisma().update(
            where={
                'id': 'beeacgfcej',
            },
            data={
                # data to update the AssetsAuditHistory record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AssetsAuditHistoryWhereUniqueInput,
        data: types.AssetsAuditHistoryUpsertInput,
        include: Optional[types.AssetsAuditHistoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AssetsAuditHistory filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AssetsAuditHistory model

        Returns
        -------
        prisma.models.AssetsAuditHistory
            The created or updated AssetsAuditHistory record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsaudithistory = await AssetsAuditHistory.prisma().upsert(
            where={
                'id': 'bbifhdiicc',
            },
            data={
                'create': {
                    'id': 'bbifhdiicc',
                    'assetId': 'bbjfijjadg',
                    'auditType': 'hdjacbehh',
                    'auditDate': datetime.datetime.utcnow(),
                },
                'update': {
                    'assetId': 'bbjfijjadg',
                    'auditType': 'hdjacbehh',
                    'auditDate': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AssetsAuditHistoryUpdateManyMutationInput,
        where: types.AssetsAuditHistoryWhereInput,
    ) -> int:
        """Update multiple AssetsAuditHistory records

        Parameters
        ----------
        data
            AssetsAuditHistory data to update the selected AssetsAuditHistory records to
        where
            Filter to select the AssetsAuditHistory records to update

        Returns
        -------
        int
            The total number of AssetsAuditHistory records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AssetsAuditHistory records
        total = await AssetsAuditHistory.prisma().update_many(
            data={
                'auditor': 'bgjeccejad'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsAuditHistoryWhereInput] = None,
        cursor: Optional[types.AssetsAuditHistoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AssetsAuditHistory records present in the database

        Parameters
        ----------
        select
            Select the AssetsAuditHistory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsAuditHistory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsAuditHistoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsAuditHistory.prisma().count()

        # results: prisma.types.AssetsAuditHistoryCountAggregateOutput
        results = await AssetsAuditHistory.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AssetsAuditHistoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsAuditHistoryWhereInput] = None,
        cursor: Optional[types.AssetsAuditHistoryWhereUniqueInput] = None,
    ) -> types.AssetsAuditHistoryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AssetsAuditHistoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsAuditHistoryWhereInput] = None,
        cursor: Optional[types.AssetsAuditHistoryWhereUniqueInput] = None,
    ) -> Union[int, types.AssetsAuditHistoryCountAggregateOutput]:
        """Count the number of AssetsAuditHistory records present in the database

        Parameters
        ----------
        select
            Select the AssetsAuditHistory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsAuditHistory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsAuditHistoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsAuditHistory.prisma().count()

        # results: prisma.types.AssetsAuditHistoryCountAggregateOutput
        results = await AssetsAuditHistory.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AssetsAuditHistoryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AssetsAuditHistoryWhereInput] = None
    ) -> int:
        """Delete multiple AssetsAuditHistory records.

        Parameters
        ----------
        where
            Optional AssetsAuditHistory filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AssetsAuditHistory records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AssetsAuditHistory records
        total = await AssetsAuditHistory.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AssetsAuditHistoryScalarFieldKeys'],
        *,
        where: Optional['types.AssetsAuditHistoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AssetsAuditHistoryAvgAggregateInput'] = None,
        sum: Optional['types.AssetsAuditHistorySumAggregateInput'] = None,
        min: Optional['types.AssetsAuditHistoryMinAggregateInput'] = None,
        max: Optional['types.AssetsAuditHistoryMaxAggregateInput'] = None,
        having: Optional['types.AssetsAuditHistoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AssetsAuditHistoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AssetsAuditHistoryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AssetsAuditHistoryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AssetsAuditHistoryGroupByOutput']:
        """Group AssetsAuditHistory records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AssetsAuditHistory fields to group records by
        where
            AssetsAuditHistory filter to select records
        take
            Limit the maximum number of AssetsAuditHistory records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AssetsAuditHistoryGroupByOutput]
            A list of dictionaries representing the AssetsAuditHistory record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AssetsAuditHistory records by updatedAt values
        # and count how many records are in each group
        results = await AssetsAuditHistory.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AssetsHistoryLogsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AssetsHistoryLogs]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AssetsHistoryLogs.prisma().query_raw(
            'SELECT * FROM AssetsHistoryLogs WHERE id = $1',
            'bjagdgabbg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AssetsHistoryLogs
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AssetsHistoryLogs.prisma().query_first(
            'SELECT * FROM AssetsHistoryLogs WHERE assetId = $1',
            'bjbbcffdij',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AssetsHistoryLogsCreateInput,
        include: Optional[types.AssetsHistoryLogsInclude] = None
    ) -> _PrismaModelT:
        """Create a new AssetsHistoryLogs record.

        Parameters
        ----------
        data
            AssetsHistoryLogs record data
        include
            Specifies which relations should be loaded on the returned AssetsHistoryLogs model

        Returns
        -------
        prisma.models.AssetsHistoryLogs
            The created AssetsHistoryLogs record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AssetsHistoryLogs record from just the required fields
        assetshistorylogs = await AssetsHistoryLogs.prisma().create(
            data={
                # data to create a AssetsHistoryLogs record
                'assetId': 'begcgchdi',
                'eventType': 'bhbjceagbb',
                'actionBy': 'bjeifffjdg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AssetsHistoryLogsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AssetsHistoryLogs records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AssetsHistoryLogs record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AssetsHistoryLogs.prisma().create_many(
            data=[
                {
                    # data to create a AssetsHistoryLogs record
                    'assetId': 'bdidcfdfjd',
                    'eventType': 'dfeggejja',
                    'actionBy': 'gehbgghbj',
                },
                {
                    # data to create a AssetsHistoryLogs record
                    'assetId': 'dfhaijeie',
                    'eventType': 'gbcdjgicb',
                    'actionBy': 'biaibdagac',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AssetsHistoryLogsWhereUniqueInput,
        include: Optional[types.AssetsHistoryLogsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AssetsHistoryLogs record.

        Parameters
        ----------
        where
            AssetsHistoryLogs filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsHistoryLogs model

        Returns
        -------
        prisma.models.AssetsHistoryLogs
            The deleted AssetsHistoryLogs record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetshistorylogs = await AssetsHistoryLogs.prisma().delete(
            where={
                'id': 'bbfbheibcd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AssetsHistoryLogsWhereUniqueInput,
        include: Optional[types.AssetsHistoryLogsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AssetsHistoryLogs record.

        Parameters
        ----------
        where
            AssetsHistoryLogs filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsHistoryLogs model

        Returns
        -------
        prisma.models.AssetsHistoryLogs
            The found AssetsHistoryLogs record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetshistorylogs = await AssetsHistoryLogs.prisma().find_unique(
            where={
                'id': 'hiagajie',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AssetsHistoryLogsWhereUniqueInput,
        include: Optional[types.AssetsHistoryLogsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AssetsHistoryLogs record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AssetsHistoryLogs filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsHistoryLogs model

        Returns
        -------
        prisma.models.AssetsHistoryLogs
            The found AssetsHistoryLogs record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetshistorylogs = await AssetsHistoryLogs.prisma().find_unique_or_raise(
            where={
                'id': 'eeejidbif',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsHistoryLogsWhereInput] = None,
        cursor: Optional[types.AssetsHistoryLogsWhereUniqueInput] = None,
        include: Optional[types.AssetsHistoryLogsInclude] = None,
        order: Optional[Union[types.AssetsHistoryLogsOrderByInput, List[types.AssetsHistoryLogsOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsHistoryLogsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AssetsHistoryLogs records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AssetsHistoryLogs records returned
        skip
            Ignore the first N results
        where
            AssetsHistoryLogs filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsHistoryLogs model
        order
            Order the returned AssetsHistoryLogs records by any field
        distinct
            Filter AssetsHistoryLogs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AssetsHistoryLogs]
            The list of all AssetsHistoryLogs records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AssetsHistoryLogs records
        assetshistorylogs = await AssetsHistoryLogs.prisma().find_many(take=10)

        # find the first 5 AssetsHistoryLogs records ordered by the eventDate field
        assetshistorylogs = await AssetsHistoryLogs.prisma().find_many(
            take=5,
            order={
                'eventDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsHistoryLogsWhereInput] = None,
        cursor: Optional[types.AssetsHistoryLogsWhereUniqueInput] = None,
        include: Optional[types.AssetsHistoryLogsInclude] = None,
        order: Optional[Union[types.AssetsHistoryLogsOrderByInput, List[types.AssetsHistoryLogsOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsHistoryLogsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AssetsHistoryLogs record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsHistoryLogs filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsHistoryLogs model
        order
            Order the returned AssetsHistoryLogs records by any field
        distinct
            Filter AssetsHistoryLogs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsHistoryLogs
            The first AssetsHistoryLogs record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsHistoryLogs record ordered by the eventType field
        assetshistorylogs = await AssetsHistoryLogs.prisma().find_first(
            skip=1,
            order={
                'eventType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsHistoryLogsWhereInput] = None,
        cursor: Optional[types.AssetsHistoryLogsWhereUniqueInput] = None,
        include: Optional[types.AssetsHistoryLogsInclude] = None,
        order: Optional[Union[types.AssetsHistoryLogsOrderByInput, List[types.AssetsHistoryLogsOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsHistoryLogsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AssetsHistoryLogs record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsHistoryLogs filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsHistoryLogs model
        order
            Order the returned AssetsHistoryLogs records by any field
        distinct
            Filter AssetsHistoryLogs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsHistoryLogs
            The first AssetsHistoryLogs record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsHistoryLogs record ordered by the field field
        assetshistorylogs = await AssetsHistoryLogs.prisma().find_first_or_raise(
            skip=1,
            order={
                'field': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AssetsHistoryLogsUpdateInput,
        where: types.AssetsHistoryLogsWhereUniqueInput,
        include: Optional[types.AssetsHistoryLogsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AssetsHistoryLogs record.

        Parameters
        ----------
        data
            AssetsHistoryLogs record data specifying what to update
        where
            AssetsHistoryLogs filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AssetsHistoryLogs model

        Returns
        -------
        prisma.models.AssetsHistoryLogs
            The updated AssetsHistoryLogs record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        assetshistorylogs = await AssetsHistoryLogs.prisma().update(
            where={
                'id': 'efgbahec',
            },
            data={
                # data to update the AssetsHistoryLogs record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AssetsHistoryLogsWhereUniqueInput,
        data: types.AssetsHistoryLogsUpsertInput,
        include: Optional[types.AssetsHistoryLogsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AssetsHistoryLogs filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AssetsHistoryLogs model

        Returns
        -------
        prisma.models.AssetsHistoryLogs
            The created or updated AssetsHistoryLogs record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetshistorylogs = await AssetsHistoryLogs.prisma().upsert(
            where={
                'id': 'hgjaiebfb',
            },
            data={
                'create': {
                    'id': 'hgjaiebfb',
                    'assetId': 'dfhaijeie',
                    'eventType': 'gbcdjgicb',
                    'actionBy': 'biaibdagac',
                },
                'update': {
                    'assetId': 'dfhaijeie',
                    'eventType': 'gbcdjgicb',
                    'actionBy': 'biaibdagac',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AssetsHistoryLogsUpdateManyMutationInput,
        where: types.AssetsHistoryLogsWhereInput,
    ) -> int:
        """Update multiple AssetsHistoryLogs records

        Parameters
        ----------
        data
            AssetsHistoryLogs data to update the selected AssetsHistoryLogs records to
        where
            Filter to select the AssetsHistoryLogs records to update

        Returns
        -------
        int
            The total number of AssetsHistoryLogs records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AssetsHistoryLogs records
        total = await AssetsHistoryLogs.prisma().update_many(
            data={
                'changeFrom': 'bddefjjabc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsHistoryLogsWhereInput] = None,
        cursor: Optional[types.AssetsHistoryLogsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AssetsHistoryLogs records present in the database

        Parameters
        ----------
        select
            Select the AssetsHistoryLogs fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsHistoryLogs filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsHistoryLogsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsHistoryLogs.prisma().count()

        # results: prisma.types.AssetsHistoryLogsCountAggregateOutput
        results = await AssetsHistoryLogs.prisma().count(
            select={
                '_all': True,
                'changeTo': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AssetsHistoryLogsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsHistoryLogsWhereInput] = None,
        cursor: Optional[types.AssetsHistoryLogsWhereUniqueInput] = None,
    ) -> types.AssetsHistoryLogsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AssetsHistoryLogsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsHistoryLogsWhereInput] = None,
        cursor: Optional[types.AssetsHistoryLogsWhereUniqueInput] = None,
    ) -> Union[int, types.AssetsHistoryLogsCountAggregateOutput]:
        """Count the number of AssetsHistoryLogs records present in the database

        Parameters
        ----------
        select
            Select the AssetsHistoryLogs fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsHistoryLogs filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsHistoryLogsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsHistoryLogs.prisma().count()

        # results: prisma.types.AssetsHistoryLogsCountAggregateOutput
        results = await AssetsHistoryLogs.prisma().count(
            select={
                '_all': True,
                'actionBy': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AssetsHistoryLogsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AssetsHistoryLogsWhereInput] = None
    ) -> int:
        """Delete multiple AssetsHistoryLogs records.

        Parameters
        ----------
        where
            Optional AssetsHistoryLogs filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AssetsHistoryLogs records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AssetsHistoryLogs records
        total = await AssetsHistoryLogs.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AssetsHistoryLogsScalarFieldKeys'],
        *,
        where: Optional['types.AssetsHistoryLogsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AssetsHistoryLogsAvgAggregateInput'] = None,
        sum: Optional['types.AssetsHistoryLogsSumAggregateInput'] = None,
        min: Optional['types.AssetsHistoryLogsMinAggregateInput'] = None,
        max: Optional['types.AssetsHistoryLogsMaxAggregateInput'] = None,
        having: Optional['types.AssetsHistoryLogsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AssetsHistoryLogsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AssetsHistoryLogsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AssetsHistoryLogsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AssetsHistoryLogsGroupByOutput']:
        """Group AssetsHistoryLogs records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AssetsHistoryLogs fields to group records by
        where
            AssetsHistoryLogs filter to select records
        take
            Limit the maximum number of AssetsHistoryLogs records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AssetsHistoryLogsGroupByOutput]
            A list of dictionaries representing the AssetsHistoryLogs record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AssetsHistoryLogs records by createdAt values
        # and count how many records are in each group
        results = await AssetsHistoryLogs.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AssetUserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AssetUser]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AssetUser.prisma().query_raw(
            'SELECT * FROM AssetUser WHERE id = $1',
            'bbbghgbadh',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AssetUser
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AssetUser.prisma().query_first(
            'SELECT * FROM AssetUser WHERE userId = $1',
            'bbhcgagaic',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AssetUserCreateInput,
        include: Optional[types.AssetUserInclude] = None
    ) -> _PrismaModelT:
        """Create a new AssetUser record.

        Parameters
        ----------
        data
            AssetUser record data
        include
            Specifies which relations should be loaded on the returned AssetUser model

        Returns
        -------
        prisma.models.AssetUser
            The created AssetUser record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AssetUser record from just the required fields
        assetuser = await AssetUser.prisma().create(
            data={
                # data to create a AssetUser record
                'userId': 'ddaabegbb',
                'role': 'bhgibfgbbc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AssetUserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AssetUser records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AssetUser record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AssetUser.prisma().create_many(
            data=[
                {
                    # data to create a AssetUser record
                    'userId': 'hbgcihef',
                    'role': 'ffhgghde',
                },
                {
                    # data to create a AssetUser record
                    'userId': 'ibcadcejf',
                    'role': 'bdcdfgccdg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AssetUserWhereUniqueInput,
        include: Optional[types.AssetUserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AssetUser record.

        Parameters
        ----------
        where
            AssetUser filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AssetUser model

        Returns
        -------
        prisma.models.AssetUser
            The deleted AssetUser record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetuser = await AssetUser.prisma().delete(
            where={
                'id': 'edhjgdfh',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AssetUserWhereUniqueInput,
        include: Optional[types.AssetUserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AssetUser record.

        Parameters
        ----------
        where
            AssetUser filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetUser model

        Returns
        -------
        prisma.models.AssetUser
            The found AssetUser record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetuser = await AssetUser.prisma().find_unique(
            where={
                'id': 'bdeffdadda',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AssetUserWhereUniqueInput,
        include: Optional[types.AssetUserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AssetUser record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AssetUser filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetUser model

        Returns
        -------
        prisma.models.AssetUser
            The found AssetUser record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetuser = await AssetUser.prisma().find_unique_or_raise(
            where={
                'id': 'bjgfdihchf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetUserWhereInput] = None,
        cursor: Optional[types.AssetUserWhereUniqueInput] = None,
        include: Optional[types.AssetUserInclude] = None,
        order: Optional[Union[types.AssetUserOrderByInput, List[types.AssetUserOrderByInput]]] = None,
        distinct: Optional[List[types.AssetUserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AssetUser records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AssetUser records returned
        skip
            Ignore the first N results
        where
            AssetUser filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetUser model
        order
            Order the returned AssetUser records by any field
        distinct
            Filter AssetUser records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AssetUser]
            The list of all AssetUser records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AssetUser records
        assetusers = await AssetUser.prisma().find_many(take=10)

        # find the first 5 AssetUser records ordered by the role field
        assetusers = await AssetUser.prisma().find_many(
            take=5,
            order={
                'role': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetUserWhereInput] = None,
        cursor: Optional[types.AssetUserWhereUniqueInput] = None,
        include: Optional[types.AssetUserInclude] = None,
        order: Optional[Union[types.AssetUserOrderByInput, List[types.AssetUserOrderByInput]]] = None,
        distinct: Optional[List[types.AssetUserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AssetUser record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetUser filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetUser model
        order
            Order the returned AssetUser records by any field
        distinct
            Filter AssetUser records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetUser
            The first AssetUser record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetUser record ordered by the canDeleteAssets field
        assetuser = await AssetUser.prisma().find_first(
            skip=1,
            order={
                'canDeleteAssets': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetUserWhereInput] = None,
        cursor: Optional[types.AssetUserWhereUniqueInput] = None,
        include: Optional[types.AssetUserInclude] = None,
        order: Optional[Union[types.AssetUserOrderByInput, List[types.AssetUserOrderByInput]]] = None,
        distinct: Optional[List[types.AssetUserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AssetUser record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetUser filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetUser model
        order
            Order the returned AssetUser records by any field
        distinct
            Filter AssetUser records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetUser
            The first AssetUser record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetUser record ordered by the canManageImport field
        assetuser = await AssetUser.prisma().find_first_or_raise(
            skip=1,
            order={
                'canManageImport': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AssetUserUpdateInput,
        where: types.AssetUserWhereUniqueInput,
        include: Optional[types.AssetUserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AssetUser record.

        Parameters
        ----------
        data
            AssetUser record data specifying what to update
        where
            AssetUser filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AssetUser model

        Returns
        -------
        prisma.models.AssetUser
            The updated AssetUser record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        assetuser = await AssetUser.prisma().update(
            where={
                'id': 'iaeihdeei',
            },
            data={
                # data to update the AssetUser record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AssetUserWhereUniqueInput,
        data: types.AssetUserUpsertInput,
        include: Optional[types.AssetUserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AssetUser filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AssetUser model

        Returns
        -------
        prisma.models.AssetUser
            The created or updated AssetUser record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetuser = await AssetUser.prisma().upsert(
            where={
                'id': 'bfggejgfbd',
            },
            data={
                'create': {
                    'id': 'bfggejgfbd',
                    'userId': 'ibcadcejf',
                    'role': 'bdcdfgccdg',
                },
                'update': {
                    'userId': 'ibcadcejf',
                    'role': 'bdcdfgccdg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AssetUserUpdateManyMutationInput,
        where: types.AssetUserWhereInput,
    ) -> int:
        """Update multiple AssetUser records

        Parameters
        ----------
        data
            AssetUser data to update the selected AssetUser records to
        where
            Filter to select the AssetUser records to update

        Returns
        -------
        int
            The total number of AssetUser records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AssetUser records
        total = await AssetUser.prisma().update_many(
            data={
                'canManageExport': True
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetUserWhereInput] = None,
        cursor: Optional[types.AssetUserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AssetUser records present in the database

        Parameters
        ----------
        select
            Select the AssetUser fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetUser filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetUserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetUser.prisma().count()

        # results: prisma.types.AssetUserCountAggregateOutput
        results = await AssetUser.prisma().count(
            select={
                '_all': True,
                'canCreateAssets': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AssetUserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetUserWhereInput] = None,
        cursor: Optional[types.AssetUserWhereUniqueInput] = None,
    ) -> types.AssetUserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AssetUserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetUserWhereInput] = None,
        cursor: Optional[types.AssetUserWhereUniqueInput] = None,
    ) -> Union[int, types.AssetUserCountAggregateOutput]:
        """Count the number of AssetUser records present in the database

        Parameters
        ----------
        select
            Select the AssetUser fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetUser filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetUserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetUser.prisma().count()

        # results: prisma.types.AssetUserCountAggregateOutput
        results = await AssetUser.prisma().count(
            select={
                '_all': True,
                'canEditAssets': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AssetUserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AssetUserWhereInput] = None
    ) -> int:
        """Delete multiple AssetUser records.

        Parameters
        ----------
        where
            Optional AssetUser filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AssetUser records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AssetUser records
        total = await AssetUser.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AssetUserScalarFieldKeys'],
        *,
        where: Optional['types.AssetUserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AssetUserAvgAggregateInput'] = None,
        sum: Optional['types.AssetUserSumAggregateInput'] = None,
        min: Optional['types.AssetUserMinAggregateInput'] = None,
        max: Optional['types.AssetUserMaxAggregateInput'] = None,
        having: Optional['types.AssetUserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AssetUserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AssetUserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AssetUserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AssetUserGroupByOutput']:
        """Group AssetUser records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AssetUser fields to group records by
        where
            AssetUser filter to select records
        take
            Limit the maximum number of AssetUser records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AssetUserGroupByOutput]
            A list of dictionaries representing the AssetUser record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AssetUser records by canViewAssets values
        # and count how many records are in each group
        results = await AssetUser.prisma().group_by(
            ['canViewAssets'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class FileHistoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.FileHistory]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await FileHistory.prisma().query_raw(
            'SELECT * FROM FileHistory WHERE id = $1',
            'cbajdjjabf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.FileHistory
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await FileHistory.prisma().query_first(
            'SELECT * FROM FileHistory WHERE operationType = $1',
            'bcicggedea',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.FileHistoryCreateInput,
        include: Optional[types.FileHistoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new FileHistory record.

        Parameters
        ----------
        data
            FileHistory record data
        include
            Specifies which relations should be loaded on the returned FileHistory model

        Returns
        -------
        prisma.models.FileHistory
            The created FileHistory record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a FileHistory record from just the required fields
        filehistory = await FileHistory.prisma().create(
            data={
                # data to create a FileHistory record
                'operationType': 'cebcdadjh',
                'fileName': 'ehfigdgac',
                'userId': 'bhbgccijjf',
                'status': 'bigjhdgbjc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.FileHistoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple FileHistory records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of FileHistory record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await FileHistory.prisma().create_many(
            data=[
                {
                    # data to create a FileHistory record
                    'operationType': 'bfifdebhfd',
                    'fileName': 'cjchbjde',
                    'userId': 'bfiibjcehj',
                    'status': 'ijieafghg',
                },
                {
                    # data to create a FileHistory record
                    'operationType': 'hhhegahcf',
                    'fileName': 'edhijefdi',
                    'userId': 'djddecjhb',
                    'status': 'bgdicjhie',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.FileHistoryWhereUniqueInput,
        include: Optional[types.FileHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single FileHistory record.

        Parameters
        ----------
        where
            FileHistory filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned FileHistory model

        Returns
        -------
        prisma.models.FileHistory
            The deleted FileHistory record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        filehistory = await FileHistory.prisma().delete(
            where={
                'id': 'ceibfcgij',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.FileHistoryWhereUniqueInput,
        include: Optional[types.FileHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique FileHistory record.

        Parameters
        ----------
        where
            FileHistory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned FileHistory model

        Returns
        -------
        prisma.models.FileHistory
            The found FileHistory record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        filehistory = await FileHistory.prisma().find_unique(
            where={
                'id': 'debhbfada',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.FileHistoryWhereUniqueInput,
        include: Optional[types.FileHistoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique FileHistory record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            FileHistory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned FileHistory model

        Returns
        -------
        prisma.models.FileHistory
            The found FileHistory record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        filehistory = await FileHistory.prisma().find_unique_or_raise(
            where={
                'id': 'bgjchggecd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FileHistoryWhereInput] = None,
        cursor: Optional[types.FileHistoryWhereUniqueInput] = None,
        include: Optional[types.FileHistoryInclude] = None,
        order: Optional[Union[types.FileHistoryOrderByInput, List[types.FileHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.FileHistoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple FileHistory records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of FileHistory records returned
        skip
            Ignore the first N results
        where
            FileHistory filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned FileHistory model
        order
            Order the returned FileHistory records by any field
        distinct
            Filter FileHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.FileHistory]
            The list of all FileHistory records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 FileHistory records
        filehistorys = await FileHistory.prisma().find_many(take=10)

        # find the first 5 FileHistory records ordered by the fileName field
        filehistorys = await FileHistory.prisma().find_many(
            take=5,
            order={
                'fileName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.FileHistoryWhereInput] = None,
        cursor: Optional[types.FileHistoryWhereUniqueInput] = None,
        include: Optional[types.FileHistoryInclude] = None,
        order: Optional[Union[types.FileHistoryOrderByInput, List[types.FileHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.FileHistoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single FileHistory record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            FileHistory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned FileHistory model
        order
            Order the returned FileHistory records by any field
        distinct
            Filter FileHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.FileHistory
            The first FileHistory record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second FileHistory record ordered by the filePath field
        filehistory = await FileHistory.prisma().find_first(
            skip=1,
            order={
                'filePath': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.FileHistoryWhereInput] = None,
        cursor: Optional[types.FileHistoryWhereUniqueInput] = None,
        include: Optional[types.FileHistoryInclude] = None,
        order: Optional[Union[types.FileHistoryOrderByInput, List[types.FileHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.FileHistoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single FileHistory record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            FileHistory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned FileHistory model
        order
            Order the returned FileHistory records by any field
        distinct
            Filter FileHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.FileHistory
            The first FileHistory record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second FileHistory record ordered by the fileSize field
        filehistory = await FileHistory.prisma().find_first_or_raise(
            skip=1,
            order={
                'fileSize': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.FileHistoryUpdateInput,
        where: types.FileHistoryWhereUniqueInput,
        include: Optional[types.FileHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single FileHistory record.

        Parameters
        ----------
        data
            FileHistory record data specifying what to update
        where
            FileHistory filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned FileHistory model

        Returns
        -------
        prisma.models.FileHistory
            The updated FileHistory record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        filehistory = await FileHistory.prisma().update(
            where={
                'id': 'igggcfjg',
            },
            data={
                # data to update the FileHistory record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.FileHistoryWhereUniqueInput,
        data: types.FileHistoryUpsertInput,
        include: Optional[types.FileHistoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            FileHistory filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned FileHistory model

        Returns
        -------
        prisma.models.FileHistory
            The created or updated FileHistory record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        filehistory = await FileHistory.prisma().upsert(
            where={
                'id': 'bgjhijffjh',
            },
            data={
                'create': {
                    'id': 'bgjhijffjh',
                    'operationType': 'hhhegahcf',
                    'fileName': 'edhijefdi',
                    'userId': 'djddecjhb',
                    'status': 'bgdicjhie',
                },
                'update': {
                    'operationType': 'hhhegahcf',
                    'fileName': 'edhijefdi',
                    'userId': 'djddecjhb',
                    'status': 'bgdicjhie',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.FileHistoryUpdateManyMutationInput,
        where: types.FileHistoryWhereInput,
    ) -> int:
        """Update multiple FileHistory records

        Parameters
        ----------
        data
            FileHistory data to update the selected FileHistory records to
        where
            Filter to select the FileHistory records to update

        Returns
        -------
        int
            The total number of FileHistory records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all FileHistory records
        total = await FileHistory.prisma().update_many(
            data={
                'mimeType': 'bcigdhache'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FileHistoryWhereInput] = None,
        cursor: Optional[types.FileHistoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of FileHistory records present in the database

        Parameters
        ----------
        select
            Select the FileHistory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            FileHistory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.FileHistoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await FileHistory.prisma().count()

        # results: prisma.types.FileHistoryCountAggregateOutput
        results = await FileHistory.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.FileHistoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FileHistoryWhereInput] = None,
        cursor: Optional[types.FileHistoryWhereUniqueInput] = None,
    ) -> types.FileHistoryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.FileHistoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FileHistoryWhereInput] = None,
        cursor: Optional[types.FileHistoryWhereUniqueInput] = None,
    ) -> Union[int, types.FileHistoryCountAggregateOutput]:
        """Count the number of FileHistory records present in the database

        Parameters
        ----------
        select
            Select the FileHistory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            FileHistory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.FileHistoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await FileHistory.prisma().count()

        # results: prisma.types.FileHistoryCountAggregateOutput
        results = await FileHistory.prisma().count(
            select={
                '_all': True,
                'recordsProcessed': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.FileHistoryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.FileHistoryWhereInput] = None
    ) -> int:
        """Delete multiple FileHistory records.

        Parameters
        ----------
        where
            Optional FileHistory filter to find the records to be deleted

        Returns
        -------
        int
            The total number of FileHistory records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all FileHistory records
        total = await FileHistory.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.FileHistoryScalarFieldKeys'],
        *,
        where: Optional['types.FileHistoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.FileHistoryAvgAggregateInput'] = None,
        sum: Optional['types.FileHistorySumAggregateInput'] = None,
        min: Optional['types.FileHistoryMinAggregateInput'] = None,
        max: Optional['types.FileHistoryMaxAggregateInput'] = None,
        having: Optional['types.FileHistoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.FileHistoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.FileHistoryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.FileHistoryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.FileHistoryGroupByOutput']:
        """Group FileHistory records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar FileHistory fields to group records by
        where
            FileHistory filter to select records
        take
            Limit the maximum number of FileHistory records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.FileHistoryGroupByOutput]
            A list of dictionaries representing the FileHistory record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group FileHistory records by recordsCreated values
        # and count how many records are in each group
        results = await FileHistory.prisma().group_by(
            ['recordsCreated'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ReturnFormActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ReturnForm]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ReturnForm.prisma().query_raw(
            'SELECT * FROM ReturnForm WHERE id = $1',
            'igefhgdhb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ReturnForm
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ReturnForm.prisma().query_first(
            'SELECT * FROM ReturnForm WHERE employeeUserId = $1',
            'ejbiifbae',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ReturnFormCreateInput,
        include: Optional[types.ReturnFormInclude] = None
    ) -> _PrismaModelT:
        """Create a new ReturnForm record.

        Parameters
        ----------
        data
            ReturnForm record data
        include
            Specifies which relations should be loaded on the returned ReturnForm model

        Returns
        -------
        prisma.models.ReturnForm
            The created ReturnForm record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ReturnForm record from just the required fields
        returnform = await ReturnForm.prisma().create(
            data={
                # data to create a ReturnForm record
                'employeeUserId': 'djcfgedjd',
                'dateReturned': datetime.datetime.utcnow(),
                'returnType': 'bdbjcdegag',
                'formData': 'hbchfebch',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ReturnFormCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ReturnForm records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ReturnForm record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ReturnForm.prisma().create_many(
            data=[
                {
                    # data to create a ReturnForm record
                    'employeeUserId': 'bcjjffegfc',
                    'dateReturned': datetime.datetime.utcnow(),
                    'returnType': 'cahaeaicjd',
                    'formData': 'ibbjaacbi',
                },
                {
                    # data to create a ReturnForm record
                    'employeeUserId': 'djgacbcch',
                    'dateReturned': datetime.datetime.utcnow(),
                    'returnType': 'geeeegace',
                    'formData': 'bbgdigchd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ReturnFormWhereUniqueInput,
        include: Optional[types.ReturnFormInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ReturnForm record.

        Parameters
        ----------
        where
            ReturnForm filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ReturnForm model

        Returns
        -------
        prisma.models.ReturnForm
            The deleted ReturnForm record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        returnform = await ReturnForm.prisma().delete(
            where={
                'id': 'dajcifgdi',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ReturnFormWhereUniqueInput,
        include: Optional[types.ReturnFormInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ReturnForm record.

        Parameters
        ----------
        where
            ReturnForm filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ReturnForm model

        Returns
        -------
        prisma.models.ReturnForm
            The found ReturnForm record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        returnform = await ReturnForm.prisma().find_unique(
            where={
                'id': 'ccedhdbj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ReturnFormWhereUniqueInput,
        include: Optional[types.ReturnFormInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ReturnForm record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ReturnForm filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ReturnForm model

        Returns
        -------
        prisma.models.ReturnForm
            The found ReturnForm record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        returnform = await ReturnForm.prisma().find_unique_or_raise(
            where={
                'id': 'bjaabjjjce',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReturnFormWhereInput] = None,
        cursor: Optional[types.ReturnFormWhereUniqueInput] = None,
        include: Optional[types.ReturnFormInclude] = None,
        order: Optional[Union[types.ReturnFormOrderByInput, List[types.ReturnFormOrderByInput]]] = None,
        distinct: Optional[List[types.ReturnFormScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ReturnForm records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ReturnForm records returned
        skip
            Ignore the first N results
        where
            ReturnForm filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ReturnForm model
        order
            Order the returned ReturnForm records by any field
        distinct
            Filter ReturnForm records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ReturnForm]
            The list of all ReturnForm records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ReturnForm records
        returnforms = await ReturnForm.prisma().find_many(take=10)

        # find the first 5 ReturnForm records ordered by the dateReturned field
        returnforms = await ReturnForm.prisma().find_many(
            take=5,
            order={
                'dateReturned': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ReturnFormWhereInput] = None,
        cursor: Optional[types.ReturnFormWhereUniqueInput] = None,
        include: Optional[types.ReturnFormInclude] = None,
        order: Optional[Union[types.ReturnFormOrderByInput, List[types.ReturnFormOrderByInput]]] = None,
        distinct: Optional[List[types.ReturnFormScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ReturnForm record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ReturnForm filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ReturnForm model
        order
            Order the returned ReturnForm records by any field
        distinct
            Filter ReturnForm records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ReturnForm
            The first ReturnForm record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ReturnForm record ordered by the department field
        returnform = await ReturnForm.prisma().find_first(
            skip=1,
            order={
                'department': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ReturnFormWhereInput] = None,
        cursor: Optional[types.ReturnFormWhereUniqueInput] = None,
        include: Optional[types.ReturnFormInclude] = None,
        order: Optional[Union[types.ReturnFormOrderByInput, List[types.ReturnFormOrderByInput]]] = None,
        distinct: Optional[List[types.ReturnFormScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ReturnForm record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ReturnForm filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ReturnForm model
        order
            Order the returned ReturnForm records by any field
        distinct
            Filter ReturnForm records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ReturnForm
            The first ReturnForm record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ReturnForm record ordered by the ctrlNo field
        returnform = await ReturnForm.prisma().find_first_or_raise(
            skip=1,
            order={
                'ctrlNo': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ReturnFormUpdateInput,
        where: types.ReturnFormWhereUniqueInput,
        include: Optional[types.ReturnFormInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ReturnForm record.

        Parameters
        ----------
        data
            ReturnForm record data specifying what to update
        where
            ReturnForm filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ReturnForm model

        Returns
        -------
        prisma.models.ReturnForm
            The updated ReturnForm record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        returnform = await ReturnForm.prisma().update(
            where={
                'id': 'cafhdcdcjd',
            },
            data={
                # data to update the ReturnForm record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ReturnFormWhereUniqueInput,
        data: types.ReturnFormUpsertInput,
        include: Optional[types.ReturnFormInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ReturnForm filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ReturnForm model

        Returns
        -------
        prisma.models.ReturnForm
            The created or updated ReturnForm record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        returnform = await ReturnForm.prisma().upsert(
            where={
                'id': 'bdeebbhbdi',
            },
            data={
                'create': {
                    'id': 'bdeebbhbdi',
                    'employeeUserId': 'djgacbcch',
                    'dateReturned': datetime.datetime.utcnow(),
                    'returnType': 'geeeegace',
                    'formData': 'bbgdigchd',
                },
                'update': {
                    'employeeUserId': 'djgacbcch',
                    'dateReturned': datetime.datetime.utcnow(),
                    'returnType': 'geeeegace',
                    'formData': 'bbgdigchd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ReturnFormUpdateManyMutationInput,
        where: types.ReturnFormWhereInput,
    ) -> int:
        """Update multiple ReturnForm records

        Parameters
        ----------
        data
            ReturnForm data to update the selected ReturnForm records to
        where
            Filter to select the ReturnForm records to update

        Returns
        -------
        int
            The total number of ReturnForm records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ReturnForm records
        total = await ReturnForm.prisma().update_many(
            data={
                'returnType': 'cafcbdchah'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReturnFormWhereInput] = None,
        cursor: Optional[types.ReturnFormWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ReturnForm records present in the database

        Parameters
        ----------
        select
            Select the ReturnForm fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ReturnForm filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ReturnFormCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ReturnForm.prisma().count()

        # results: prisma.types.ReturnFormCountAggregateOutput
        results = await ReturnForm.prisma().count(
            select={
                '_all': True,
                'formData': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ReturnFormCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReturnFormWhereInput] = None,
        cursor: Optional[types.ReturnFormWhereUniqueInput] = None,
    ) -> types.ReturnFormCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ReturnFormCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReturnFormWhereInput] = None,
        cursor: Optional[types.ReturnFormWhereUniqueInput] = None,
    ) -> Union[int, types.ReturnFormCountAggregateOutput]:
        """Count the number of ReturnForm records present in the database

        Parameters
        ----------
        select
            Select the ReturnForm fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ReturnForm filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ReturnFormCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ReturnForm.prisma().count()

        # results: prisma.types.ReturnFormCountAggregateOutput
        results = await ReturnForm.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ReturnFormCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ReturnFormWhereInput] = None
    ) -> int:
        """Delete multiple ReturnForm records.

        Parameters
        ----------
        where
            Optional ReturnForm filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ReturnForm records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ReturnForm records
        total = await ReturnForm.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ReturnFormScalarFieldKeys'],
        *,
        where: Optional['types.ReturnFormWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ReturnFormAvgAggregateInput'] = None,
        sum: Optional['types.ReturnFormSumAggregateInput'] = None,
        min: Optional['types.ReturnFormMinAggregateInput'] = None,
        max: Optional['types.ReturnFormMaxAggregateInput'] = None,
        having: Optional['types.ReturnFormScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ReturnFormCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ReturnFormScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ReturnFormScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ReturnFormGroupByOutput']:
        """Group ReturnForm records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ReturnForm fields to group records by
        where
            ReturnForm filter to select records
        take
            Limit the maximum number of ReturnForm records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ReturnFormGroupByOutput]
            A list of dictionaries representing the ReturnForm record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ReturnForm records by updatedAt values
        # and count how many records are in each group
        results = await ReturnForm.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AccountabilityFormActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AccountabilityForm]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AccountabilityForm.prisma().query_raw(
            'SELECT * FROM AccountabilityForm WHERE id = $1',
            'bdffbehbae',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AccountabilityForm
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AccountabilityForm.prisma().query_first(
            'SELECT * FROM AccountabilityForm WHERE employeeUserId = $1',
            'ieahjgeb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AccountabilityFormCreateInput,
        include: Optional[types.AccountabilityFormInclude] = None
    ) -> _PrismaModelT:
        """Create a new AccountabilityForm record.

        Parameters
        ----------
        data
            AccountabilityForm record data
        include
            Specifies which relations should be loaded on the returned AccountabilityForm model

        Returns
        -------
        prisma.models.AccountabilityForm
            The created AccountabilityForm record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AccountabilityForm record from just the required fields
        accountabilityform = await AccountabilityForm.prisma().create(
            data={
                # data to create a AccountabilityForm record
                'employeeUserId': 'hfeeddceg',
                'dateIssued': datetime.datetime.utcnow(),
                'formData': 'dbecgbbid',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AccountabilityFormCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AccountabilityForm records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AccountabilityForm record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AccountabilityForm.prisma().create_many(
            data=[
                {
                    # data to create a AccountabilityForm record
                    'employeeUserId': 'cchghigae',
                    'dateIssued': datetime.datetime.utcnow(),
                    'formData': 'ecdjjjhab',
                },
                {
                    # data to create a AccountabilityForm record
                    'employeeUserId': 'biachfede',
                    'dateIssued': datetime.datetime.utcnow(),
                    'formData': 'fhgaibff',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AccountabilityFormWhereUniqueInput,
        include: Optional[types.AccountabilityFormInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AccountabilityForm record.

        Parameters
        ----------
        where
            AccountabilityForm filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AccountabilityForm model

        Returns
        -------
        prisma.models.AccountabilityForm
            The deleted AccountabilityForm record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        accountabilityform = await AccountabilityForm.prisma().delete(
            where={
                'id': 'cadajbcbca',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AccountabilityFormWhereUniqueInput,
        include: Optional[types.AccountabilityFormInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AccountabilityForm record.

        Parameters
        ----------
        where
            AccountabilityForm filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AccountabilityForm model

        Returns
        -------
        prisma.models.AccountabilityForm
            The found AccountabilityForm record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        accountabilityform = await AccountabilityForm.prisma().find_unique(
            where={
                'id': 'bjheigfcdd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AccountabilityFormWhereUniqueInput,
        include: Optional[types.AccountabilityFormInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AccountabilityForm record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AccountabilityForm filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AccountabilityForm model

        Returns
        -------
        prisma.models.AccountabilityForm
            The found AccountabilityForm record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        accountabilityform = await AccountabilityForm.prisma().find_unique_or_raise(
            where={
                'id': 'bjejigcdcg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountabilityFormWhereInput] = None,
        cursor: Optional[types.AccountabilityFormWhereUniqueInput] = None,
        include: Optional[types.AccountabilityFormInclude] = None,
        order: Optional[Union[types.AccountabilityFormOrderByInput, List[types.AccountabilityFormOrderByInput]]] = None,
        distinct: Optional[List[types.AccountabilityFormScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AccountabilityForm records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AccountabilityForm records returned
        skip
            Ignore the first N results
        where
            AccountabilityForm filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AccountabilityForm model
        order
            Order the returned AccountabilityForm records by any field
        distinct
            Filter AccountabilityForm records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AccountabilityForm]
            The list of all AccountabilityForm records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AccountabilityForm records
        accountabilityforms = await AccountabilityForm.prisma().find_many(take=10)

        # find the first 5 AccountabilityForm records ordered by the dateIssued field
        accountabilityforms = await AccountabilityForm.prisma().find_many(
            take=5,
            order={
                'dateIssued': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AccountabilityFormWhereInput] = None,
        cursor: Optional[types.AccountabilityFormWhereUniqueInput] = None,
        include: Optional[types.AccountabilityFormInclude] = None,
        order: Optional[Union[types.AccountabilityFormOrderByInput, List[types.AccountabilityFormOrderByInput]]] = None,
        distinct: Optional[List[types.AccountabilityFormScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AccountabilityForm record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AccountabilityForm filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AccountabilityForm model
        order
            Order the returned AccountabilityForm records by any field
        distinct
            Filter AccountabilityForm records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AccountabilityForm
            The first AccountabilityForm record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AccountabilityForm record ordered by the department field
        accountabilityform = await AccountabilityForm.prisma().find_first(
            skip=1,
            order={
                'department': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AccountabilityFormWhereInput] = None,
        cursor: Optional[types.AccountabilityFormWhereUniqueInput] = None,
        include: Optional[types.AccountabilityFormInclude] = None,
        order: Optional[Union[types.AccountabilityFormOrderByInput, List[types.AccountabilityFormOrderByInput]]] = None,
        distinct: Optional[List[types.AccountabilityFormScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AccountabilityForm record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AccountabilityForm filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AccountabilityForm model
        order
            Order the returned AccountabilityForm records by any field
        distinct
            Filter AccountabilityForm records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AccountabilityForm
            The first AccountabilityForm record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AccountabilityForm record ordered by the accountabilityFormNo field
        accountabilityform = await AccountabilityForm.prisma().find_first_or_raise(
            skip=1,
            order={
                'accountabilityFormNo': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AccountabilityFormUpdateInput,
        where: types.AccountabilityFormWhereUniqueInput,
        include: Optional[types.AccountabilityFormInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AccountabilityForm record.

        Parameters
        ----------
        data
            AccountabilityForm record data specifying what to update
        where
            AccountabilityForm filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AccountabilityForm model

        Returns
        -------
        prisma.models.AccountabilityForm
            The updated AccountabilityForm record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        accountabilityform = await AccountabilityForm.prisma().update(
            where={
                'id': 'bifiiibcah',
            },
            data={
                # data to update the AccountabilityForm record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AccountabilityFormWhereUniqueInput,
        data: types.AccountabilityFormUpsertInput,
        include: Optional[types.AccountabilityFormInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AccountabilityForm filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AccountabilityForm model

        Returns
        -------
        prisma.models.AccountabilityForm
            The created or updated AccountabilityForm record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        accountabilityform = await AccountabilityForm.prisma().upsert(
            where={
                'id': 'dbjibjdaa',
            },
            data={
                'create': {
                    'id': 'dbjibjdaa',
                    'employeeUserId': 'biachfede',
                    'dateIssued': datetime.datetime.utcnow(),
                    'formData': 'fhgaibff',
                },
                'update': {
                    'employeeUserId': 'biachfede',
                    'dateIssued': datetime.datetime.utcnow(),
                    'formData': 'fhgaibff',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AccountabilityFormUpdateManyMutationInput,
        where: types.AccountabilityFormWhereInput,
    ) -> int:
        """Update multiple AccountabilityForm records

        Parameters
        ----------
        data
            AccountabilityForm data to update the selected AccountabilityForm records to
        where
            Filter to select the AccountabilityForm records to update

        Returns
        -------
        int
            The total number of AccountabilityForm records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AccountabilityForm records
        total = await AccountabilityForm.prisma().update_many(
            data={
                'formData': 'dgijbdiaf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountabilityFormWhereInput] = None,
        cursor: Optional[types.AccountabilityFormWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AccountabilityForm records present in the database

        Parameters
        ----------
        select
            Select the AccountabilityForm fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AccountabilityForm filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AccountabilityFormCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AccountabilityForm.prisma().count()

        # results: prisma.types.AccountabilityFormCountAggregateOutput
        results = await AccountabilityForm.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AccountabilityFormCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountabilityFormWhereInput] = None,
        cursor: Optional[types.AccountabilityFormWhereUniqueInput] = None,
    ) -> types.AccountabilityFormCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AccountabilityFormCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountabilityFormWhereInput] = None,
        cursor: Optional[types.AccountabilityFormWhereUniqueInput] = None,
    ) -> Union[int, types.AccountabilityFormCountAggregateOutput]:
        """Count the number of AccountabilityForm records present in the database

        Parameters
        ----------
        select
            Select the AccountabilityForm fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AccountabilityForm filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AccountabilityFormCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AccountabilityForm.prisma().count()

        # results: prisma.types.AccountabilityFormCountAggregateOutput
        results = await AccountabilityForm.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AccountabilityFormCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AccountabilityFormWhereInput] = None
    ) -> int:
        """Delete multiple AccountabilityForm records.

        Parameters
        ----------
        where
            Optional AccountabilityForm filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AccountabilityForm records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AccountabilityForm records
        total = await AccountabilityForm.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AccountabilityFormScalarFieldKeys'],
        *,
        where: Optional['types.AccountabilityFormWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AccountabilityFormAvgAggregateInput'] = None,
        sum: Optional['types.AccountabilityFormSumAggregateInput'] = None,
        min: Optional['types.AccountabilityFormMinAggregateInput'] = None,
        max: Optional['types.AccountabilityFormMaxAggregateInput'] = None,
        having: Optional['types.AccountabilityFormScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AccountabilityFormCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AccountabilityFormScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AccountabilityFormScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AccountabilityFormGroupByOutput']:
        """Group AccountabilityForm records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AccountabilityForm fields to group records by
        where
            AccountabilityForm filter to select records
        take
            Limit the maximum number of AccountabilityForm records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AccountabilityFormGroupByOutput]
            A list of dictionaries representing the AccountabilityForm record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AccountabilityForm records by id values
        # and count how many records are in each group
        results = await AccountabilityForm.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AssetsLocationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AssetsLocation]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AssetsLocation.prisma().query_raw(
            'SELECT * FROM AssetsLocation WHERE id = $1',
            'begfaigba',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AssetsLocation
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AssetsLocation.prisma().query_first(
            'SELECT * FROM AssetsLocation WHERE name = $1',
            'bdjiafcgjb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AssetsLocationCreateInput,
        include: Optional[types.AssetsLocationInclude] = None
    ) -> _PrismaModelT:
        """Create a new AssetsLocation record.

        Parameters
        ----------
        data
            AssetsLocation record data
        include
            Specifies which relations should be loaded on the returned AssetsLocation model

        Returns
        -------
        prisma.models.AssetsLocation
            The created AssetsLocation record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AssetsLocation record from just the required fields
        assetslocation = await AssetsLocation.prisma().create(
            data={
                # data to create a AssetsLocation record
                'name': 'bficecgcfg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AssetsLocationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AssetsLocation records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AssetsLocation record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AssetsLocation.prisma().create_many(
            data=[
                {
                    # data to create a AssetsLocation record
                    'name': 'cbjjeedcj',
                },
                {
                    # data to create a AssetsLocation record
                    'name': 'dedgbbhja',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AssetsLocationWhereUniqueInput,
        include: Optional[types.AssetsLocationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AssetsLocation record.

        Parameters
        ----------
        where
            AssetsLocation filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsLocation model

        Returns
        -------
        prisma.models.AssetsLocation
            The deleted AssetsLocation record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetslocation = await AssetsLocation.prisma().delete(
            where={
                'id': 'cabiahchj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AssetsLocationWhereUniqueInput,
        include: Optional[types.AssetsLocationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AssetsLocation record.

        Parameters
        ----------
        where
            AssetsLocation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsLocation model

        Returns
        -------
        prisma.models.AssetsLocation
            The found AssetsLocation record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetslocation = await AssetsLocation.prisma().find_unique(
            where={
                'id': 'cgbeccfce',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AssetsLocationWhereUniqueInput,
        include: Optional[types.AssetsLocationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AssetsLocation record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AssetsLocation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsLocation model

        Returns
        -------
        prisma.models.AssetsLocation
            The found AssetsLocation record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetslocation = await AssetsLocation.prisma().find_unique_or_raise(
            where={
                'id': 'fcjcagef',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsLocationWhereInput] = None,
        cursor: Optional[types.AssetsLocationWhereUniqueInput] = None,
        include: Optional[types.AssetsLocationInclude] = None,
        order: Optional[Union[types.AssetsLocationOrderByInput, List[types.AssetsLocationOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsLocationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AssetsLocation records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AssetsLocation records returned
        skip
            Ignore the first N results
        where
            AssetsLocation filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsLocation model
        order
            Order the returned AssetsLocation records by any field
        distinct
            Filter AssetsLocation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AssetsLocation]
            The list of all AssetsLocation records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AssetsLocation records
        assetslocations = await AssetsLocation.prisma().find_many(take=10)

        # find the first 5 AssetsLocation records ordered by the description field
        assetslocations = await AssetsLocation.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsLocationWhereInput] = None,
        cursor: Optional[types.AssetsLocationWhereUniqueInput] = None,
        include: Optional[types.AssetsLocationInclude] = None,
        order: Optional[Union[types.AssetsLocationOrderByInput, List[types.AssetsLocationOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsLocationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AssetsLocation record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsLocation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsLocation model
        order
            Order the returned AssetsLocation records by any field
        distinct
            Filter AssetsLocation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsLocation
            The first AssetsLocation record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsLocation record ordered by the createdAt field
        assetslocation = await AssetsLocation.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsLocationWhereInput] = None,
        cursor: Optional[types.AssetsLocationWhereUniqueInput] = None,
        include: Optional[types.AssetsLocationInclude] = None,
        order: Optional[Union[types.AssetsLocationOrderByInput, List[types.AssetsLocationOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsLocationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AssetsLocation record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsLocation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsLocation model
        order
            Order the returned AssetsLocation records by any field
        distinct
            Filter AssetsLocation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsLocation
            The first AssetsLocation record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsLocation record ordered by the updatedAt field
        assetslocation = await AssetsLocation.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AssetsLocationUpdateInput,
        where: types.AssetsLocationWhereUniqueInput,
        include: Optional[types.AssetsLocationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AssetsLocation record.

        Parameters
        ----------
        data
            AssetsLocation record data specifying what to update
        where
            AssetsLocation filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AssetsLocation model

        Returns
        -------
        prisma.models.AssetsLocation
            The updated AssetsLocation record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        assetslocation = await AssetsLocation.prisma().update(
            where={
                'id': 'bgdhaeacic',
            },
            data={
                # data to update the AssetsLocation record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AssetsLocationWhereUniqueInput,
        data: types.AssetsLocationUpsertInput,
        include: Optional[types.AssetsLocationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AssetsLocation filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AssetsLocation model

        Returns
        -------
        prisma.models.AssetsLocation
            The created or updated AssetsLocation record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetslocation = await AssetsLocation.prisma().upsert(
            where={
                'id': 'caffafcheh',
            },
            data={
                'create': {
                    'id': 'caffafcheh',
                    'name': 'dedgbbhja',
                },
                'update': {
                    'name': 'dedgbbhja',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AssetsLocationUpdateManyMutationInput,
        where: types.AssetsLocationWhereInput,
    ) -> int:
        """Update multiple AssetsLocation records

        Parameters
        ----------
        data
            AssetsLocation data to update the selected AssetsLocation records to
        where
            Filter to select the AssetsLocation records to update

        Returns
        -------
        int
            The total number of AssetsLocation records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AssetsLocation records
        total = await AssetsLocation.prisma().update_many(
            data={
                'id': 'fjjbegge'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsLocationWhereInput] = None,
        cursor: Optional[types.AssetsLocationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AssetsLocation records present in the database

        Parameters
        ----------
        select
            Select the AssetsLocation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsLocation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsLocationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsLocation.prisma().count()

        # results: prisma.types.AssetsLocationCountAggregateOutput
        results = await AssetsLocation.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AssetsLocationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsLocationWhereInput] = None,
        cursor: Optional[types.AssetsLocationWhereUniqueInput] = None,
    ) -> types.AssetsLocationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AssetsLocationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsLocationWhereInput] = None,
        cursor: Optional[types.AssetsLocationWhereUniqueInput] = None,
    ) -> Union[int, types.AssetsLocationCountAggregateOutput]:
        """Count the number of AssetsLocation records present in the database

        Parameters
        ----------
        select
            Select the AssetsLocation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsLocation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsLocationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsLocation.prisma().count()

        # results: prisma.types.AssetsLocationCountAggregateOutput
        results = await AssetsLocation.prisma().count(
            select={
                '_all': True,
                'description': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AssetsLocationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AssetsLocationWhereInput] = None
    ) -> int:
        """Delete multiple AssetsLocation records.

        Parameters
        ----------
        where
            Optional AssetsLocation filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AssetsLocation records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AssetsLocation records
        total = await AssetsLocation.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AssetsLocationScalarFieldKeys'],
        *,
        where: Optional['types.AssetsLocationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AssetsLocationAvgAggregateInput'] = None,
        sum: Optional['types.AssetsLocationSumAggregateInput'] = None,
        min: Optional['types.AssetsLocationMinAggregateInput'] = None,
        max: Optional['types.AssetsLocationMaxAggregateInput'] = None,
        having: Optional['types.AssetsLocationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AssetsLocationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AssetsLocationScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AssetsLocationScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AssetsLocationGroupByOutput']:
        """Group AssetsLocation records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AssetsLocation fields to group records by
        where
            AssetsLocation filter to select records
        take
            Limit the maximum number of AssetsLocation records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AssetsLocationGroupByOutput]
            A list of dictionaries representing the AssetsLocation record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AssetsLocation records by createdAt values
        # and count how many records are in each group
        results = await AssetsLocation.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AssetsSiteActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AssetsSite]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AssetsSite.prisma().query_raw(
            'SELECT * FROM AssetsSite WHERE id = $1',
            'bdiifhbieb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AssetsSite
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AssetsSite.prisma().query_first(
            'SELECT * FROM AssetsSite WHERE name = $1',
            'cdcaejhgg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AssetsSiteCreateInput,
        include: Optional[types.AssetsSiteInclude] = None
    ) -> _PrismaModelT:
        """Create a new AssetsSite record.

        Parameters
        ----------
        data
            AssetsSite record data
        include
            Specifies which relations should be loaded on the returned AssetsSite model

        Returns
        -------
        prisma.models.AssetsSite
            The created AssetsSite record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AssetsSite record from just the required fields
        assetssite = await AssetsSite.prisma().create(
            data={
                # data to create a AssetsSite record
                'name': 'jbijgfbfj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AssetsSiteCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AssetsSite records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AssetsSite record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AssetsSite.prisma().create_many(
            data=[
                {
                    # data to create a AssetsSite record
                    'name': 'ggfbeddia',
                },
                {
                    # data to create a AssetsSite record
                    'name': 'djjejdaj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AssetsSiteWhereUniqueInput,
        include: Optional[types.AssetsSiteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AssetsSite record.

        Parameters
        ----------
        where
            AssetsSite filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsSite model

        Returns
        -------
        prisma.models.AssetsSite
            The deleted AssetsSite record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetssite = await AssetsSite.prisma().delete(
            where={
                'id': 'bjabbfceji',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AssetsSiteWhereUniqueInput,
        include: Optional[types.AssetsSiteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AssetsSite record.

        Parameters
        ----------
        where
            AssetsSite filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsSite model

        Returns
        -------
        prisma.models.AssetsSite
            The found AssetsSite record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetssite = await AssetsSite.prisma().find_unique(
            where={
                'id': 'bgchfbjibb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AssetsSiteWhereUniqueInput,
        include: Optional[types.AssetsSiteInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AssetsSite record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AssetsSite filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsSite model

        Returns
        -------
        prisma.models.AssetsSite
            The found AssetsSite record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetssite = await AssetsSite.prisma().find_unique_or_raise(
            where={
                'id': 'bajecchdjc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsSiteWhereInput] = None,
        cursor: Optional[types.AssetsSiteWhereUniqueInput] = None,
        include: Optional[types.AssetsSiteInclude] = None,
        order: Optional[Union[types.AssetsSiteOrderByInput, List[types.AssetsSiteOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsSiteScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AssetsSite records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AssetsSite records returned
        skip
            Ignore the first N results
        where
            AssetsSite filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsSite model
        order
            Order the returned AssetsSite records by any field
        distinct
            Filter AssetsSite records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AssetsSite]
            The list of all AssetsSite records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AssetsSite records
        assetssites = await AssetsSite.prisma().find_many(take=10)

        # find the first 5 AssetsSite records ordered by the description field
        assetssites = await AssetsSite.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsSiteWhereInput] = None,
        cursor: Optional[types.AssetsSiteWhereUniqueInput] = None,
        include: Optional[types.AssetsSiteInclude] = None,
        order: Optional[Union[types.AssetsSiteOrderByInput, List[types.AssetsSiteOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsSiteScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AssetsSite record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsSite filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsSite model
        order
            Order the returned AssetsSite records by any field
        distinct
            Filter AssetsSite records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsSite
            The first AssetsSite record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsSite record ordered by the createdAt field
        assetssite = await AssetsSite.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsSiteWhereInput] = None,
        cursor: Optional[types.AssetsSiteWhereUniqueInput] = None,
        include: Optional[types.AssetsSiteInclude] = None,
        order: Optional[Union[types.AssetsSiteOrderByInput, List[types.AssetsSiteOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsSiteScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AssetsSite record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsSite filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsSite model
        order
            Order the returned AssetsSite records by any field
        distinct
            Filter AssetsSite records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsSite
            The first AssetsSite record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsSite record ordered by the updatedAt field
        assetssite = await AssetsSite.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AssetsSiteUpdateInput,
        where: types.AssetsSiteWhereUniqueInput,
        include: Optional[types.AssetsSiteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AssetsSite record.

        Parameters
        ----------
        data
            AssetsSite record data specifying what to update
        where
            AssetsSite filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AssetsSite model

        Returns
        -------
        prisma.models.AssetsSite
            The updated AssetsSite record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        assetssite = await AssetsSite.prisma().update(
            where={
                'id': 'dfgacajif',
            },
            data={
                # data to update the AssetsSite record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AssetsSiteWhereUniqueInput,
        data: types.AssetsSiteUpsertInput,
        include: Optional[types.AssetsSiteInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AssetsSite filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AssetsSite model

        Returns
        -------
        prisma.models.AssetsSite
            The created or updated AssetsSite record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetssite = await AssetsSite.prisma().upsert(
            where={
                'id': 'bgdiddfadi',
            },
            data={
                'create': {
                    'id': 'bgdiddfadi',
                    'name': 'djjejdaj',
                },
                'update': {
                    'name': 'djjejdaj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AssetsSiteUpdateManyMutationInput,
        where: types.AssetsSiteWhereInput,
    ) -> int:
        """Update multiple AssetsSite records

        Parameters
        ----------
        data
            AssetsSite data to update the selected AssetsSite records to
        where
            Filter to select the AssetsSite records to update

        Returns
        -------
        int
            The total number of AssetsSite records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AssetsSite records
        total = await AssetsSite.prisma().update_many(
            data={
                'id': 'bijbfghhhf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsSiteWhereInput] = None,
        cursor: Optional[types.AssetsSiteWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AssetsSite records present in the database

        Parameters
        ----------
        select
            Select the AssetsSite fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsSite filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsSiteCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsSite.prisma().count()

        # results: prisma.types.AssetsSiteCountAggregateOutput
        results = await AssetsSite.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AssetsSiteCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsSiteWhereInput] = None,
        cursor: Optional[types.AssetsSiteWhereUniqueInput] = None,
    ) -> types.AssetsSiteCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AssetsSiteCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsSiteWhereInput] = None,
        cursor: Optional[types.AssetsSiteWhereUniqueInput] = None,
    ) -> Union[int, types.AssetsSiteCountAggregateOutput]:
        """Count the number of AssetsSite records present in the database

        Parameters
        ----------
        select
            Select the AssetsSite fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsSite filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsSiteCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsSite.prisma().count()

        # results: prisma.types.AssetsSiteCountAggregateOutput
        results = await AssetsSite.prisma().count(
            select={
                '_all': True,
                'description': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AssetsSiteCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AssetsSiteWhereInput] = None
    ) -> int:
        """Delete multiple AssetsSite records.

        Parameters
        ----------
        where
            Optional AssetsSite filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AssetsSite records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AssetsSite records
        total = await AssetsSite.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AssetsSiteScalarFieldKeys'],
        *,
        where: Optional['types.AssetsSiteWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AssetsSiteAvgAggregateInput'] = None,
        sum: Optional['types.AssetsSiteSumAggregateInput'] = None,
        min: Optional['types.AssetsSiteMinAggregateInput'] = None,
        max: Optional['types.AssetsSiteMaxAggregateInput'] = None,
        having: Optional['types.AssetsSiteScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AssetsSiteCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AssetsSiteScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AssetsSiteScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AssetsSiteGroupByOutput']:
        """Group AssetsSite records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AssetsSite fields to group records by
        where
            AssetsSite filter to select records
        take
            Limit the maximum number of AssetsSite records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AssetsSiteGroupByOutput]
            A list of dictionaries representing the AssetsSite record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AssetsSite records by createdAt values
        # and count how many records are in each group
        results = await AssetsSite.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AssetsDepartmentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AssetsDepartment]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AssetsDepartment.prisma().query_raw(
            'SELECT * FROM AssetsDepartment WHERE id = $1',
            'bahchhihdc',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AssetsDepartment
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AssetsDepartment.prisma().query_first(
            'SELECT * FROM AssetsDepartment WHERE name = $1',
            'bihjdcibib',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AssetsDepartmentCreateInput,
        include: Optional[types.AssetsDepartmentInclude] = None
    ) -> _PrismaModelT:
        """Create a new AssetsDepartment record.

        Parameters
        ----------
        data
            AssetsDepartment record data
        include
            Specifies which relations should be loaded on the returned AssetsDepartment model

        Returns
        -------
        prisma.models.AssetsDepartment
            The created AssetsDepartment record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AssetsDepartment record from just the required fields
        assetsdepartment = await AssetsDepartment.prisma().create(
            data={
                # data to create a AssetsDepartment record
                'name': 'bfhhjbbdha',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AssetsDepartmentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AssetsDepartment records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AssetsDepartment record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AssetsDepartment.prisma().create_many(
            data=[
                {
                    # data to create a AssetsDepartment record
                    'name': 'faehcjfdb',
                },
                {
                    # data to create a AssetsDepartment record
                    'name': 'bbaiefbee',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AssetsDepartmentWhereUniqueInput,
        include: Optional[types.AssetsDepartmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AssetsDepartment record.

        Parameters
        ----------
        where
            AssetsDepartment filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsDepartment model

        Returns
        -------
        prisma.models.AssetsDepartment
            The deleted AssetsDepartment record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsdepartment = await AssetsDepartment.prisma().delete(
            where={
                'id': 'bdaacgjbaf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AssetsDepartmentWhereUniqueInput,
        include: Optional[types.AssetsDepartmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AssetsDepartment record.

        Parameters
        ----------
        where
            AssetsDepartment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsDepartment model

        Returns
        -------
        prisma.models.AssetsDepartment
            The found AssetsDepartment record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsdepartment = await AssetsDepartment.prisma().find_unique(
            where={
                'id': 'biibaighec',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AssetsDepartmentWhereUniqueInput,
        include: Optional[types.AssetsDepartmentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AssetsDepartment record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AssetsDepartment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetsDepartment model

        Returns
        -------
        prisma.models.AssetsDepartment
            The found AssetsDepartment record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsdepartment = await AssetsDepartment.prisma().find_unique_or_raise(
            where={
                'id': 'baicdfeidj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsDepartmentWhereInput] = None,
        cursor: Optional[types.AssetsDepartmentWhereUniqueInput] = None,
        include: Optional[types.AssetsDepartmentInclude] = None,
        order: Optional[Union[types.AssetsDepartmentOrderByInput, List[types.AssetsDepartmentOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsDepartmentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AssetsDepartment records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AssetsDepartment records returned
        skip
            Ignore the first N results
        where
            AssetsDepartment filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsDepartment model
        order
            Order the returned AssetsDepartment records by any field
        distinct
            Filter AssetsDepartment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AssetsDepartment]
            The list of all AssetsDepartment records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AssetsDepartment records
        assetsdepartments = await AssetsDepartment.prisma().find_many(take=10)

        # find the first 5 AssetsDepartment records ordered by the description field
        assetsdepartments = await AssetsDepartment.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsDepartmentWhereInput] = None,
        cursor: Optional[types.AssetsDepartmentWhereUniqueInput] = None,
        include: Optional[types.AssetsDepartmentInclude] = None,
        order: Optional[Union[types.AssetsDepartmentOrderByInput, List[types.AssetsDepartmentOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsDepartmentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AssetsDepartment record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsDepartment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsDepartment model
        order
            Order the returned AssetsDepartment records by any field
        distinct
            Filter AssetsDepartment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsDepartment
            The first AssetsDepartment record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsDepartment record ordered by the createdAt field
        assetsdepartment = await AssetsDepartment.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetsDepartmentWhereInput] = None,
        cursor: Optional[types.AssetsDepartmentWhereUniqueInput] = None,
        include: Optional[types.AssetsDepartmentInclude] = None,
        order: Optional[Union[types.AssetsDepartmentOrderByInput, List[types.AssetsDepartmentOrderByInput]]] = None,
        distinct: Optional[List[types.AssetsDepartmentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AssetsDepartment record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetsDepartment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetsDepartment model
        order
            Order the returned AssetsDepartment records by any field
        distinct
            Filter AssetsDepartment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetsDepartment
            The first AssetsDepartment record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetsDepartment record ordered by the updatedAt field
        assetsdepartment = await AssetsDepartment.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AssetsDepartmentUpdateInput,
        where: types.AssetsDepartmentWhereUniqueInput,
        include: Optional[types.AssetsDepartmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AssetsDepartment record.

        Parameters
        ----------
        data
            AssetsDepartment record data specifying what to update
        where
            AssetsDepartment filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AssetsDepartment model

        Returns
        -------
        prisma.models.AssetsDepartment
            The updated AssetsDepartment record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        assetsdepartment = await AssetsDepartment.prisma().update(
            where={
                'id': 'befgiciadg',
            },
            data={
                # data to update the AssetsDepartment record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AssetsDepartmentWhereUniqueInput,
        data: types.AssetsDepartmentUpsertInput,
        include: Optional[types.AssetsDepartmentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AssetsDepartment filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AssetsDepartment model

        Returns
        -------
        prisma.models.AssetsDepartment
            The created or updated AssetsDepartment record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetsdepartment = await AssetsDepartment.prisma().upsert(
            where={
                'id': 'cbcehahedh',
            },
            data={
                'create': {
                    'id': 'cbcehahedh',
                    'name': 'bbaiefbee',
                },
                'update': {
                    'name': 'bbaiefbee',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AssetsDepartmentUpdateManyMutationInput,
        where: types.AssetsDepartmentWhereInput,
    ) -> int:
        """Update multiple AssetsDepartment records

        Parameters
        ----------
        data
            AssetsDepartment data to update the selected AssetsDepartment records to
        where
            Filter to select the AssetsDepartment records to update

        Returns
        -------
        int
            The total number of AssetsDepartment records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AssetsDepartment records
        total = await AssetsDepartment.prisma().update_many(
            data={
                'id': 'bcjihiaide'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsDepartmentWhereInput] = None,
        cursor: Optional[types.AssetsDepartmentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AssetsDepartment records present in the database

        Parameters
        ----------
        select
            Select the AssetsDepartment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsDepartment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsDepartmentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsDepartment.prisma().count()

        # results: prisma.types.AssetsDepartmentCountAggregateOutput
        results = await AssetsDepartment.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AssetsDepartmentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsDepartmentWhereInput] = None,
        cursor: Optional[types.AssetsDepartmentWhereUniqueInput] = None,
    ) -> types.AssetsDepartmentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AssetsDepartmentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetsDepartmentWhereInput] = None,
        cursor: Optional[types.AssetsDepartmentWhereUniqueInput] = None,
    ) -> Union[int, types.AssetsDepartmentCountAggregateOutput]:
        """Count the number of AssetsDepartment records present in the database

        Parameters
        ----------
        select
            Select the AssetsDepartment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetsDepartment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetsDepartmentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetsDepartment.prisma().count()

        # results: prisma.types.AssetsDepartmentCountAggregateOutput
        results = await AssetsDepartment.prisma().count(
            select={
                '_all': True,
                'description': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AssetsDepartmentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AssetsDepartmentWhereInput] = None
    ) -> int:
        """Delete multiple AssetsDepartment records.

        Parameters
        ----------
        where
            Optional AssetsDepartment filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AssetsDepartment records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AssetsDepartment records
        total = await AssetsDepartment.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AssetsDepartmentScalarFieldKeys'],
        *,
        where: Optional['types.AssetsDepartmentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AssetsDepartmentAvgAggregateInput'] = None,
        sum: Optional['types.AssetsDepartmentSumAggregateInput'] = None,
        min: Optional['types.AssetsDepartmentMinAggregateInput'] = None,
        max: Optional['types.AssetsDepartmentMaxAggregateInput'] = None,
        having: Optional['types.AssetsDepartmentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AssetsDepartmentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AssetsDepartmentScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AssetsDepartmentScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AssetsDepartmentGroupByOutput']:
        """Group AssetsDepartment records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AssetsDepartment fields to group records by
        where
            AssetsDepartment filter to select records
        take
            Limit the maximum number of AssetsDepartment records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AssetsDepartmentGroupByOutput]
            A list of dictionaries representing the AssetsDepartment record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AssetsDepartment records by createdAt values
        # and count how many records are in each group
        results = await AssetsDepartment.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class InventoryItemActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.InventoryItem]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await InventoryItem.prisma().query_raw(
            'SELECT * FROM InventoryItem WHERE id = $1',
            'bagfijcgfj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.InventoryItem
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await InventoryItem.prisma().query_first(
            'SELECT * FROM InventoryItem WHERE itemCode = $1',
            'bcggehiidc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.InventoryItemCreateInput,
        include: Optional[types.InventoryItemInclude] = None
    ) -> _PrismaModelT:
        """Create a new InventoryItem record.

        Parameters
        ----------
        data
            InventoryItem record data
        include
            Specifies which relations should be loaded on the returned InventoryItem model

        Returns
        -------
        prisma.models.InventoryItem
            The created InventoryItem record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a InventoryItem record from just the required fields
        inventoryitem = await InventoryItem.prisma().create(
            data={
                # data to create a InventoryItem record
                'itemCode': 'bjcdacgacf',
                'name': 'jfieeahi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.InventoryItemCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple InventoryItem records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of InventoryItem record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await InventoryItem.prisma().create_many(
            data=[
                {
                    # data to create a InventoryItem record
                    'itemCode': 'bijfjbddfj',
                    'name': 'cdcdjdcee',
                },
                {
                    # data to create a InventoryItem record
                    'itemCode': 'bbbgjdbgcb',
                    'name': 'bcedacgecg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.InventoryItemWhereUniqueInput,
        include: Optional[types.InventoryItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single InventoryItem record.

        Parameters
        ----------
        where
            InventoryItem filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned InventoryItem model

        Returns
        -------
        prisma.models.InventoryItem
            The deleted InventoryItem record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        inventoryitem = await InventoryItem.prisma().delete(
            where={
                'id': 'cbdffjeh',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.InventoryItemWhereUniqueInput,
        include: Optional[types.InventoryItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique InventoryItem record.

        Parameters
        ----------
        where
            InventoryItem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned InventoryItem model

        Returns
        -------
        prisma.models.InventoryItem
            The found InventoryItem record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        inventoryitem = await InventoryItem.prisma().find_unique(
            where={
                'id': 'idbcdhbci',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.InventoryItemWhereUniqueInput,
        include: Optional[types.InventoryItemInclude] = None
    ) -> _PrismaModelT:
        """Find a unique InventoryItem record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            InventoryItem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned InventoryItem model

        Returns
        -------
        prisma.models.InventoryItem
            The found InventoryItem record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        inventoryitem = await InventoryItem.prisma().find_unique_or_raise(
            where={
                'id': 'bacegehahd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InventoryItemWhereInput] = None,
        cursor: Optional[types.InventoryItemWhereUniqueInput] = None,
        include: Optional[types.InventoryItemInclude] = None,
        order: Optional[Union[types.InventoryItemOrderByInput, List[types.InventoryItemOrderByInput]]] = None,
        distinct: Optional[List[types.InventoryItemScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple InventoryItem records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of InventoryItem records returned
        skip
            Ignore the first N results
        where
            InventoryItem filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned InventoryItem model
        order
            Order the returned InventoryItem records by any field
        distinct
            Filter InventoryItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.InventoryItem]
            The list of all InventoryItem records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 InventoryItem records
        inventoryitems = await InventoryItem.prisma().find_many(take=10)

        # find the first 5 InventoryItem records ordered by the name field
        inventoryitems = await InventoryItem.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.InventoryItemWhereInput] = None,
        cursor: Optional[types.InventoryItemWhereUniqueInput] = None,
        include: Optional[types.InventoryItemInclude] = None,
        order: Optional[Union[types.InventoryItemOrderByInput, List[types.InventoryItemOrderByInput]]] = None,
        distinct: Optional[List[types.InventoryItemScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single InventoryItem record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            InventoryItem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned InventoryItem model
        order
            Order the returned InventoryItem records by any field
        distinct
            Filter InventoryItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.InventoryItem
            The first InventoryItem record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second InventoryItem record ordered by the description field
        inventoryitem = await InventoryItem.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.InventoryItemWhereInput] = None,
        cursor: Optional[types.InventoryItemWhereUniqueInput] = None,
        include: Optional[types.InventoryItemInclude] = None,
        order: Optional[Union[types.InventoryItemOrderByInput, List[types.InventoryItemOrderByInput]]] = None,
        distinct: Optional[List[types.InventoryItemScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single InventoryItem record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            InventoryItem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned InventoryItem model
        order
            Order the returned InventoryItem records by any field
        distinct
            Filter InventoryItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.InventoryItem
            The first InventoryItem record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second InventoryItem record ordered by the category field
        inventoryitem = await InventoryItem.prisma().find_first_or_raise(
            skip=1,
            order={
                'category': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.InventoryItemUpdateInput,
        where: types.InventoryItemWhereUniqueInput,
        include: Optional[types.InventoryItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single InventoryItem record.

        Parameters
        ----------
        data
            InventoryItem record data specifying what to update
        where
            InventoryItem filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned InventoryItem model

        Returns
        -------
        prisma.models.InventoryItem
            The updated InventoryItem record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        inventoryitem = await InventoryItem.prisma().update(
            where={
                'id': 'ebedeihec',
            },
            data={
                # data to update the InventoryItem record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.InventoryItemWhereUniqueInput,
        data: types.InventoryItemUpsertInput,
        include: Optional[types.InventoryItemInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            InventoryItem filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned InventoryItem model

        Returns
        -------
        prisma.models.InventoryItem
            The created or updated InventoryItem record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        inventoryitem = await InventoryItem.prisma().upsert(
            where={
                'id': 'bajagjdfbb',
            },
            data={
                'create': {
                    'id': 'bajagjdfbb',
                    'itemCode': 'bbbgjdbgcb',
                    'name': 'bcedacgecg',
                },
                'update': {
                    'itemCode': 'bbbgjdbgcb',
                    'name': 'bcedacgecg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.InventoryItemUpdateManyMutationInput,
        where: types.InventoryItemWhereInput,
    ) -> int:
        """Update multiple InventoryItem records

        Parameters
        ----------
        data
            InventoryItem data to update the selected InventoryItem records to
        where
            Filter to select the InventoryItem records to update

        Returns
        -------
        int
            The total number of InventoryItem records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all InventoryItem records
        total = await InventoryItem.prisma().update_many(
            data={
                'unit': 'bggedbjggi'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InventoryItemWhereInput] = None,
        cursor: Optional[types.InventoryItemWhereUniqueInput] = None,
    ) -> int:
        """Count the number of InventoryItem records present in the database

        Parameters
        ----------
        select
            Select the InventoryItem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            InventoryItem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.InventoryItemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await InventoryItem.prisma().count()

        # results: prisma.types.InventoryItemCountAggregateOutput
        results = await InventoryItem.prisma().count(
            select={
                '_all': True,
                'currentStock': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.InventoryItemCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InventoryItemWhereInput] = None,
        cursor: Optional[types.InventoryItemWhereUniqueInput] = None,
    ) -> types.InventoryItemCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.InventoryItemCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InventoryItemWhereInput] = None,
        cursor: Optional[types.InventoryItemWhereUniqueInput] = None,
    ) -> Union[int, types.InventoryItemCountAggregateOutput]:
        """Count the number of InventoryItem records present in the database

        Parameters
        ----------
        select
            Select the InventoryItem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            InventoryItem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.InventoryItemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await InventoryItem.prisma().count()

        # results: prisma.types.InventoryItemCountAggregateOutput
        results = await InventoryItem.prisma().count(
            select={
                '_all': True,
                'minStockLevel': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.InventoryItemCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.InventoryItemWhereInput] = None
    ) -> int:
        """Delete multiple InventoryItem records.

        Parameters
        ----------
        where
            Optional InventoryItem filter to find the records to be deleted

        Returns
        -------
        int
            The total number of InventoryItem records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all InventoryItem records
        total = await InventoryItem.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.InventoryItemScalarFieldKeys'],
        *,
        where: Optional['types.InventoryItemWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.InventoryItemAvgAggregateInput'] = None,
        sum: Optional['types.InventoryItemSumAggregateInput'] = None,
        min: Optional['types.InventoryItemMinAggregateInput'] = None,
        max: Optional['types.InventoryItemMaxAggregateInput'] = None,
        having: Optional['types.InventoryItemScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.InventoryItemCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.InventoryItemScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.InventoryItemScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.InventoryItemGroupByOutput']:
        """Group InventoryItem records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar InventoryItem fields to group records by
        where
            InventoryItem filter to select records
        take
            Limit the maximum number of InventoryItem records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.InventoryItemGroupByOutput]
            A list of dictionaries representing the InventoryItem record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group InventoryItem records by maxStockLevel values
        # and count how many records are in each group
        results = await InventoryItem.prisma().group_by(
            ['maxStockLevel'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class InventoryTransactionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.InventoryTransaction]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await InventoryTransaction.prisma().query_raw(
            'SELECT * FROM InventoryTransaction WHERE id = $1',
            'hgbafifcf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.InventoryTransaction
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await InventoryTransaction.prisma().query_first(
            'SELECT * FROM InventoryTransaction WHERE inventoryItemId = $1',
            'bejiecfecg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.InventoryTransactionCreateInput,
        include: Optional[types.InventoryTransactionInclude] = None
    ) -> _PrismaModelT:
        """Create a new InventoryTransaction record.

        Parameters
        ----------
        data
            InventoryTransaction record data
        include
            Specifies which relations should be loaded on the returned InventoryTransaction model

        Returns
        -------
        prisma.models.InventoryTransaction
            The created InventoryTransaction record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a InventoryTransaction record from just the required fields
        inventorytransaction = await InventoryTransaction.prisma().create(
            data={
                # data to create a InventoryTransaction record
                'inventoryItemId': 'bjgacaeagh',
                'transactionType': 'beeaihbefg',
                'quantity': Decimal('1515643353.91674'),
                'actionBy': 'eejajbid',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.InventoryTransactionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple InventoryTransaction records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of InventoryTransaction record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await InventoryTransaction.prisma().create_many(
            data=[
                {
                    # data to create a InventoryTransaction record
                    'inventoryItemId': 'efhdcdaie',
                    'transactionType': 'cadejecgbd',
                    'quantity': Decimal('1079799722.41717'),
                    'actionBy': 'bdiefcdfhg',
                },
                {
                    # data to create a InventoryTransaction record
                    'inventoryItemId': 'cheifeghd',
                    'transactionType': 'fgijheefe',
                    'quantity': Decimal('721617527.151116'),
                    'actionBy': 'ibijjdeb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.InventoryTransactionWhereUniqueInput,
        include: Optional[types.InventoryTransactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single InventoryTransaction record.

        Parameters
        ----------
        where
            InventoryTransaction filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned InventoryTransaction model

        Returns
        -------
        prisma.models.InventoryTransaction
            The deleted InventoryTransaction record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        inventorytransaction = await InventoryTransaction.prisma().delete(
            where={
                'id': 'caehiccddi',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.InventoryTransactionWhereUniqueInput,
        include: Optional[types.InventoryTransactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique InventoryTransaction record.

        Parameters
        ----------
        where
            InventoryTransaction filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned InventoryTransaction model

        Returns
        -------
        prisma.models.InventoryTransaction
            The found InventoryTransaction record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        inventorytransaction = await InventoryTransaction.prisma().find_unique(
            where={
                'id': 'bgcahjbafj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.InventoryTransactionWhereUniqueInput,
        include: Optional[types.InventoryTransactionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique InventoryTransaction record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            InventoryTransaction filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned InventoryTransaction model

        Returns
        -------
        prisma.models.InventoryTransaction
            The found InventoryTransaction record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        inventorytransaction = await InventoryTransaction.prisma().find_unique_or_raise(
            where={
                'id': 'bihhgeihca',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InventoryTransactionWhereInput] = None,
        cursor: Optional[types.InventoryTransactionWhereUniqueInput] = None,
        include: Optional[types.InventoryTransactionInclude] = None,
        order: Optional[Union[types.InventoryTransactionOrderByInput, List[types.InventoryTransactionOrderByInput]]] = None,
        distinct: Optional[List[types.InventoryTransactionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple InventoryTransaction records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of InventoryTransaction records returned
        skip
            Ignore the first N results
        where
            InventoryTransaction filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned InventoryTransaction model
        order
            Order the returned InventoryTransaction records by any field
        distinct
            Filter InventoryTransaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.InventoryTransaction]
            The list of all InventoryTransaction records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 InventoryTransaction records
        inventorytransactions = await InventoryTransaction.prisma().find_many(take=10)

        # find the first 5 InventoryTransaction records ordered by the transactionType field
        inventorytransactions = await InventoryTransaction.prisma().find_many(
            take=5,
            order={
                'transactionType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.InventoryTransactionWhereInput] = None,
        cursor: Optional[types.InventoryTransactionWhereUniqueInput] = None,
        include: Optional[types.InventoryTransactionInclude] = None,
        order: Optional[Union[types.InventoryTransactionOrderByInput, List[types.InventoryTransactionOrderByInput]]] = None,
        distinct: Optional[List[types.InventoryTransactionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single InventoryTransaction record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            InventoryTransaction filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned InventoryTransaction model
        order
            Order the returned InventoryTransaction records by any field
        distinct
            Filter InventoryTransaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.InventoryTransaction
            The first InventoryTransaction record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second InventoryTransaction record ordered by the quantity field
        inventorytransaction = await InventoryTransaction.prisma().find_first(
            skip=1,
            order={
                'quantity': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.InventoryTransactionWhereInput] = None,
        cursor: Optional[types.InventoryTransactionWhereUniqueInput] = None,
        include: Optional[types.InventoryTransactionInclude] = None,
        order: Optional[Union[types.InventoryTransactionOrderByInput, List[types.InventoryTransactionOrderByInput]]] = None,
        distinct: Optional[List[types.InventoryTransactionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single InventoryTransaction record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            InventoryTransaction filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned InventoryTransaction model
        order
            Order the returned InventoryTransaction records by any field
        distinct
            Filter InventoryTransaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.InventoryTransaction
            The first InventoryTransaction record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second InventoryTransaction record ordered by the unitCost field
        inventorytransaction = await InventoryTransaction.prisma().find_first_or_raise(
            skip=1,
            order={
                'unitCost': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.InventoryTransactionUpdateInput,
        where: types.InventoryTransactionWhereUniqueInput,
        include: Optional[types.InventoryTransactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single InventoryTransaction record.

        Parameters
        ----------
        data
            InventoryTransaction record data specifying what to update
        where
            InventoryTransaction filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned InventoryTransaction model

        Returns
        -------
        prisma.models.InventoryTransaction
            The updated InventoryTransaction record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        inventorytransaction = await InventoryTransaction.prisma().update(
            where={
                'id': 'bdgbfahbef',
            },
            data={
                # data to update the InventoryTransaction record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.InventoryTransactionWhereUniqueInput,
        data: types.InventoryTransactionUpsertInput,
        include: Optional[types.InventoryTransactionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            InventoryTransaction filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned InventoryTransaction model

        Returns
        -------
        prisma.models.InventoryTransaction
            The created or updated InventoryTransaction record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        inventorytransaction = await InventoryTransaction.prisma().upsert(
            where={
                'id': 'fccjhidic',
            },
            data={
                'create': {
                    'id': 'fccjhidic',
                    'inventoryItemId': 'cheifeghd',
                    'transactionType': 'fgijheefe',
                    'quantity': Decimal('721617527.151116'),
                    'actionBy': 'ibijjdeb',
                },
                'update': {
                    'inventoryItemId': 'cheifeghd',
                    'transactionType': 'fgijheefe',
                    'quantity': Decimal('721617527.151116'),
                    'actionBy': 'ibijjdeb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.InventoryTransactionUpdateManyMutationInput,
        where: types.InventoryTransactionWhereInput,
    ) -> int:
        """Update multiple InventoryTransaction records

        Parameters
        ----------
        data
            InventoryTransaction data to update the selected InventoryTransaction records to
        where
            Filter to select the InventoryTransaction records to update

        Returns
        -------
        int
            The total number of InventoryTransaction records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all InventoryTransaction records
        total = await InventoryTransaction.prisma().update_many(
            data={
                'reference': 'bdgfdgdaff'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InventoryTransactionWhereInput] = None,
        cursor: Optional[types.InventoryTransactionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of InventoryTransaction records present in the database

        Parameters
        ----------
        select
            Select the InventoryTransaction fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            InventoryTransaction filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.InventoryTransactionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await InventoryTransaction.prisma().count()

        # results: prisma.types.InventoryTransactionCountAggregateOutput
        results = await InventoryTransaction.prisma().count(
            select={
                '_all': True,
                'notes': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.InventoryTransactionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InventoryTransactionWhereInput] = None,
        cursor: Optional[types.InventoryTransactionWhereUniqueInput] = None,
    ) -> types.InventoryTransactionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.InventoryTransactionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InventoryTransactionWhereInput] = None,
        cursor: Optional[types.InventoryTransactionWhereUniqueInput] = None,
    ) -> Union[int, types.InventoryTransactionCountAggregateOutput]:
        """Count the number of InventoryTransaction records present in the database

        Parameters
        ----------
        select
            Select the InventoryTransaction fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            InventoryTransaction filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.InventoryTransactionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await InventoryTransaction.prisma().count()

        # results: prisma.types.InventoryTransactionCountAggregateOutput
        results = await InventoryTransaction.prisma().count(
            select={
                '_all': True,
                'actionBy': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.InventoryTransactionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.InventoryTransactionWhereInput] = None
    ) -> int:
        """Delete multiple InventoryTransaction records.

        Parameters
        ----------
        where
            Optional InventoryTransaction filter to find the records to be deleted

        Returns
        -------
        int
            The total number of InventoryTransaction records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all InventoryTransaction records
        total = await InventoryTransaction.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.InventoryTransactionScalarFieldKeys'],
        *,
        where: Optional['types.InventoryTransactionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.InventoryTransactionAvgAggregateInput'] = None,
        sum: Optional['types.InventoryTransactionSumAggregateInput'] = None,
        min: Optional['types.InventoryTransactionMinAggregateInput'] = None,
        max: Optional['types.InventoryTransactionMaxAggregateInput'] = None,
        having: Optional['types.InventoryTransactionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.InventoryTransactionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.InventoryTransactionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.InventoryTransactionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.InventoryTransactionGroupByOutput']:
        """Group InventoryTransaction records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar InventoryTransaction fields to group records by
        where
            InventoryTransaction filter to select records
        take
            Limit the maximum number of InventoryTransaction records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.InventoryTransactionGroupByOutput]
            A list of dictionaries representing the InventoryTransaction record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group InventoryTransaction records by transactionDate values
        # and count how many records are in each group
        results = await InventoryTransaction.prisma().group_by(
            ['transactionDate'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CompanyInfoActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.CompanyInfo]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await CompanyInfo.prisma().query_raw(
            'SELECT * FROM CompanyInfo WHERE id = $1',
            'bicgeaiaga',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.CompanyInfo
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await CompanyInfo.prisma().query_first(
            'SELECT * FROM CompanyInfo WHERE companyName = $1',
            'fajhhafab',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CompanyInfoCreateInput,
        include: Optional[types.CompanyInfoInclude] = None
    ) -> _PrismaModelT:
        """Create a new CompanyInfo record.

        Parameters
        ----------
        data
            CompanyInfo record data
        include
            Specifies which relations should be loaded on the returned CompanyInfo model

        Returns
        -------
        prisma.models.CompanyInfo
            The created CompanyInfo record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a CompanyInfo record from just the required fields
        companyinfo = await CompanyInfo.prisma().create(
            data={
                # data to create a CompanyInfo record
                'companyName': 'bfeiccieec',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CompanyInfoCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple CompanyInfo records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of CompanyInfo record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await CompanyInfo.prisma().create_many(
            data=[
                {
                    # data to create a CompanyInfo record
                    'companyName': 'hciegiihf',
                },
                {
                    # data to create a CompanyInfo record
                    'companyName': 'bahifjfga',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CompanyInfoWhereUniqueInput,
        include: Optional[types.CompanyInfoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single CompanyInfo record.

        Parameters
        ----------
        where
            CompanyInfo filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned CompanyInfo model

        Returns
        -------
        prisma.models.CompanyInfo
            The deleted CompanyInfo record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        companyinfo = await CompanyInfo.prisma().delete(
            where={
                'id': 'baebfehjaf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CompanyInfoWhereUniqueInput,
        include: Optional[types.CompanyInfoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique CompanyInfo record.

        Parameters
        ----------
        where
            CompanyInfo filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CompanyInfo model

        Returns
        -------
        prisma.models.CompanyInfo
            The found CompanyInfo record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        companyinfo = await CompanyInfo.prisma().find_unique(
            where={
                'id': 'bjchdacjfa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CompanyInfoWhereUniqueInput,
        include: Optional[types.CompanyInfoInclude] = None
    ) -> _PrismaModelT:
        """Find a unique CompanyInfo record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            CompanyInfo filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CompanyInfo model

        Returns
        -------
        prisma.models.CompanyInfo
            The found CompanyInfo record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        companyinfo = await CompanyInfo.prisma().find_unique_or_raise(
            where={
                'id': 'fcadcaihb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CompanyInfoWhereInput] = None,
        cursor: Optional[types.CompanyInfoWhereUniqueInput] = None,
        include: Optional[types.CompanyInfoInclude] = None,
        order: Optional[Union[types.CompanyInfoOrderByInput, List[types.CompanyInfoOrderByInput]]] = None,
        distinct: Optional[List[types.CompanyInfoScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple CompanyInfo records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of CompanyInfo records returned
        skip
            Ignore the first N results
        where
            CompanyInfo filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CompanyInfo model
        order
            Order the returned CompanyInfo records by any field
        distinct
            Filter CompanyInfo records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.CompanyInfo]
            The list of all CompanyInfo records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 CompanyInfo records
        companyinfos = await CompanyInfo.prisma().find_many(take=10)

        # find the first 5 CompanyInfo records ordered by the contactEmail field
        companyinfos = await CompanyInfo.prisma().find_many(
            take=5,
            order={
                'contactEmail': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CompanyInfoWhereInput] = None,
        cursor: Optional[types.CompanyInfoWhereUniqueInput] = None,
        include: Optional[types.CompanyInfoInclude] = None,
        order: Optional[Union[types.CompanyInfoOrderByInput, List[types.CompanyInfoOrderByInput]]] = None,
        distinct: Optional[List[types.CompanyInfoScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single CompanyInfo record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CompanyInfo filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CompanyInfo model
        order
            Order the returned CompanyInfo records by any field
        distinct
            Filter CompanyInfo records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CompanyInfo
            The first CompanyInfo record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CompanyInfo record ordered by the contactPhone field
        companyinfo = await CompanyInfo.prisma().find_first(
            skip=1,
            order={
                'contactPhone': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CompanyInfoWhereInput] = None,
        cursor: Optional[types.CompanyInfoWhereUniqueInput] = None,
        include: Optional[types.CompanyInfoInclude] = None,
        order: Optional[Union[types.CompanyInfoOrderByInput, List[types.CompanyInfoOrderByInput]]] = None,
        distinct: Optional[List[types.CompanyInfoScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single CompanyInfo record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CompanyInfo filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CompanyInfo model
        order
            Order the returned CompanyInfo records by any field
        distinct
            Filter CompanyInfo records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CompanyInfo
            The first CompanyInfo record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CompanyInfo record ordered by the address field
        companyinfo = await CompanyInfo.prisma().find_first_or_raise(
            skip=1,
            order={
                'address': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CompanyInfoUpdateInput,
        where: types.CompanyInfoWhereUniqueInput,
        include: Optional[types.CompanyInfoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single CompanyInfo record.

        Parameters
        ----------
        data
            CompanyInfo record data specifying what to update
        where
            CompanyInfo filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned CompanyInfo model

        Returns
        -------
        prisma.models.CompanyInfo
            The updated CompanyInfo record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        companyinfo = await CompanyInfo.prisma().update(
            where={
                'id': 'bbdcibggga',
            },
            data={
                # data to update the CompanyInfo record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CompanyInfoWhereUniqueInput,
        data: types.CompanyInfoUpsertInput,
        include: Optional[types.CompanyInfoInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            CompanyInfo filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned CompanyInfo model

        Returns
        -------
        prisma.models.CompanyInfo
            The created or updated CompanyInfo record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        companyinfo = await CompanyInfo.prisma().upsert(
            where={
                'id': 'bagbibfheb',
            },
            data={
                'create': {
                    'id': 'bagbibfheb',
                    'companyName': 'bahifjfga',
                },
                'update': {
                    'companyName': 'bahifjfga',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CompanyInfoUpdateManyMutationInput,
        where: types.CompanyInfoWhereInput,
    ) -> int:
        """Update multiple CompanyInfo records

        Parameters
        ----------
        data
            CompanyInfo data to update the selected CompanyInfo records to
        where
            Filter to select the CompanyInfo records to update

        Returns
        -------
        int
            The total number of CompanyInfo records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all CompanyInfo records
        total = await CompanyInfo.prisma().update_many(
            data={
                'zipCode': 'bidgcabjag'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CompanyInfoWhereInput] = None,
        cursor: Optional[types.CompanyInfoWhereUniqueInput] = None,
    ) -> int:
        """Count the number of CompanyInfo records present in the database

        Parameters
        ----------
        select
            Select the CompanyInfo fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CompanyInfo filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CompanyInfoCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await CompanyInfo.prisma().count()

        # results: prisma.types.CompanyInfoCountAggregateOutput
        results = await CompanyInfo.prisma().count(
            select={
                '_all': True,
                'country': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CompanyInfoCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CompanyInfoWhereInput] = None,
        cursor: Optional[types.CompanyInfoWhereUniqueInput] = None,
    ) -> types.CompanyInfoCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CompanyInfoCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CompanyInfoWhereInput] = None,
        cursor: Optional[types.CompanyInfoWhereUniqueInput] = None,
    ) -> Union[int, types.CompanyInfoCountAggregateOutput]:
        """Count the number of CompanyInfo records present in the database

        Parameters
        ----------
        select
            Select the CompanyInfo fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CompanyInfo filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CompanyInfoCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await CompanyInfo.prisma().count()

        # results: prisma.types.CompanyInfoCountAggregateOutput
        results = await CompanyInfo.prisma().count(
            select={
                '_all': True,
                'website': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CompanyInfoCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CompanyInfoWhereInput] = None
    ) -> int:
        """Delete multiple CompanyInfo records.

        Parameters
        ----------
        where
            Optional CompanyInfo filter to find the records to be deleted

        Returns
        -------
        int
            The total number of CompanyInfo records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all CompanyInfo records
        total = await CompanyInfo.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CompanyInfoScalarFieldKeys'],
        *,
        where: Optional['types.CompanyInfoWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CompanyInfoAvgAggregateInput'] = None,
        sum: Optional['types.CompanyInfoSumAggregateInput'] = None,
        min: Optional['types.CompanyInfoMinAggregateInput'] = None,
        max: Optional['types.CompanyInfoMaxAggregateInput'] = None,
        having: Optional['types.CompanyInfoScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CompanyInfoCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CompanyInfoScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CompanyInfoScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CompanyInfoGroupByOutput']:
        """Group CompanyInfo records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar CompanyInfo fields to group records by
        where
            CompanyInfo filter to select records
        take
            Limit the maximum number of CompanyInfo records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CompanyInfoGroupByOutput]
            A list of dictionaries representing the CompanyInfo record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group CompanyInfo records by primaryLogoUrl values
        # and count how many records are in each group
        results = await CompanyInfo.prisma().group_by(
            ['primaryLogoUrl'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AssetScheduleActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AssetSchedule]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AssetSchedule.prisma().query_raw(
            'SELECT * FROM AssetSchedule WHERE id = $1',
            'hechjdjih',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AssetSchedule
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AssetSchedule.prisma().query_first(
            'SELECT * FROM AssetSchedule WHERE assetId = $1',
            'cgfjefhci',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AssetScheduleCreateInput,
        include: Optional[types.AssetScheduleInclude] = None
    ) -> _PrismaModelT:
        """Create a new AssetSchedule record.

        Parameters
        ----------
        data
            AssetSchedule record data
        include
            Specifies which relations should be loaded on the returned AssetSchedule model

        Returns
        -------
        prisma.models.AssetSchedule
            The created AssetSchedule record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AssetSchedule record from just the required fields
        assetschedule = await AssetSchedule.prisma().create(
            data={
                # data to create a AssetSchedule record
                'assetId': 'egcidbiab',
                'scheduleType': 'cehjjfgeg',
                'scheduledDate': datetime.datetime.utcnow(),
                'title': 'hiaaaeeeh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AssetScheduleCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AssetSchedule records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AssetSchedule record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AssetSchedule.prisma().create_many(
            data=[
                {
                    # data to create a AssetSchedule record
                    'assetId': 'ediajdeie',
                    'scheduleType': 'jdgefgafd',
                    'scheduledDate': datetime.datetime.utcnow(),
                    'title': 'bhhihbfeac',
                },
                {
                    # data to create a AssetSchedule record
                    'assetId': 'bajegedfhj',
                    'scheduleType': 'bhfjihjfhg',
                    'scheduledDate': datetime.datetime.utcnow(),
                    'title': 'iicaadeeb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AssetScheduleWhereUniqueInput,
        include: Optional[types.AssetScheduleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AssetSchedule record.

        Parameters
        ----------
        where
            AssetSchedule filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AssetSchedule model

        Returns
        -------
        prisma.models.AssetSchedule
            The deleted AssetSchedule record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetschedule = await AssetSchedule.prisma().delete(
            where={
                'id': 'bigjggdhac',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AssetScheduleWhereUniqueInput,
        include: Optional[types.AssetScheduleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AssetSchedule record.

        Parameters
        ----------
        where
            AssetSchedule filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetSchedule model

        Returns
        -------
        prisma.models.AssetSchedule
            The found AssetSchedule record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetschedule = await AssetSchedule.prisma().find_unique(
            where={
                'id': 'bfdbbbjhad',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AssetScheduleWhereUniqueInput,
        include: Optional[types.AssetScheduleInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AssetSchedule record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AssetSchedule filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AssetSchedule model

        Returns
        -------
        prisma.models.AssetSchedule
            The found AssetSchedule record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetschedule = await AssetSchedule.prisma().find_unique_or_raise(
            where={
                'id': 'bdibjhdici',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetScheduleWhereInput] = None,
        cursor: Optional[types.AssetScheduleWhereUniqueInput] = None,
        include: Optional[types.AssetScheduleInclude] = None,
        order: Optional[Union[types.AssetScheduleOrderByInput, List[types.AssetScheduleOrderByInput]]] = None,
        distinct: Optional[List[types.AssetScheduleScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AssetSchedule records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AssetSchedule records returned
        skip
            Ignore the first N results
        where
            AssetSchedule filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetSchedule model
        order
            Order the returned AssetSchedule records by any field
        distinct
            Filter AssetSchedule records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AssetSchedule]
            The list of all AssetSchedule records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AssetSchedule records
        assetschedules = await AssetSchedule.prisma().find_many(take=10)

        # find the first 5 AssetSchedule records ordered by the scheduleType field
        assetschedules = await AssetSchedule.prisma().find_many(
            take=5,
            order={
                'scheduleType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetScheduleWhereInput] = None,
        cursor: Optional[types.AssetScheduleWhereUniqueInput] = None,
        include: Optional[types.AssetScheduleInclude] = None,
        order: Optional[Union[types.AssetScheduleOrderByInput, List[types.AssetScheduleOrderByInput]]] = None,
        distinct: Optional[List[types.AssetScheduleScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AssetSchedule record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetSchedule filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetSchedule model
        order
            Order the returned AssetSchedule records by any field
        distinct
            Filter AssetSchedule records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetSchedule
            The first AssetSchedule record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetSchedule record ordered by the scheduledDate field
        assetschedule = await AssetSchedule.prisma().find_first(
            skip=1,
            order={
                'scheduledDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssetScheduleWhereInput] = None,
        cursor: Optional[types.AssetScheduleWhereUniqueInput] = None,
        include: Optional[types.AssetScheduleInclude] = None,
        order: Optional[Union[types.AssetScheduleOrderByInput, List[types.AssetScheduleOrderByInput]]] = None,
        distinct: Optional[List[types.AssetScheduleScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AssetSchedule record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AssetSchedule filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AssetSchedule model
        order
            Order the returned AssetSchedule records by any field
        distinct
            Filter AssetSchedule records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AssetSchedule
            The first AssetSchedule record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AssetSchedule record ordered by the scheduledTime field
        assetschedule = await AssetSchedule.prisma().find_first_or_raise(
            skip=1,
            order={
                'scheduledTime': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AssetScheduleUpdateInput,
        where: types.AssetScheduleWhereUniqueInput,
        include: Optional[types.AssetScheduleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AssetSchedule record.

        Parameters
        ----------
        data
            AssetSchedule record data specifying what to update
        where
            AssetSchedule filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AssetSchedule model

        Returns
        -------
        prisma.models.AssetSchedule
            The updated AssetSchedule record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        assetschedule = await AssetSchedule.prisma().update(
            where={
                'id': 'bceigehcbd',
            },
            data={
                # data to update the AssetSchedule record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AssetScheduleWhereUniqueInput,
        data: types.AssetScheduleUpsertInput,
        include: Optional[types.AssetScheduleInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AssetSchedule filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AssetSchedule model

        Returns
        -------
        prisma.models.AssetSchedule
            The created or updated AssetSchedule record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        assetschedule = await AssetSchedule.prisma().upsert(
            where={
                'id': 'caehahihfe',
            },
            data={
                'create': {
                    'id': 'caehahihfe',
                    'assetId': 'bajegedfhj',
                    'scheduleType': 'bhfjihjfhg',
                    'scheduledDate': datetime.datetime.utcnow(),
                    'title': 'iicaadeeb',
                },
                'update': {
                    'assetId': 'bajegedfhj',
                    'scheduleType': 'bhfjihjfhg',
                    'scheduledDate': datetime.datetime.utcnow(),
                    'title': 'iicaadeeb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AssetScheduleUpdateManyMutationInput,
        where: types.AssetScheduleWhereInput,
    ) -> int:
        """Update multiple AssetSchedule records

        Parameters
        ----------
        data
            AssetSchedule data to update the selected AssetSchedule records to
        where
            Filter to select the AssetSchedule records to update

        Returns
        -------
        int
            The total number of AssetSchedule records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AssetSchedule records
        total = await AssetSchedule.prisma().update_many(
            data={
                'title': 'jjacdhech'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetScheduleWhereInput] = None,
        cursor: Optional[types.AssetScheduleWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AssetSchedule records present in the database

        Parameters
        ----------
        select
            Select the AssetSchedule fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetSchedule filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetScheduleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetSchedule.prisma().count()

        # results: prisma.types.AssetScheduleCountAggregateOutput
        results = await AssetSchedule.prisma().count(
            select={
                '_all': True,
                'notes': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AssetScheduleCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetScheduleWhereInput] = None,
        cursor: Optional[types.AssetScheduleWhereUniqueInput] = None,
    ) -> types.AssetScheduleCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AssetScheduleCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssetScheduleWhereInput] = None,
        cursor: Optional[types.AssetScheduleWhereUniqueInput] = None,
    ) -> Union[int, types.AssetScheduleCountAggregateOutput]:
        """Count the number of AssetSchedule records present in the database

        Parameters
        ----------
        select
            Select the AssetSchedule fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AssetSchedule filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssetScheduleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AssetSchedule.prisma().count()

        # results: prisma.types.AssetScheduleCountAggregateOutput
        results = await AssetSchedule.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AssetScheduleCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AssetScheduleWhereInput] = None
    ) -> int:
        """Delete multiple AssetSchedule records.

        Parameters
        ----------
        where
            Optional AssetSchedule filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AssetSchedule records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AssetSchedule records
        total = await AssetSchedule.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AssetScheduleScalarFieldKeys'],
        *,
        where: Optional['types.AssetScheduleWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AssetScheduleAvgAggregateInput'] = None,
        sum: Optional['types.AssetScheduleSumAggregateInput'] = None,
        min: Optional['types.AssetScheduleMinAggregateInput'] = None,
        max: Optional['types.AssetScheduleMaxAggregateInput'] = None,
        having: Optional['types.AssetScheduleScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AssetScheduleCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AssetScheduleScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AssetScheduleScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AssetScheduleGroupByOutput']:
        """Group AssetSchedule records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AssetSchedule fields to group records by
        where
            AssetSchedule filter to select records
        take
            Limit the maximum number of AssetSchedule records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AssetScheduleGroupByOutput]
            A list of dictionaries representing the AssetSchedule record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AssetSchedule records by assignedTo values
        # and count how many records are in each group
        results = await AssetSchedule.prisma().group_by(
            ['assignedTo'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AutomatedReportScheduleActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AutomatedReportSchedule]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AutomatedReportSchedule.prisma().query_raw(
            'SELECT * FROM AutomatedReportSchedule WHERE id = $1',
            'bbbjadabjc',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AutomatedReportSchedule
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AutomatedReportSchedule.prisma().query_first(
            'SELECT * FROM AutomatedReportSchedule WHERE reportName = $1',
            'hhaechedd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AutomatedReportScheduleCreateInput,
        include: Optional[types.AutomatedReportScheduleInclude] = None
    ) -> _PrismaModelT:
        """Create a new AutomatedReportSchedule record.

        Parameters
        ----------
        data
            AutomatedReportSchedule record data
        include
            Specifies which relations should be loaded on the returned AutomatedReportSchedule model

        Returns
        -------
        prisma.models.AutomatedReportSchedule
            The created AutomatedReportSchedule record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AutomatedReportSchedule record from just the required fields
        automatedreportschedule = await AutomatedReportSchedule.prisma().create(
            data={
                # data to create a AutomatedReportSchedule record
                'reportName': 'gjjgegdic',
                'reportType': 'bijbiccd',
                'frequency': 'cbaagdieci',
                'scheduledTime': 'jchifaegj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AutomatedReportScheduleCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AutomatedReportSchedule records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AutomatedReportSchedule record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AutomatedReportSchedule.prisma().create_many(
            data=[
                {
                    # data to create a AutomatedReportSchedule record
                    'reportName': 'dhhdhfebi',
                    'reportType': 'decchddih',
                    'frequency': 'bbegbdehci',
                    'scheduledTime': 'bcebgbhhgb',
                },
                {
                    # data to create a AutomatedReportSchedule record
                    'reportName': 'ghegfaceg',
                    'reportType': 'hdeaejgah',
                    'frequency': 'ddiiihaci',
                    'scheduledTime': 'jdhfacdgf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AutomatedReportScheduleWhereUniqueInput,
        include: Optional[types.AutomatedReportScheduleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AutomatedReportSchedule record.

        Parameters
        ----------
        where
            AutomatedReportSchedule filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AutomatedReportSchedule model

        Returns
        -------
        prisma.models.AutomatedReportSchedule
            The deleted AutomatedReportSchedule record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        automatedreportschedule = await AutomatedReportSchedule.prisma().delete(
            where={
                'id': 'fcbbahcbi',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AutomatedReportScheduleWhereUniqueInput,
        include: Optional[types.AutomatedReportScheduleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AutomatedReportSchedule record.

        Parameters
        ----------
        where
            AutomatedReportSchedule filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AutomatedReportSchedule model

        Returns
        -------
        prisma.models.AutomatedReportSchedule
            The found AutomatedReportSchedule record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        automatedreportschedule = await AutomatedReportSchedule.prisma().find_unique(
            where={
                'id': 'edcgchech',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AutomatedReportScheduleWhereUniqueInput,
        include: Optional[types.AutomatedReportScheduleInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AutomatedReportSchedule record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AutomatedReportSchedule filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AutomatedReportSchedule model

        Returns
        -------
        prisma.models.AutomatedReportSchedule
            The found AutomatedReportSchedule record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        automatedreportschedule = await AutomatedReportSchedule.prisma().find_unique_or_raise(
            where={
                'id': 'bfehccdcge',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AutomatedReportScheduleWhereInput] = None,
        cursor: Optional[types.AutomatedReportScheduleWhereUniqueInput] = None,
        include: Optional[types.AutomatedReportScheduleInclude] = None,
        order: Optional[Union[types.AutomatedReportScheduleOrderByInput, List[types.AutomatedReportScheduleOrderByInput]]] = None,
        distinct: Optional[List[types.AutomatedReportScheduleScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AutomatedReportSchedule records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AutomatedReportSchedule records returned
        skip
            Ignore the first N results
        where
            AutomatedReportSchedule filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AutomatedReportSchedule model
        order
            Order the returned AutomatedReportSchedule records by any field
        distinct
            Filter AutomatedReportSchedule records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AutomatedReportSchedule]
            The list of all AutomatedReportSchedule records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AutomatedReportSchedule records
        automatedreportschedules = await AutomatedReportSchedule.prisma().find_many(take=10)

        # find the first 5 AutomatedReportSchedule records ordered by the reportType field
        automatedreportschedules = await AutomatedReportSchedule.prisma().find_many(
            take=5,
            order={
                'reportType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AutomatedReportScheduleWhereInput] = None,
        cursor: Optional[types.AutomatedReportScheduleWhereUniqueInput] = None,
        include: Optional[types.AutomatedReportScheduleInclude] = None,
        order: Optional[Union[types.AutomatedReportScheduleOrderByInput, List[types.AutomatedReportScheduleOrderByInput]]] = None,
        distinct: Optional[List[types.AutomatedReportScheduleScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AutomatedReportSchedule record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AutomatedReportSchedule filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AutomatedReportSchedule model
        order
            Order the returned AutomatedReportSchedule records by any field
        distinct
            Filter AutomatedReportSchedule records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AutomatedReportSchedule
            The first AutomatedReportSchedule record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AutomatedReportSchedule record ordered by the frequency field
        automatedreportschedule = await AutomatedReportSchedule.prisma().find_first(
            skip=1,
            order={
                'frequency': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AutomatedReportScheduleWhereInput] = None,
        cursor: Optional[types.AutomatedReportScheduleWhereUniqueInput] = None,
        include: Optional[types.AutomatedReportScheduleInclude] = None,
        order: Optional[Union[types.AutomatedReportScheduleOrderByInput, List[types.AutomatedReportScheduleOrderByInput]]] = None,
        distinct: Optional[List[types.AutomatedReportScheduleScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AutomatedReportSchedule record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AutomatedReportSchedule filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AutomatedReportSchedule model
        order
            Order the returned AutomatedReportSchedule records by any field
        distinct
            Filter AutomatedReportSchedule records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AutomatedReportSchedule
            The first AutomatedReportSchedule record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AutomatedReportSchedule record ordered by the frequencyDay field
        automatedreportschedule = await AutomatedReportSchedule.prisma().find_first_or_raise(
            skip=1,
            order={
                'frequencyDay': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AutomatedReportScheduleUpdateInput,
        where: types.AutomatedReportScheduleWhereUniqueInput,
        include: Optional[types.AutomatedReportScheduleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AutomatedReportSchedule record.

        Parameters
        ----------
        data
            AutomatedReportSchedule record data specifying what to update
        where
            AutomatedReportSchedule filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AutomatedReportSchedule model

        Returns
        -------
        prisma.models.AutomatedReportSchedule
            The updated AutomatedReportSchedule record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        automatedreportschedule = await AutomatedReportSchedule.prisma().update(
            where={
                'id': 'ehcibdegf',
            },
            data={
                # data to update the AutomatedReportSchedule record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AutomatedReportScheduleWhereUniqueInput,
        data: types.AutomatedReportScheduleUpsertInput,
        include: Optional[types.AutomatedReportScheduleInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AutomatedReportSchedule filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AutomatedReportSchedule model

        Returns
        -------
        prisma.models.AutomatedReportSchedule
            The created or updated AutomatedReportSchedule record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        automatedreportschedule = await AutomatedReportSchedule.prisma().upsert(
            where={
                'id': 'ebhjifbbi',
            },
            data={
                'create': {
                    'id': 'ebhjifbbi',
                    'reportName': 'ghegfaceg',
                    'reportType': 'hdeaejgah',
                    'frequency': 'ddiiihaci',
                    'scheduledTime': 'jdhfacdgf',
                },
                'update': {
                    'reportName': 'ghegfaceg',
                    'reportType': 'hdeaejgah',
                    'frequency': 'ddiiihaci',
                    'scheduledTime': 'jdhfacdgf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AutomatedReportScheduleUpdateManyMutationInput,
        where: types.AutomatedReportScheduleWhereInput,
    ) -> int:
        """Update multiple AutomatedReportSchedule records

        Parameters
        ----------
        data
            AutomatedReportSchedule data to update the selected AutomatedReportSchedule records to
        where
            Filter to select the AutomatedReportSchedule records to update

        Returns
        -------
        int
            The total number of AutomatedReportSchedule records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AutomatedReportSchedule records
        total = await AutomatedReportSchedule.prisma().update_many(
            data={
                'frequencyMonth': 908658239
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AutomatedReportScheduleWhereInput] = None,
        cursor: Optional[types.AutomatedReportScheduleWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AutomatedReportSchedule records present in the database

        Parameters
        ----------
        select
            Select the AutomatedReportSchedule fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AutomatedReportSchedule filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AutomatedReportScheduleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AutomatedReportSchedule.prisma().count()

        # results: prisma.types.AutomatedReportScheduleCountAggregateOutput
        results = await AutomatedReportSchedule.prisma().count(
            select={
                '_all': True,
                'scheduledTime': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AutomatedReportScheduleCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AutomatedReportScheduleWhereInput] = None,
        cursor: Optional[types.AutomatedReportScheduleWhereUniqueInput] = None,
    ) -> types.AutomatedReportScheduleCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AutomatedReportScheduleCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AutomatedReportScheduleWhereInput] = None,
        cursor: Optional[types.AutomatedReportScheduleWhereUniqueInput] = None,
    ) -> Union[int, types.AutomatedReportScheduleCountAggregateOutput]:
        """Count the number of AutomatedReportSchedule records present in the database

        Parameters
        ----------
        select
            Select the AutomatedReportSchedule fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AutomatedReportSchedule filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AutomatedReportScheduleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AutomatedReportSchedule.prisma().count()

        # results: prisma.types.AutomatedReportScheduleCountAggregateOutput
        results = await AutomatedReportSchedule.prisma().count(
            select={
                '_all': True,
                'emailRecipients': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AutomatedReportScheduleCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AutomatedReportScheduleWhereInput] = None
    ) -> int:
        """Delete multiple AutomatedReportSchedule records.

        Parameters
        ----------
        where
            Optional AutomatedReportSchedule filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AutomatedReportSchedule records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AutomatedReportSchedule records
        total = await AutomatedReportSchedule.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AutomatedReportScheduleScalarFieldKeys'],
        *,
        where: Optional['types.AutomatedReportScheduleWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AutomatedReportScheduleAvgAggregateInput'] = None,
        sum: Optional['types.AutomatedReportScheduleSumAggregateInput'] = None,
        min: Optional['types.AutomatedReportScheduleMinAggregateInput'] = None,
        max: Optional['types.AutomatedReportScheduleMaxAggregateInput'] = None,
        having: Optional['types.AutomatedReportScheduleScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AutomatedReportScheduleCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AutomatedReportScheduleScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AutomatedReportScheduleScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AutomatedReportScheduleGroupByOutput']:
        """Group AutomatedReportSchedule records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AutomatedReportSchedule fields to group records by
        where
            AutomatedReportSchedule filter to select records
        take
            Limit the maximum number of AutomatedReportSchedule records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AutomatedReportScheduleGroupByOutput]
            A list of dictionaries representing the AutomatedReportSchedule record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AutomatedReportSchedule records by filters values
        # and count how many records are in each group
        results = await AutomatedReportSchedule.prisma().group_by(
            ['filters'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models