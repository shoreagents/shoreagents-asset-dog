# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template client.py.jinja --
import warnings
import logging
from datetime import timedelta
from pathlib import Path
from types import TracebackType
from typing_extensions import override

from pydantic import BaseModel

from . import types, models, errors, actions
from ._base_client import BasePrisma, UseClientDefault, USE_CLIENT_DEFAULT
from .types import DatasourceOverride, HttpConfig, MetricsFormat
from ._types import BaseModelT, PrismaMethod, TransactionId, Datasource
from .bases import _PrismaModel
from ._builder import QueryBuilder, dumps
from .generator.models import EngineType, OptionalValueFromEnvVar, BinaryPaths
from ._compat import removeprefix, model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED, DEFAULT_CONNECT_TIMEOUT, DEFAULT_TX_MAX_WAIT, DEFAULT_TX_TIMEOUT
from ._raw_query import deserialize_raw_results
from ._metrics import Metrics
from .metadata import PRISMA_MODELS, RELATIONAL_FIELD_MAPPINGS
from ._transactions import AsyncTransactionManager, SyncTransactionManager

# re-exports
from ._base_client import SyncBasePrisma, AsyncBasePrisma, load_env as load_env
from ._registry import (
    register as register,
    get_client as get_client,
    RegisteredClient as RegisteredClient,
)


__all__ = (
    'ENGINE_TYPE',
    'SCHEMA_PATH',
    'BINARY_PATHS',
    'Batch',
    'Prisma',
    'Client',
    'load_env',
    'register',
    'get_client',
)

log: logging.Logger = logging.getLogger(__name__)

SCHEMA_PATH = Path('C:/Users/Lenovo/Documents/GitHub/shoreagents-asset-dog/backend/prisma_client/schema.prisma')
PACKAGED_SCHEMA_PATH = Path(__file__).parent.joinpath('schema.prisma')
ENGINE_TYPE: EngineType = EngineType.binary
BINARY_PATHS = model_parse(BinaryPaths, {'queryEngine': {'windows': 'C:\\Users\\Lenovo\\.cache\\prisma-python\\binaries\\5.17.0\\393aa359c9ad4a4bb28630fb5613f9c281cde053\\node_modules\\prisma\\query-engine-windows.exe'}, 'introspectionEngine': {}, 'migrationEngine': {}, 'libqueryEngine': {}, 'prismaFmt': {}})


class Prisma(AsyncBasePrisma):
    # Note: these property names can be customised using `/// @Python(instance_name: '...')`
    # https://prisma-client-py.readthedocs.io/en/stable/reference/schema-extensions/#instance_name
    assets: 'actions.AssetsActions[models.Assets]'
    assetsimage: 'actions.AssetsImageActions[models.AssetsImage]'
    assetsdocument: 'actions.AssetsDocumentActions[models.AssetsDocument]'
    category: 'actions.CategoryActions[models.Category]'
    subcategory: 'actions.SubCategoryActions[models.SubCategory]'
    employeeuser: 'actions.EmployeeUserActions[models.EmployeeUser]'
    assetscheckout: 'actions.AssetsCheckoutActions[models.AssetsCheckout]'
    assetscheckin: 'actions.AssetsCheckinActions[models.AssetsCheckin]'
    assetsmove: 'actions.AssetsMoveActions[models.AssetsMove]'
    assetsreserve: 'actions.AssetsReserveActions[models.AssetsReserve]'
    assetslease: 'actions.AssetsLeaseActions[models.AssetsLease]'
    assetsleasereturn: 'actions.AssetsLeaseReturnActions[models.AssetsLeaseReturn]'
    assetsdispose: 'actions.AssetsDisposeActions[models.AssetsDispose]'
    assetsmaintenance: 'actions.AssetsMaintenanceActions[models.AssetsMaintenance]'
    maintenanceinventoryitem: 'actions.MaintenanceInventoryItemActions[models.MaintenanceInventoryItem]'
    assetsaudithistory: 'actions.AssetsAuditHistoryActions[models.AssetsAuditHistory]'
    assetshistorylogs: 'actions.AssetsHistoryLogsActions[models.AssetsHistoryLogs]'
    assetuser: 'actions.AssetUserActions[models.AssetUser]'
    filehistory: 'actions.FileHistoryActions[models.FileHistory]'
    returnform: 'actions.ReturnFormActions[models.ReturnForm]'
    accountabilityform: 'actions.AccountabilityFormActions[models.AccountabilityForm]'
    assetslocation: 'actions.AssetsLocationActions[models.AssetsLocation]'
    assetssite: 'actions.AssetsSiteActions[models.AssetsSite]'
    assetsdepartment: 'actions.AssetsDepartmentActions[models.AssetsDepartment]'
    inventoryitem: 'actions.InventoryItemActions[models.InventoryItem]'
    inventorytransaction: 'actions.InventoryTransactionActions[models.InventoryTransaction]'
    companyinfo: 'actions.CompanyInfoActions[models.CompanyInfo]'
    assetschedule: 'actions.AssetScheduleActions[models.AssetSchedule]'
    automatedreportschedule: 'actions.AutomatedReportScheduleActions[models.AutomatedReportSchedule]'

    __slots__ = (
        'assets',
        'assetsimage',
        'assetsdocument',
        'category',
        'subcategory',
        'employeeuser',
        'assetscheckout',
        'assetscheckin',
        'assetsmove',
        'assetsreserve',
        'assetslease',
        'assetsleasereturn',
        'assetsdispose',
        'assetsmaintenance',
        'maintenanceinventoryitem',
        'assetsaudithistory',
        'assetshistorylogs',
        'assetuser',
        'filehistory',
        'returnform',
        'accountabilityform',
        'assetslocation',
        'assetssite',
        'assetsdepartment',
        'inventoryitem',
        'inventorytransaction',
        'companyinfo',
        'assetschedule',
        'automatedreportschedule',
    )

    def __init__(
        self,
        *,
        use_dotenv: bool = True,
        log_queries: bool = False,
        auto_register: bool = False,
        datasource: DatasourceOverride | None = None,
        connect_timeout: int | timedelta = DEFAULT_CONNECT_TIMEOUT,
        http: HttpConfig | None = None,
    ) -> None:
        super().__init__(
            http=http,
            use_dotenv=use_dotenv,
            log_queries=log_queries,
            datasource=datasource,
            connect_timeout=connect_timeout,
        )
        self._set_generated_properties(
            schema_path=SCHEMA_PATH,
            engine_type=ENGINE_TYPE,
            prisma_models=PRISMA_MODELS,
            packaged_schema_path=PACKAGED_SCHEMA_PATH,
            relational_field_mappings=RELATIONAL_FIELD_MAPPINGS,
            preview_features=set([]),
            active_provider='postgresql',
            default_datasource_name='db',
        )

        self.assets = actions.AssetsActions[models.Assets](self, models.Assets)
        self.assetsimage = actions.AssetsImageActions[models.AssetsImage](self, models.AssetsImage)
        self.assetsdocument = actions.AssetsDocumentActions[models.AssetsDocument](self, models.AssetsDocument)
        self.category = actions.CategoryActions[models.Category](self, models.Category)
        self.subcategory = actions.SubCategoryActions[models.SubCategory](self, models.SubCategory)
        self.employeeuser = actions.EmployeeUserActions[models.EmployeeUser](self, models.EmployeeUser)
        self.assetscheckout = actions.AssetsCheckoutActions[models.AssetsCheckout](self, models.AssetsCheckout)
        self.assetscheckin = actions.AssetsCheckinActions[models.AssetsCheckin](self, models.AssetsCheckin)
        self.assetsmove = actions.AssetsMoveActions[models.AssetsMove](self, models.AssetsMove)
        self.assetsreserve = actions.AssetsReserveActions[models.AssetsReserve](self, models.AssetsReserve)
        self.assetslease = actions.AssetsLeaseActions[models.AssetsLease](self, models.AssetsLease)
        self.assetsleasereturn = actions.AssetsLeaseReturnActions[models.AssetsLeaseReturn](self, models.AssetsLeaseReturn)
        self.assetsdispose = actions.AssetsDisposeActions[models.AssetsDispose](self, models.AssetsDispose)
        self.assetsmaintenance = actions.AssetsMaintenanceActions[models.AssetsMaintenance](self, models.AssetsMaintenance)
        self.maintenanceinventoryitem = actions.MaintenanceInventoryItemActions[models.MaintenanceInventoryItem](self, models.MaintenanceInventoryItem)
        self.assetsaudithistory = actions.AssetsAuditHistoryActions[models.AssetsAuditHistory](self, models.AssetsAuditHistory)
        self.assetshistorylogs = actions.AssetsHistoryLogsActions[models.AssetsHistoryLogs](self, models.AssetsHistoryLogs)
        self.assetuser = actions.AssetUserActions[models.AssetUser](self, models.AssetUser)
        self.filehistory = actions.FileHistoryActions[models.FileHistory](self, models.FileHistory)
        self.returnform = actions.ReturnFormActions[models.ReturnForm](self, models.ReturnForm)
        self.accountabilityform = actions.AccountabilityFormActions[models.AccountabilityForm](self, models.AccountabilityForm)
        self.assetslocation = actions.AssetsLocationActions[models.AssetsLocation](self, models.AssetsLocation)
        self.assetssite = actions.AssetsSiteActions[models.AssetsSite](self, models.AssetsSite)
        self.assetsdepartment = actions.AssetsDepartmentActions[models.AssetsDepartment](self, models.AssetsDepartment)
        self.inventoryitem = actions.InventoryItemActions[models.InventoryItem](self, models.InventoryItem)
        self.inventorytransaction = actions.InventoryTransactionActions[models.InventoryTransaction](self, models.InventoryTransaction)
        self.companyinfo = actions.CompanyInfoActions[models.CompanyInfo](self, models.CompanyInfo)
        self.assetschedule = actions.AssetScheduleActions[models.AssetSchedule](self, models.AssetSchedule)
        self.automatedreportschedule = actions.AutomatedReportScheduleActions[models.AutomatedReportSchedule](self, models.AutomatedReportSchedule)

        if auto_register:
            register(self)

    @property
    @override
    def _default_datasource(self) -> Datasource:
        return {
            'name': 'db',
            'url': OptionalValueFromEnvVar(**{'value': None, 'fromEnvVar': 'DATABASE_URL'}).resolve(),
            'source_file_path': 'C:/Users/Lenovo/Documents/GitHub/shoreagents-asset-dog/backend/prisma_client/schema.prisma',
        }

    async def execute_raw(self, query: LiteralString, *args: Any) -> int:
        resp = await self._execute(
            method='execute_raw',
            arguments={
                'query': query,
                'parameters': args,
            },
            model=None,
        )
        return int(resp['data']['result'])

    @overload
    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> dict[str, Any]:
        ...

    @overload
    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
        model: Type[BaseModelT],
    ) -> Optional[BaseModelT]:
        ...

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
        model: Optional[Type[BaseModelT]] = None,
    ) -> Union[Optional[BaseModelT], dict[str, Any]]:
        """This function is the exact same as `query_raw()` but returns the first result.

        If model is given, the returned record is converted to the pydantic model first,
        otherwise a raw dictionary will be returned.
        """
        results: Sequence[Union[BaseModelT, dict[str, Any]]]
        if model is not None:
            results = await self.query_raw(query, *args, model=model)
        else:
            results = await self.query_raw(query, *args)

        if not results:
            return None

        return results[0]

    @overload
    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[dict[str, Any]]:
        ...

    @overload
    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
        model: Type[BaseModelT],
    ) -> List[BaseModelT]:
        ...

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
        model: Optional[Type[BaseModelT]] = None,
    ) -> Union[List[BaseModelT], List[dict[str, Any]]]:
        """Execute a raw SQL query against the database.

        If model is given, each returned record is converted to the pydantic model first,
        otherwise results will be raw dictionaries.
        """
        resp = await self._execute(
            method='query_raw',
            arguments={
                'query': query,
                'parameters': args,
            },
            model=model,
        )
        result = resp['data']['result']
        if model is not None:
            return deserialize_raw_results(result, model=model)

        return deserialize_raw_results(result)

    def batch_(self) -> Batch:
        """Returns a context manager for grouping write queries into a single transaction."""
        return Batch(client=self)

    def tx(
        self,
        *,
        max_wait: Union[int, timedelta] = DEFAULT_TX_MAX_WAIT,
        timeout: Union[int, timedelta] = DEFAULT_TX_TIMEOUT,
    ) -> TransactionManager:
        """Returns a context manager for executing queries within a database transaction.

        Entering the context manager returns a new Prisma instance wrapping all
        actions within a transaction, queries will be isolated to the Prisma instance and
        will not be commited to the database until the context manager exits.

        By default, Prisma will wait a maximum of 2 seconds to acquire a transaction from the database. You can modify this
        default with the `max_wait` argument which accepts a value in milliseconds or `datetime.timedelta`.

        By default, Prisma will cancel and rollback ay transactions that last longer than 5 seconds. You can modify this timeout
        with the `timeout` argument which accepts a value in milliseconds or `datetime.timedelta`.

        Example usage:

        ```py
        async with client.tx() as transaction:
            user1 = await client.user.create({'name': 'Robert'})
            user2 = await client.user.create({'name': 'Tegan'})
        ```

        In the above example, if the first database call succeeds but the second does not then neither of the records will be created.
        """
        return TransactionManager(
            client=self,
            max_wait=max_wait,
            timeout=timeout,
        )


TransactionManager = AsyncTransactionManager[Prisma]


# TODO: this should return the results as well
# TODO: don't require copy-pasting arguments between actions and batch actions
class Batch:
    assets: 'AssetsBatchActions'
    assetsimage: 'AssetsImageBatchActions'
    assetsdocument: 'AssetsDocumentBatchActions'
    category: 'CategoryBatchActions'
    subcategory: 'SubCategoryBatchActions'
    employeeuser: 'EmployeeUserBatchActions'
    assetscheckout: 'AssetsCheckoutBatchActions'
    assetscheckin: 'AssetsCheckinBatchActions'
    assetsmove: 'AssetsMoveBatchActions'
    assetsreserve: 'AssetsReserveBatchActions'
    assetslease: 'AssetsLeaseBatchActions'
    assetsleasereturn: 'AssetsLeaseReturnBatchActions'
    assetsdispose: 'AssetsDisposeBatchActions'
    assetsmaintenance: 'AssetsMaintenanceBatchActions'
    maintenanceinventoryitem: 'MaintenanceInventoryItemBatchActions'
    assetsaudithistory: 'AssetsAuditHistoryBatchActions'
    assetshistorylogs: 'AssetsHistoryLogsBatchActions'
    assetuser: 'AssetUserBatchActions'
    filehistory: 'FileHistoryBatchActions'
    returnform: 'ReturnFormBatchActions'
    accountabilityform: 'AccountabilityFormBatchActions'
    assetslocation: 'AssetsLocationBatchActions'
    assetssite: 'AssetsSiteBatchActions'
    assetsdepartment: 'AssetsDepartmentBatchActions'
    inventoryitem: 'InventoryItemBatchActions'
    inventorytransaction: 'InventoryTransactionBatchActions'
    companyinfo: 'CompanyInfoBatchActions'
    assetschedule: 'AssetScheduleBatchActions'
    automatedreportschedule: 'AutomatedReportScheduleBatchActions'

    def __init__(self, client: Prisma) -> None:
        self.__client = client
        self.__queries: List[str] = []
        self._active_provider = client._active_provider
        self.assets = AssetsBatchActions(self)
        self.assetsimage = AssetsImageBatchActions(self)
        self.assetsdocument = AssetsDocumentBatchActions(self)
        self.category = CategoryBatchActions(self)
        self.subcategory = SubCategoryBatchActions(self)
        self.employeeuser = EmployeeUserBatchActions(self)
        self.assetscheckout = AssetsCheckoutBatchActions(self)
        self.assetscheckin = AssetsCheckinBatchActions(self)
        self.assetsmove = AssetsMoveBatchActions(self)
        self.assetsreserve = AssetsReserveBatchActions(self)
        self.assetslease = AssetsLeaseBatchActions(self)
        self.assetsleasereturn = AssetsLeaseReturnBatchActions(self)
        self.assetsdispose = AssetsDisposeBatchActions(self)
        self.assetsmaintenance = AssetsMaintenanceBatchActions(self)
        self.maintenanceinventoryitem = MaintenanceInventoryItemBatchActions(self)
        self.assetsaudithistory = AssetsAuditHistoryBatchActions(self)
        self.assetshistorylogs = AssetsHistoryLogsBatchActions(self)
        self.assetuser = AssetUserBatchActions(self)
        self.filehistory = FileHistoryBatchActions(self)
        self.returnform = ReturnFormBatchActions(self)
        self.accountabilityform = AccountabilityFormBatchActions(self)
        self.assetslocation = AssetsLocationBatchActions(self)
        self.assetssite = AssetsSiteBatchActions(self)
        self.assetsdepartment = AssetsDepartmentBatchActions(self)
        self.inventoryitem = InventoryItemBatchActions(self)
        self.inventorytransaction = InventoryTransactionBatchActions(self)
        self.companyinfo = CompanyInfoBatchActions(self)
        self.assetschedule = AssetScheduleBatchActions(self)
        self.automatedreportschedule = AutomatedReportScheduleBatchActions(self)

    def _add(self, **kwargs: Any) -> None:
        builder = QueryBuilder(
            **kwargs,
            prisma_models=PRISMA_MODELS,
            relational_field_mappings=RELATIONAL_FIELD_MAPPINGS,
        )
        self.__queries.append(builder.build_query())

    async def commit(self) -> None:
        """Execute the queries"""
        # TODO: normalise this, we should still call client._execute
        queries = self.__queries
        self.__queries = []

        payload = {
            'batch': [
                {
                    'query': query,
                    'variables': {},
                }
                for query in queries
            ],
            'transaction': True,
        }
        await self.__client._engine.query(
            dumps(payload),
            tx_id=self.__client._tx_id,
        )

    def execute_raw(self, query: LiteralString, *args: Any) -> None:
        self._add(
            method='execute_raw',
            arguments={
                'query': query,
                'parameters': args,
            }
        )

    async def __aenter__(self) -> 'Batch':
        return self

    async def __aexit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc: Optional[BaseException],
        exc_tb: Optional[TracebackType],
    ) -> None:
        if exc is None:
            await self.commit()


# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class AssetsBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.AssetsCreateInput,
        include: Optional[types.AssetsInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.Assets,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.AssetsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.Assets,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.AssetsWhereUniqueInput,
        include: Optional[types.AssetsInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.Assets,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.AssetsUpdateInput,
        where: types.AssetsWhereUniqueInput,
        include: Optional[types.AssetsInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.Assets,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.AssetsWhereUniqueInput,
        data: types.AssetsUpsertInput,
        include: Optional[types.AssetsInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.Assets,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.AssetsUpdateManyMutationInput,
        where: types.AssetsWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.Assets,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.AssetsWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.Assets,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class AssetsImageBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.AssetsImageCreateInput,
        include: Optional[types.AssetsImageInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.AssetsImage,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.AssetsImageCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.AssetsImage,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.AssetsImageWhereUniqueInput,
        include: Optional[types.AssetsImageInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.AssetsImage,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.AssetsImageUpdateInput,
        where: types.AssetsImageWhereUniqueInput,
        include: Optional[types.AssetsImageInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.AssetsImage,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.AssetsImageWhereUniqueInput,
        data: types.AssetsImageUpsertInput,
        include: Optional[types.AssetsImageInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.AssetsImage,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.AssetsImageUpdateManyMutationInput,
        where: types.AssetsImageWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.AssetsImage,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.AssetsImageWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.AssetsImage,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class AssetsDocumentBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.AssetsDocumentCreateInput,
        include: Optional[types.AssetsDocumentInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.AssetsDocument,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.AssetsDocumentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.AssetsDocument,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.AssetsDocumentWhereUniqueInput,
        include: Optional[types.AssetsDocumentInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.AssetsDocument,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.AssetsDocumentUpdateInput,
        where: types.AssetsDocumentWhereUniqueInput,
        include: Optional[types.AssetsDocumentInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.AssetsDocument,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.AssetsDocumentWhereUniqueInput,
        data: types.AssetsDocumentUpsertInput,
        include: Optional[types.AssetsDocumentInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.AssetsDocument,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.AssetsDocumentUpdateManyMutationInput,
        where: types.AssetsDocumentWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.AssetsDocument,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.AssetsDocumentWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.AssetsDocument,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class CategoryBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.CategoryCreateInput,
        include: Optional[types.CategoryInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.Category,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.CategoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.Category,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.CategoryWhereUniqueInput,
        include: Optional[types.CategoryInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.Category,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.CategoryUpdateInput,
        where: types.CategoryWhereUniqueInput,
        include: Optional[types.CategoryInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.Category,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.CategoryWhereUniqueInput,
        data: types.CategoryUpsertInput,
        include: Optional[types.CategoryInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.Category,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.CategoryUpdateManyMutationInput,
        where: types.CategoryWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.Category,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.CategoryWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.Category,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class SubCategoryBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.SubCategoryCreateInput,
        include: Optional[types.SubCategoryInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.SubCategory,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.SubCategoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.SubCategory,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.SubCategoryWhereUniqueInput,
        include: Optional[types.SubCategoryInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.SubCategory,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.SubCategoryUpdateInput,
        where: types.SubCategoryWhereUniqueInput,
        include: Optional[types.SubCategoryInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.SubCategory,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.SubCategoryWhereUniqueInput,
        data: types.SubCategoryUpsertInput,
        include: Optional[types.SubCategoryInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.SubCategory,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.SubCategoryUpdateManyMutationInput,
        where: types.SubCategoryWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.SubCategory,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.SubCategoryWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.SubCategory,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class EmployeeUserBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.EmployeeUserCreateInput,
        include: Optional[types.EmployeeUserInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.EmployeeUser,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.EmployeeUserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.EmployeeUser,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.EmployeeUserWhereUniqueInput,
        include: Optional[types.EmployeeUserInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.EmployeeUser,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.EmployeeUserUpdateInput,
        where: types.EmployeeUserWhereUniqueInput,
        include: Optional[types.EmployeeUserInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.EmployeeUser,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.EmployeeUserWhereUniqueInput,
        data: types.EmployeeUserUpsertInput,
        include: Optional[types.EmployeeUserInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.EmployeeUser,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.EmployeeUserUpdateManyMutationInput,
        where: types.EmployeeUserWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.EmployeeUser,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.EmployeeUserWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.EmployeeUser,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class AssetsCheckoutBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.AssetsCheckoutCreateInput,
        include: Optional[types.AssetsCheckoutInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.AssetsCheckout,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.AssetsCheckoutCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.AssetsCheckout,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.AssetsCheckoutWhereUniqueInput,
        include: Optional[types.AssetsCheckoutInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.AssetsCheckout,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.AssetsCheckoutUpdateInput,
        where: types.AssetsCheckoutWhereUniqueInput,
        include: Optional[types.AssetsCheckoutInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.AssetsCheckout,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.AssetsCheckoutWhereUniqueInput,
        data: types.AssetsCheckoutUpsertInput,
        include: Optional[types.AssetsCheckoutInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.AssetsCheckout,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.AssetsCheckoutUpdateManyMutationInput,
        where: types.AssetsCheckoutWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.AssetsCheckout,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.AssetsCheckoutWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.AssetsCheckout,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class AssetsCheckinBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.AssetsCheckinCreateInput,
        include: Optional[types.AssetsCheckinInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.AssetsCheckin,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.AssetsCheckinCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.AssetsCheckin,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.AssetsCheckinWhereUniqueInput,
        include: Optional[types.AssetsCheckinInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.AssetsCheckin,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.AssetsCheckinUpdateInput,
        where: types.AssetsCheckinWhereUniqueInput,
        include: Optional[types.AssetsCheckinInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.AssetsCheckin,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.AssetsCheckinWhereUniqueInput,
        data: types.AssetsCheckinUpsertInput,
        include: Optional[types.AssetsCheckinInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.AssetsCheckin,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.AssetsCheckinUpdateManyMutationInput,
        where: types.AssetsCheckinWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.AssetsCheckin,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.AssetsCheckinWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.AssetsCheckin,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class AssetsMoveBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.AssetsMoveCreateInput,
        include: Optional[types.AssetsMoveInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.AssetsMove,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.AssetsMoveCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.AssetsMove,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.AssetsMoveWhereUniqueInput,
        include: Optional[types.AssetsMoveInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.AssetsMove,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.AssetsMoveUpdateInput,
        where: types.AssetsMoveWhereUniqueInput,
        include: Optional[types.AssetsMoveInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.AssetsMove,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.AssetsMoveWhereUniqueInput,
        data: types.AssetsMoveUpsertInput,
        include: Optional[types.AssetsMoveInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.AssetsMove,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.AssetsMoveUpdateManyMutationInput,
        where: types.AssetsMoveWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.AssetsMove,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.AssetsMoveWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.AssetsMove,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class AssetsReserveBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.AssetsReserveCreateInput,
        include: Optional[types.AssetsReserveInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.AssetsReserve,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.AssetsReserveCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.AssetsReserve,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.AssetsReserveWhereUniqueInput,
        include: Optional[types.AssetsReserveInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.AssetsReserve,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.AssetsReserveUpdateInput,
        where: types.AssetsReserveWhereUniqueInput,
        include: Optional[types.AssetsReserveInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.AssetsReserve,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.AssetsReserveWhereUniqueInput,
        data: types.AssetsReserveUpsertInput,
        include: Optional[types.AssetsReserveInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.AssetsReserve,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.AssetsReserveUpdateManyMutationInput,
        where: types.AssetsReserveWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.AssetsReserve,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.AssetsReserveWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.AssetsReserve,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class AssetsLeaseBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.AssetsLeaseCreateInput,
        include: Optional[types.AssetsLeaseInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.AssetsLease,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.AssetsLeaseCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.AssetsLease,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.AssetsLeaseWhereUniqueInput,
        include: Optional[types.AssetsLeaseInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.AssetsLease,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.AssetsLeaseUpdateInput,
        where: types.AssetsLeaseWhereUniqueInput,
        include: Optional[types.AssetsLeaseInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.AssetsLease,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.AssetsLeaseWhereUniqueInput,
        data: types.AssetsLeaseUpsertInput,
        include: Optional[types.AssetsLeaseInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.AssetsLease,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.AssetsLeaseUpdateManyMutationInput,
        where: types.AssetsLeaseWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.AssetsLease,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.AssetsLeaseWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.AssetsLease,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class AssetsLeaseReturnBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.AssetsLeaseReturnCreateInput,
        include: Optional[types.AssetsLeaseReturnInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.AssetsLeaseReturn,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.AssetsLeaseReturnCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.AssetsLeaseReturn,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.AssetsLeaseReturnWhereUniqueInput,
        include: Optional[types.AssetsLeaseReturnInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.AssetsLeaseReturn,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.AssetsLeaseReturnUpdateInput,
        where: types.AssetsLeaseReturnWhereUniqueInput,
        include: Optional[types.AssetsLeaseReturnInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.AssetsLeaseReturn,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.AssetsLeaseReturnWhereUniqueInput,
        data: types.AssetsLeaseReturnUpsertInput,
        include: Optional[types.AssetsLeaseReturnInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.AssetsLeaseReturn,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.AssetsLeaseReturnUpdateManyMutationInput,
        where: types.AssetsLeaseReturnWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.AssetsLeaseReturn,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.AssetsLeaseReturnWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.AssetsLeaseReturn,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class AssetsDisposeBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.AssetsDisposeCreateInput,
        include: Optional[types.AssetsDisposeInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.AssetsDispose,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.AssetsDisposeCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.AssetsDispose,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.AssetsDisposeWhereUniqueInput,
        include: Optional[types.AssetsDisposeInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.AssetsDispose,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.AssetsDisposeUpdateInput,
        where: types.AssetsDisposeWhereUniqueInput,
        include: Optional[types.AssetsDisposeInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.AssetsDispose,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.AssetsDisposeWhereUniqueInput,
        data: types.AssetsDisposeUpsertInput,
        include: Optional[types.AssetsDisposeInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.AssetsDispose,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.AssetsDisposeUpdateManyMutationInput,
        where: types.AssetsDisposeWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.AssetsDispose,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.AssetsDisposeWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.AssetsDispose,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class AssetsMaintenanceBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.AssetsMaintenanceCreateInput,
        include: Optional[types.AssetsMaintenanceInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.AssetsMaintenance,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.AssetsMaintenanceCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.AssetsMaintenance,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.AssetsMaintenanceWhereUniqueInput,
        include: Optional[types.AssetsMaintenanceInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.AssetsMaintenance,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.AssetsMaintenanceUpdateInput,
        where: types.AssetsMaintenanceWhereUniqueInput,
        include: Optional[types.AssetsMaintenanceInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.AssetsMaintenance,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.AssetsMaintenanceWhereUniqueInput,
        data: types.AssetsMaintenanceUpsertInput,
        include: Optional[types.AssetsMaintenanceInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.AssetsMaintenance,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.AssetsMaintenanceUpdateManyMutationInput,
        where: types.AssetsMaintenanceWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.AssetsMaintenance,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.AssetsMaintenanceWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.AssetsMaintenance,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class MaintenanceInventoryItemBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.MaintenanceInventoryItemCreateInput,
        include: Optional[types.MaintenanceInventoryItemInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.MaintenanceInventoryItem,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.MaintenanceInventoryItemCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.MaintenanceInventoryItem,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.MaintenanceInventoryItemWhereUniqueInput,
        include: Optional[types.MaintenanceInventoryItemInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.MaintenanceInventoryItem,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.MaintenanceInventoryItemUpdateInput,
        where: types.MaintenanceInventoryItemWhereUniqueInput,
        include: Optional[types.MaintenanceInventoryItemInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.MaintenanceInventoryItem,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.MaintenanceInventoryItemWhereUniqueInput,
        data: types.MaintenanceInventoryItemUpsertInput,
        include: Optional[types.MaintenanceInventoryItemInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.MaintenanceInventoryItem,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.MaintenanceInventoryItemUpdateManyMutationInput,
        where: types.MaintenanceInventoryItemWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.MaintenanceInventoryItem,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.MaintenanceInventoryItemWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.MaintenanceInventoryItem,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class AssetsAuditHistoryBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.AssetsAuditHistoryCreateInput,
        include: Optional[types.AssetsAuditHistoryInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.AssetsAuditHistory,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.AssetsAuditHistoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.AssetsAuditHistory,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.AssetsAuditHistoryWhereUniqueInput,
        include: Optional[types.AssetsAuditHistoryInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.AssetsAuditHistory,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.AssetsAuditHistoryUpdateInput,
        where: types.AssetsAuditHistoryWhereUniqueInput,
        include: Optional[types.AssetsAuditHistoryInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.AssetsAuditHistory,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.AssetsAuditHistoryWhereUniqueInput,
        data: types.AssetsAuditHistoryUpsertInput,
        include: Optional[types.AssetsAuditHistoryInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.AssetsAuditHistory,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.AssetsAuditHistoryUpdateManyMutationInput,
        where: types.AssetsAuditHistoryWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.AssetsAuditHistory,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.AssetsAuditHistoryWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.AssetsAuditHistory,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class AssetsHistoryLogsBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.AssetsHistoryLogsCreateInput,
        include: Optional[types.AssetsHistoryLogsInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.AssetsHistoryLogs,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.AssetsHistoryLogsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.AssetsHistoryLogs,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.AssetsHistoryLogsWhereUniqueInput,
        include: Optional[types.AssetsHistoryLogsInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.AssetsHistoryLogs,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.AssetsHistoryLogsUpdateInput,
        where: types.AssetsHistoryLogsWhereUniqueInput,
        include: Optional[types.AssetsHistoryLogsInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.AssetsHistoryLogs,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.AssetsHistoryLogsWhereUniqueInput,
        data: types.AssetsHistoryLogsUpsertInput,
        include: Optional[types.AssetsHistoryLogsInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.AssetsHistoryLogs,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.AssetsHistoryLogsUpdateManyMutationInput,
        where: types.AssetsHistoryLogsWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.AssetsHistoryLogs,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.AssetsHistoryLogsWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.AssetsHistoryLogs,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class AssetUserBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.AssetUserCreateInput,
        include: Optional[types.AssetUserInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.AssetUser,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.AssetUserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.AssetUser,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.AssetUserWhereUniqueInput,
        include: Optional[types.AssetUserInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.AssetUser,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.AssetUserUpdateInput,
        where: types.AssetUserWhereUniqueInput,
        include: Optional[types.AssetUserInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.AssetUser,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.AssetUserWhereUniqueInput,
        data: types.AssetUserUpsertInput,
        include: Optional[types.AssetUserInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.AssetUser,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.AssetUserUpdateManyMutationInput,
        where: types.AssetUserWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.AssetUser,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.AssetUserWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.AssetUser,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class FileHistoryBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.FileHistoryCreateInput,
        include: Optional[types.FileHistoryInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.FileHistory,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.FileHistoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.FileHistory,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.FileHistoryWhereUniqueInput,
        include: Optional[types.FileHistoryInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.FileHistory,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.FileHistoryUpdateInput,
        where: types.FileHistoryWhereUniqueInput,
        include: Optional[types.FileHistoryInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.FileHistory,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.FileHistoryWhereUniqueInput,
        data: types.FileHistoryUpsertInput,
        include: Optional[types.FileHistoryInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.FileHistory,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.FileHistoryUpdateManyMutationInput,
        where: types.FileHistoryWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.FileHistory,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.FileHistoryWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.FileHistory,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class ReturnFormBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.ReturnFormCreateInput,
        include: Optional[types.ReturnFormInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.ReturnForm,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.ReturnFormCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.ReturnForm,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.ReturnFormWhereUniqueInput,
        include: Optional[types.ReturnFormInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.ReturnForm,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.ReturnFormUpdateInput,
        where: types.ReturnFormWhereUniqueInput,
        include: Optional[types.ReturnFormInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.ReturnForm,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.ReturnFormWhereUniqueInput,
        data: types.ReturnFormUpsertInput,
        include: Optional[types.ReturnFormInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.ReturnForm,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.ReturnFormUpdateManyMutationInput,
        where: types.ReturnFormWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.ReturnForm,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.ReturnFormWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.ReturnForm,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class AccountabilityFormBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.AccountabilityFormCreateInput,
        include: Optional[types.AccountabilityFormInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.AccountabilityForm,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.AccountabilityFormCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.AccountabilityForm,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.AccountabilityFormWhereUniqueInput,
        include: Optional[types.AccountabilityFormInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.AccountabilityForm,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.AccountabilityFormUpdateInput,
        where: types.AccountabilityFormWhereUniqueInput,
        include: Optional[types.AccountabilityFormInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.AccountabilityForm,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.AccountabilityFormWhereUniqueInput,
        data: types.AccountabilityFormUpsertInput,
        include: Optional[types.AccountabilityFormInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.AccountabilityForm,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.AccountabilityFormUpdateManyMutationInput,
        where: types.AccountabilityFormWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.AccountabilityForm,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.AccountabilityFormWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.AccountabilityForm,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class AssetsLocationBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.AssetsLocationCreateInput,
        include: Optional[types.AssetsLocationInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.AssetsLocation,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.AssetsLocationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.AssetsLocation,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.AssetsLocationWhereUniqueInput,
        include: Optional[types.AssetsLocationInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.AssetsLocation,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.AssetsLocationUpdateInput,
        where: types.AssetsLocationWhereUniqueInput,
        include: Optional[types.AssetsLocationInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.AssetsLocation,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.AssetsLocationWhereUniqueInput,
        data: types.AssetsLocationUpsertInput,
        include: Optional[types.AssetsLocationInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.AssetsLocation,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.AssetsLocationUpdateManyMutationInput,
        where: types.AssetsLocationWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.AssetsLocation,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.AssetsLocationWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.AssetsLocation,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class AssetsSiteBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.AssetsSiteCreateInput,
        include: Optional[types.AssetsSiteInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.AssetsSite,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.AssetsSiteCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.AssetsSite,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.AssetsSiteWhereUniqueInput,
        include: Optional[types.AssetsSiteInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.AssetsSite,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.AssetsSiteUpdateInput,
        where: types.AssetsSiteWhereUniqueInput,
        include: Optional[types.AssetsSiteInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.AssetsSite,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.AssetsSiteWhereUniqueInput,
        data: types.AssetsSiteUpsertInput,
        include: Optional[types.AssetsSiteInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.AssetsSite,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.AssetsSiteUpdateManyMutationInput,
        where: types.AssetsSiteWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.AssetsSite,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.AssetsSiteWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.AssetsSite,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class AssetsDepartmentBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.AssetsDepartmentCreateInput,
        include: Optional[types.AssetsDepartmentInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.AssetsDepartment,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.AssetsDepartmentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.AssetsDepartment,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.AssetsDepartmentWhereUniqueInput,
        include: Optional[types.AssetsDepartmentInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.AssetsDepartment,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.AssetsDepartmentUpdateInput,
        where: types.AssetsDepartmentWhereUniqueInput,
        include: Optional[types.AssetsDepartmentInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.AssetsDepartment,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.AssetsDepartmentWhereUniqueInput,
        data: types.AssetsDepartmentUpsertInput,
        include: Optional[types.AssetsDepartmentInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.AssetsDepartment,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.AssetsDepartmentUpdateManyMutationInput,
        where: types.AssetsDepartmentWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.AssetsDepartment,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.AssetsDepartmentWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.AssetsDepartment,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class InventoryItemBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.InventoryItemCreateInput,
        include: Optional[types.InventoryItemInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.InventoryItem,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.InventoryItemCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.InventoryItem,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.InventoryItemWhereUniqueInput,
        include: Optional[types.InventoryItemInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.InventoryItem,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.InventoryItemUpdateInput,
        where: types.InventoryItemWhereUniqueInput,
        include: Optional[types.InventoryItemInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.InventoryItem,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.InventoryItemWhereUniqueInput,
        data: types.InventoryItemUpsertInput,
        include: Optional[types.InventoryItemInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.InventoryItem,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.InventoryItemUpdateManyMutationInput,
        where: types.InventoryItemWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.InventoryItem,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.InventoryItemWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.InventoryItem,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class InventoryTransactionBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.InventoryTransactionCreateInput,
        include: Optional[types.InventoryTransactionInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.InventoryTransaction,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.InventoryTransactionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.InventoryTransaction,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.InventoryTransactionWhereUniqueInput,
        include: Optional[types.InventoryTransactionInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.InventoryTransaction,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.InventoryTransactionUpdateInput,
        where: types.InventoryTransactionWhereUniqueInput,
        include: Optional[types.InventoryTransactionInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.InventoryTransaction,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.InventoryTransactionWhereUniqueInput,
        data: types.InventoryTransactionUpsertInput,
        include: Optional[types.InventoryTransactionInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.InventoryTransaction,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.InventoryTransactionUpdateManyMutationInput,
        where: types.InventoryTransactionWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.InventoryTransaction,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.InventoryTransactionWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.InventoryTransaction,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class CompanyInfoBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.CompanyInfoCreateInput,
        include: Optional[types.CompanyInfoInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.CompanyInfo,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.CompanyInfoCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.CompanyInfo,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.CompanyInfoWhereUniqueInput,
        include: Optional[types.CompanyInfoInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.CompanyInfo,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.CompanyInfoUpdateInput,
        where: types.CompanyInfoWhereUniqueInput,
        include: Optional[types.CompanyInfoInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.CompanyInfo,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.CompanyInfoWhereUniqueInput,
        data: types.CompanyInfoUpsertInput,
        include: Optional[types.CompanyInfoInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.CompanyInfo,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.CompanyInfoUpdateManyMutationInput,
        where: types.CompanyInfoWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.CompanyInfo,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.CompanyInfoWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.CompanyInfo,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class AssetScheduleBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.AssetScheduleCreateInput,
        include: Optional[types.AssetScheduleInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.AssetSchedule,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.AssetScheduleCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.AssetSchedule,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.AssetScheduleWhereUniqueInput,
        include: Optional[types.AssetScheduleInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.AssetSchedule,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.AssetScheduleUpdateInput,
        where: types.AssetScheduleWhereUniqueInput,
        include: Optional[types.AssetScheduleInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.AssetSchedule,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.AssetScheduleWhereUniqueInput,
        data: types.AssetScheduleUpsertInput,
        include: Optional[types.AssetScheduleInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.AssetSchedule,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.AssetScheduleUpdateManyMutationInput,
        where: types.AssetScheduleWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.AssetSchedule,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.AssetScheduleWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.AssetSchedule,
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class AutomatedReportScheduleBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.AutomatedReportScheduleCreateInput,
        include: Optional[types.AutomatedReportScheduleInclude] = None
    ) -> None:
        self._batcher._add(
            method='create',
            model=models.AutomatedReportSchedule,
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.AutomatedReportScheduleCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if skip_duplicates and self._batcher._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._batcher._active_provider, 'create_many_skip_duplicates')

        self._batcher._add(
            method='create_many',
            model=models.AutomatedReportSchedule,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.AutomatedReportScheduleWhereUniqueInput,
        include: Optional[types.AutomatedReportScheduleInclude] = None,
    ) -> None:
        self._batcher._add(
            method='delete',
            model=models.AutomatedReportSchedule,
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.AutomatedReportScheduleUpdateInput,
        where: types.AutomatedReportScheduleWhereUniqueInput,
        include: Optional[types.AutomatedReportScheduleInclude] = None
    ) -> None:
        self._batcher._add(
            method='update',
            model=models.AutomatedReportSchedule,
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.AutomatedReportScheduleWhereUniqueInput,
        data: types.AutomatedReportScheduleUpsertInput,
        include: Optional[types.AutomatedReportScheduleInclude] = None,
    ) -> None:
        self._batcher._add(
            method='upsert',
            model=models.AutomatedReportSchedule,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.AutomatedReportScheduleUpdateManyMutationInput,
        where: types.AutomatedReportScheduleWhereInput,
    ) -> None:
        self._batcher._add(
            method='update_many',
            model=models.AutomatedReportSchedule,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.AutomatedReportScheduleWhereInput] = None,
    ) -> None:
        self._batcher._add(
            method='delete_many',
            model=models.AutomatedReportSchedule,
            arguments={'where': where},
            root_selection=['count'],
        )



Client = Prisma