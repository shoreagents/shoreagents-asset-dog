# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from ._builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class Assets(bases.BaseAssets):
    """Represents a Assets record"""

    id: _str
    assetTagId: _str
    description: _str
    purchasedFrom: Optional[_str] = None
    purchaseDate: Optional[datetime.datetime] = None
    brand: Optional[_str] = None
    cost: Optional[decimal.Decimal] = None
    model: Optional[_str] = None
    serialNo: Optional[_str] = None
    additionalInformation: Optional[_str] = None
    xeroAssetNo: Optional[_str] = None
    owner: Optional[_str] = None
    pbiNumber: Optional[_str] = None
    status: Optional[_str] = None
    issuedTo: Optional[_str] = None
    poNumber: Optional[_str] = None
    paymentVoucherNumber: Optional[_str] = None
    assetType: Optional[_str] = None
    deliveryDate: Optional[datetime.datetime] = None
    unaccountedInventory: Optional[_bool] = None
    remarks: Optional[_str] = None
    qr: Optional[_str] = None
    oldAssetTag: Optional[_str] = None
    depreciableAsset: Optional[_bool] = None
    depreciableCost: Optional[decimal.Decimal] = None
    salvageValue: Optional[decimal.Decimal] = None
    assetLifeMonths: Optional[_int] = None
    depreciationMethod: Optional[_str] = None
    dateAcquired: Optional[datetime.datetime] = None
    categoryId: Optional[_str] = None
    category: Optional['models.Category'] = None
    subCategoryId: Optional[_str] = None
    subCategory: Optional['models.SubCategory'] = None
    department: Optional[_str] = None
    site: Optional[_str] = None
    location: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    isDeleted: _bool
    checkouts: Optional[List['models.AssetsCheckout']] = None
    checkins: Optional[List['models.AssetsCheckin']] = None
    moves: Optional[List['models.AssetsMove']] = None
    reservations: Optional[List['models.AssetsReserve']] = None
    leases: Optional[List['models.AssetsLease']] = None
    leaseReturns: Optional[List['models.AssetsLeaseReturn']] = None
    disposals: Optional[List['models.AssetsDispose']] = None
    maintenances: Optional[List['models.AssetsMaintenance']] = None
    auditHistory: Optional[List['models.AssetsAuditHistory']] = None
    historyLogs: Optional[List['models.AssetsHistoryLogs']] = None
    schedules: Optional[List['models.AssetSchedule']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AssetsKeys']] = None,
        exclude: Optional[Iterable['types.AssetsKeys']] = None,
        required: Optional[Iterable['types.AssetsKeys']] = None,
        optional: Optional[Iterable['types.AssetsKeys']] = None,
        relations: Optional[Mapping['types.AssetsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AssetsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Assets_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Assets_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Assets_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Assets_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Assets_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Assets_relational_fields:
                        raise errors.UnknownRelationalFieldError('Assets', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Assets / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Assets',
            }
        )
        _created_partial_types.add(name)


class AssetsImage(bases.BaseAssetsImage):
    """Represents a AssetsImage record"""

    id: _str
    assetTagId: _str
    imageUrl: _str
    imageType: Optional[_str] = None
    imageSize: Optional[_int] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AssetsImageKeys']] = None,
        exclude: Optional[Iterable['types.AssetsImageKeys']] = None,
        required: Optional[Iterable['types.AssetsImageKeys']] = None,
        optional: Optional[Iterable['types.AssetsImageKeys']] = None,
        relations: Optional[Mapping['types.AssetsImageRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AssetsImageKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AssetsImage_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AssetsImage_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AssetsImage_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AssetsImage_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "AssetsImage" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AssetsImage / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AssetsImage',
            }
        )
        _created_partial_types.add(name)


class AssetsDocument(bases.BaseAssetsDocument):
    """Represents a AssetsDocument record"""

    id: _str
    assetTagId: _str
    documentUrl: _str
    documentType: Optional[_str] = None
    documentSize: Optional[_int] = None
    fileName: Optional[_str] = None
    mimeType: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AssetsDocumentKeys']] = None,
        exclude: Optional[Iterable['types.AssetsDocumentKeys']] = None,
        required: Optional[Iterable['types.AssetsDocumentKeys']] = None,
        optional: Optional[Iterable['types.AssetsDocumentKeys']] = None,
        relations: Optional[Mapping['types.AssetsDocumentRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AssetsDocumentKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AssetsDocument_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AssetsDocument_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AssetsDocument_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AssetsDocument_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "AssetsDocument" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AssetsDocument / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AssetsDocument',
            }
        )
        _created_partial_types.add(name)


class Category(bases.BaseCategory):
    """Represents a Category record"""

    id: _str
    name: _str
    description: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    subCategories: Optional[List['models.SubCategory']] = None
    assets: Optional[List['models.Assets']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.CategoryKeys']] = None,
        exclude: Optional[Iterable['types.CategoryKeys']] = None,
        required: Optional[Iterable['types.CategoryKeys']] = None,
        optional: Optional[Iterable['types.CategoryKeys']] = None,
        relations: Optional[Mapping['types.CategoryRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.CategoryKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Category_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Category_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Category_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Category_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Category_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Category_relational_fields:
                        raise errors.UnknownRelationalFieldError('Category', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Category / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Category',
            }
        )
        _created_partial_types.add(name)


class SubCategory(bases.BaseSubCategory):
    """Represents a SubCategory record"""

    id: _str
    name: _str
    description: Optional[_str] = None
    categoryId: _str
    category: Optional['models.Category'] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    assets: Optional[List['models.Assets']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.SubCategoryKeys']] = None,
        exclude: Optional[Iterable['types.SubCategoryKeys']] = None,
        required: Optional[Iterable['types.SubCategoryKeys']] = None,
        optional: Optional[Iterable['types.SubCategoryKeys']] = None,
        relations: Optional[Mapping['types.SubCategoryRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.SubCategoryKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _SubCategory_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _SubCategory_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _SubCategory_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _SubCategory_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _SubCategory_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _SubCategory_relational_fields:
                        raise errors.UnknownRelationalFieldError('SubCategory', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid SubCategory / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'SubCategory',
            }
        )
        _created_partial_types.add(name)


class EmployeeUser(bases.BaseEmployeeUser):
    """Represents a EmployeeUser record"""

    id: _str
    name: _str
    email: _str
    department: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    checkouts: Optional[List['models.AssetsCheckout']] = None
    checkins: Optional[List['models.AssetsCheckin']] = None
    moves: Optional[List['models.AssetsMove']] = None
    reservations: Optional[List['models.AssetsReserve']] = None
    returnForms: Optional[List['models.ReturnForm']] = None
    accountabilityForms: Optional[List['models.AccountabilityForm']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.EmployeeUserKeys']] = None,
        exclude: Optional[Iterable['types.EmployeeUserKeys']] = None,
        required: Optional[Iterable['types.EmployeeUserKeys']] = None,
        optional: Optional[Iterable['types.EmployeeUserKeys']] = None,
        relations: Optional[Mapping['types.EmployeeUserRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.EmployeeUserKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _EmployeeUser_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _EmployeeUser_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _EmployeeUser_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _EmployeeUser_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _EmployeeUser_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _EmployeeUser_relational_fields:
                        raise errors.UnknownRelationalFieldError('EmployeeUser', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid EmployeeUser / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'EmployeeUser',
            }
        )
        _created_partial_types.add(name)


class AssetsCheckout(bases.BaseAssetsCheckout):
    """Represents a AssetsCheckout record"""

    id: _str
    assetId: _str
    asset: Optional['models.Assets'] = None
    employeeUserId: Optional[_str] = None
    employeeUser: Optional['models.EmployeeUser'] = None
    checkoutDate: datetime.datetime
    expectedReturnDate: Optional[datetime.datetime] = None
    checkins: Optional[List['models.AssetsCheckin']] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AssetsCheckoutKeys']] = None,
        exclude: Optional[Iterable['types.AssetsCheckoutKeys']] = None,
        required: Optional[Iterable['types.AssetsCheckoutKeys']] = None,
        optional: Optional[Iterable['types.AssetsCheckoutKeys']] = None,
        relations: Optional[Mapping['types.AssetsCheckoutRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AssetsCheckoutKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AssetsCheckout_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AssetsCheckout_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AssetsCheckout_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AssetsCheckout_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _AssetsCheckout_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _AssetsCheckout_relational_fields:
                        raise errors.UnknownRelationalFieldError('AssetsCheckout', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AssetsCheckout / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AssetsCheckout',
            }
        )
        _created_partial_types.add(name)


class AssetsCheckin(bases.BaseAssetsCheckin):
    """Represents a AssetsCheckin record"""

    id: _str
    assetId: _str
    asset: Optional['models.Assets'] = None
    checkoutId: _str
    checkout: Optional['models.AssetsCheckout'] = None
    employeeUserId: _str
    employeeUser: Optional['models.EmployeeUser'] = None
    checkinDate: datetime.datetime
    condition: Optional[_str] = None
    notes: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AssetsCheckinKeys']] = None,
        exclude: Optional[Iterable['types.AssetsCheckinKeys']] = None,
        required: Optional[Iterable['types.AssetsCheckinKeys']] = None,
        optional: Optional[Iterable['types.AssetsCheckinKeys']] = None,
        relations: Optional[Mapping['types.AssetsCheckinRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AssetsCheckinKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AssetsCheckin_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AssetsCheckin_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AssetsCheckin_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AssetsCheckin_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _AssetsCheckin_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _AssetsCheckin_relational_fields:
                        raise errors.UnknownRelationalFieldError('AssetsCheckin', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AssetsCheckin / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AssetsCheckin',
            }
        )
        _created_partial_types.add(name)


class AssetsMove(bases.BaseAssetsMove):
    """Represents a AssetsMove record"""

    id: _str
    assetId: _str
    asset: Optional['models.Assets'] = None
    moveType: _str
    moveDate: datetime.datetime
    employeeUserId: Optional[_str] = None
    employeeUser: Optional['models.EmployeeUser'] = None
    reason: Optional[_str] = None
    notes: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AssetsMoveKeys']] = None,
        exclude: Optional[Iterable['types.AssetsMoveKeys']] = None,
        required: Optional[Iterable['types.AssetsMoveKeys']] = None,
        optional: Optional[Iterable['types.AssetsMoveKeys']] = None,
        relations: Optional[Mapping['types.AssetsMoveRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AssetsMoveKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AssetsMove_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AssetsMove_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AssetsMove_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AssetsMove_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _AssetsMove_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _AssetsMove_relational_fields:
                        raise errors.UnknownRelationalFieldError('AssetsMove', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AssetsMove / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AssetsMove',
            }
        )
        _created_partial_types.add(name)


class AssetsReserve(bases.BaseAssetsReserve):
    """Represents a AssetsReserve record"""

    id: _str
    assetId: _str
    asset: Optional['models.Assets'] = None
    reservationType: _str
    reservationDate: datetime.datetime
    purpose: Optional[_str] = None
    notes: Optional[_str] = None
    employeeUserId: Optional[_str] = None
    employeeUser: Optional['models.EmployeeUser'] = None
    department: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AssetsReserveKeys']] = None,
        exclude: Optional[Iterable['types.AssetsReserveKeys']] = None,
        required: Optional[Iterable['types.AssetsReserveKeys']] = None,
        optional: Optional[Iterable['types.AssetsReserveKeys']] = None,
        relations: Optional[Mapping['types.AssetsReserveRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AssetsReserveKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AssetsReserve_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AssetsReserve_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AssetsReserve_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AssetsReserve_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _AssetsReserve_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _AssetsReserve_relational_fields:
                        raise errors.UnknownRelationalFieldError('AssetsReserve', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AssetsReserve / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AssetsReserve',
            }
        )
        _created_partial_types.add(name)


class AssetsLease(bases.BaseAssetsLease):
    """Represents a AssetsLease record"""

    id: _str
    assetId: _str
    asset: Optional['models.Assets'] = None
    lessee: _str
    leaseStartDate: datetime.datetime
    leaseEndDate: Optional[datetime.datetime] = None
    conditions: Optional[_str] = None
    notes: Optional[_str] = None
    returns: Optional[List['models.AssetsLeaseReturn']] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AssetsLeaseKeys']] = None,
        exclude: Optional[Iterable['types.AssetsLeaseKeys']] = None,
        required: Optional[Iterable['types.AssetsLeaseKeys']] = None,
        optional: Optional[Iterable['types.AssetsLeaseKeys']] = None,
        relations: Optional[Mapping['types.AssetsLeaseRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AssetsLeaseKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AssetsLease_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AssetsLease_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AssetsLease_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AssetsLease_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _AssetsLease_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _AssetsLease_relational_fields:
                        raise errors.UnknownRelationalFieldError('AssetsLease', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AssetsLease / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AssetsLease',
            }
        )
        _created_partial_types.add(name)


class AssetsLeaseReturn(bases.BaseAssetsLeaseReturn):
    """Represents a AssetsLeaseReturn record"""

    id: _str
    assetId: _str
    asset: Optional['models.Assets'] = None
    leaseId: _str
    lease: Optional['models.AssetsLease'] = None
    returnDate: datetime.datetime
    condition: Optional[_str] = None
    notes: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AssetsLeaseReturnKeys']] = None,
        exclude: Optional[Iterable['types.AssetsLeaseReturnKeys']] = None,
        required: Optional[Iterable['types.AssetsLeaseReturnKeys']] = None,
        optional: Optional[Iterable['types.AssetsLeaseReturnKeys']] = None,
        relations: Optional[Mapping['types.AssetsLeaseReturnRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AssetsLeaseReturnKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AssetsLeaseReturn_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AssetsLeaseReturn_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AssetsLeaseReturn_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AssetsLeaseReturn_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _AssetsLeaseReturn_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _AssetsLeaseReturn_relational_fields:
                        raise errors.UnknownRelationalFieldError('AssetsLeaseReturn', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AssetsLeaseReturn / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AssetsLeaseReturn',
            }
        )
        _created_partial_types.add(name)


class AssetsDispose(bases.BaseAssetsDispose):
    """Represents a AssetsDispose record"""

    id: _str
    assetId: _str
    asset: Optional['models.Assets'] = None
    disposeDate: datetime.datetime
    disposalMethod: _str
    disposeReason: Optional[_str] = None
    disposeValue: Optional[decimal.Decimal] = None
    notes: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AssetsDisposeKeys']] = None,
        exclude: Optional[Iterable['types.AssetsDisposeKeys']] = None,
        required: Optional[Iterable['types.AssetsDisposeKeys']] = None,
        optional: Optional[Iterable['types.AssetsDisposeKeys']] = None,
        relations: Optional[Mapping['types.AssetsDisposeRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AssetsDisposeKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AssetsDispose_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AssetsDispose_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AssetsDispose_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AssetsDispose_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _AssetsDispose_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _AssetsDispose_relational_fields:
                        raise errors.UnknownRelationalFieldError('AssetsDispose', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AssetsDispose / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AssetsDispose',
            }
        )
        _created_partial_types.add(name)


class AssetsMaintenance(bases.BaseAssetsMaintenance):
    """Represents a AssetsMaintenance record"""

    id: _str
    assetId: _str
    asset: Optional['models.Assets'] = None
    title: _str
    details: Optional[_str] = None
    dueDate: Optional[datetime.datetime] = None
    maintenanceBy: Optional[_str] = None
    status: _str
    dateCompleted: Optional[datetime.datetime] = None
    dateCancelled: Optional[datetime.datetime] = None
    cost: Optional[decimal.Decimal] = None
    isRepeating: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    inventoryItems: Optional[List['models.MaintenanceInventoryItem']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AssetsMaintenanceKeys']] = None,
        exclude: Optional[Iterable['types.AssetsMaintenanceKeys']] = None,
        required: Optional[Iterable['types.AssetsMaintenanceKeys']] = None,
        optional: Optional[Iterable['types.AssetsMaintenanceKeys']] = None,
        relations: Optional[Mapping['types.AssetsMaintenanceRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AssetsMaintenanceKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AssetsMaintenance_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AssetsMaintenance_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AssetsMaintenance_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AssetsMaintenance_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _AssetsMaintenance_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _AssetsMaintenance_relational_fields:
                        raise errors.UnknownRelationalFieldError('AssetsMaintenance', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AssetsMaintenance / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AssetsMaintenance',
            }
        )
        _created_partial_types.add(name)


class MaintenanceInventoryItem(bases.BaseMaintenanceInventoryItem):
    """Represents a MaintenanceInventoryItem record"""

    id: _str
    maintenanceId: _str
    maintenance: Optional['models.AssetsMaintenance'] = None
    inventoryItemId: _str
    inventoryItem: Optional['models.InventoryItem'] = None
    quantity: decimal.Decimal
    unitCost: Optional[decimal.Decimal] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.MaintenanceInventoryItemKeys']] = None,
        exclude: Optional[Iterable['types.MaintenanceInventoryItemKeys']] = None,
        required: Optional[Iterable['types.MaintenanceInventoryItemKeys']] = None,
        optional: Optional[Iterable['types.MaintenanceInventoryItemKeys']] = None,
        relations: Optional[Mapping['types.MaintenanceInventoryItemRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.MaintenanceInventoryItemKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _MaintenanceInventoryItem_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _MaintenanceInventoryItem_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _MaintenanceInventoryItem_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _MaintenanceInventoryItem_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _MaintenanceInventoryItem_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _MaintenanceInventoryItem_relational_fields:
                        raise errors.UnknownRelationalFieldError('MaintenanceInventoryItem', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid MaintenanceInventoryItem / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'MaintenanceInventoryItem',
            }
        )
        _created_partial_types.add(name)


class AssetsAuditHistory(bases.BaseAssetsAuditHistory):
    """Represents a AssetsAuditHistory record"""

    id: _str
    assetId: _str
    asset: Optional['models.Assets'] = None
    auditType: _str
    auditDate: datetime.datetime
    notes: Optional[_str] = None
    auditor: Optional[_str] = None
    status: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AssetsAuditHistoryKeys']] = None,
        exclude: Optional[Iterable['types.AssetsAuditHistoryKeys']] = None,
        required: Optional[Iterable['types.AssetsAuditHistoryKeys']] = None,
        optional: Optional[Iterable['types.AssetsAuditHistoryKeys']] = None,
        relations: Optional[Mapping['types.AssetsAuditHistoryRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AssetsAuditHistoryKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AssetsAuditHistory_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AssetsAuditHistory_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AssetsAuditHistory_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AssetsAuditHistory_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _AssetsAuditHistory_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _AssetsAuditHistory_relational_fields:
                        raise errors.UnknownRelationalFieldError('AssetsAuditHistory', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AssetsAuditHistory / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AssetsAuditHistory',
            }
        )
        _created_partial_types.add(name)


class AssetsHistoryLogs(bases.BaseAssetsHistoryLogs):
    """Represents a AssetsHistoryLogs record"""

    id: _str
    assetId: _str
    asset: Optional['models.Assets'] = None
    eventDate: datetime.datetime
    eventType: _str
    field: Optional[_str] = None
    changeFrom: Optional[_str] = None
    changeTo: Optional[_str] = None
    actionBy: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AssetsHistoryLogsKeys']] = None,
        exclude: Optional[Iterable['types.AssetsHistoryLogsKeys']] = None,
        required: Optional[Iterable['types.AssetsHistoryLogsKeys']] = None,
        optional: Optional[Iterable['types.AssetsHistoryLogsKeys']] = None,
        relations: Optional[Mapping['types.AssetsHistoryLogsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AssetsHistoryLogsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AssetsHistoryLogs_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AssetsHistoryLogs_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AssetsHistoryLogs_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AssetsHistoryLogs_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _AssetsHistoryLogs_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _AssetsHistoryLogs_relational_fields:
                        raise errors.UnknownRelationalFieldError('AssetsHistoryLogs', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AssetsHistoryLogs / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AssetsHistoryLogs',
            }
        )
        _created_partial_types.add(name)


class AssetUser(bases.BaseAssetUser):
    """Represents a AssetUser record"""

    id: _str
    userId: _str
    role: _str
    canDeleteAssets: _bool
    canManageImport: _bool
    canManageExport: _bool
    canCreateAssets: _bool
    canEditAssets: _bool
    canViewAssets: _bool
    canManageEmployees: _bool
    canManageSetup: _bool
    canCheckout: _bool
    canCheckin: _bool
    canReserve: _bool
    canMove: _bool
    canLease: _bool
    canDispose: _bool
    canManageMaintenance: _bool
    canAudit: _bool
    canManageMedia: _bool
    canManageTrash: _bool
    canManageUsers: _bool
    canManageReturnForms: _bool
    canViewReturnForms: _bool
    canManageAccountabilityForms: _bool
    canViewAccountabilityForms: _bool
    canManageReports: _bool
    canManageInventory: _bool
    isActive: _bool
    isApproved: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AssetUserKeys']] = None,
        exclude: Optional[Iterable['types.AssetUserKeys']] = None,
        required: Optional[Iterable['types.AssetUserKeys']] = None,
        optional: Optional[Iterable['types.AssetUserKeys']] = None,
        relations: Optional[Mapping['types.AssetUserRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AssetUserKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AssetUser_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AssetUser_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AssetUser_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AssetUser_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "AssetUser" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AssetUser / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AssetUser',
            }
        )
        _created_partial_types.add(name)


class FileHistory(bases.BaseFileHistory):
    """Represents a FileHistory record"""

    id: _str
    operationType: _str
    fileName: _str
    filePath: Optional[_str] = None
    fileSize: Optional[_int] = None
    mimeType: Optional[_str] = None
    userId: _str
    recordsProcessed: Optional[_int] = None
    recordsCreated: Optional[_int] = None
    recordsSkipped: Optional[_int] = None
    recordsFailed: Optional[_int] = None
    recordsExported: Optional[_int] = None
    fieldsExported: Optional[_int] = None
    status: _str
    errorMessage: Optional[_str] = None
    metadata: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.FileHistoryKeys']] = None,
        exclude: Optional[Iterable['types.FileHistoryKeys']] = None,
        required: Optional[Iterable['types.FileHistoryKeys']] = None,
        optional: Optional[Iterable['types.FileHistoryKeys']] = None,
        relations: Optional[Mapping['types.FileHistoryRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.FileHistoryKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _FileHistory_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _FileHistory_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _FileHistory_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _FileHistory_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "FileHistory" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid FileHistory / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'FileHistory',
            }
        )
        _created_partial_types.add(name)


class ReturnForm(bases.BaseReturnForm):
    """Represents a ReturnForm record"""

    id: _str
    employeeUserId: _str
    employeeUser: Optional['models.EmployeeUser'] = None
    dateReturned: datetime.datetime
    department: Optional[_str] = None
    ctrlNo: Optional[_str] = None
    returnType: _str
    formData: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ReturnFormKeys']] = None,
        exclude: Optional[Iterable['types.ReturnFormKeys']] = None,
        required: Optional[Iterable['types.ReturnFormKeys']] = None,
        optional: Optional[Iterable['types.ReturnFormKeys']] = None,
        relations: Optional[Mapping['types.ReturnFormRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ReturnFormKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ReturnForm_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ReturnForm_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ReturnForm_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ReturnForm_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ReturnForm_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ReturnForm_relational_fields:
                        raise errors.UnknownRelationalFieldError('ReturnForm', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ReturnForm / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ReturnForm',
            }
        )
        _created_partial_types.add(name)


class AccountabilityForm(bases.BaseAccountabilityForm):
    """Represents a AccountabilityForm record"""

    id: _str
    employeeUserId: _str
    employeeUser: Optional['models.EmployeeUser'] = None
    dateIssued: datetime.datetime
    department: Optional[_str] = None
    accountabilityFormNo: Optional[_str] = None
    formData: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AccountabilityFormKeys']] = None,
        exclude: Optional[Iterable['types.AccountabilityFormKeys']] = None,
        required: Optional[Iterable['types.AccountabilityFormKeys']] = None,
        optional: Optional[Iterable['types.AccountabilityFormKeys']] = None,
        relations: Optional[Mapping['types.AccountabilityFormRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AccountabilityFormKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AccountabilityForm_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AccountabilityForm_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AccountabilityForm_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AccountabilityForm_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _AccountabilityForm_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _AccountabilityForm_relational_fields:
                        raise errors.UnknownRelationalFieldError('AccountabilityForm', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AccountabilityForm / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AccountabilityForm',
            }
        )
        _created_partial_types.add(name)


class AssetsLocation(bases.BaseAssetsLocation):
    """Represents a AssetsLocation record"""

    id: _str
    name: _str
    description: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AssetsLocationKeys']] = None,
        exclude: Optional[Iterable['types.AssetsLocationKeys']] = None,
        required: Optional[Iterable['types.AssetsLocationKeys']] = None,
        optional: Optional[Iterable['types.AssetsLocationKeys']] = None,
        relations: Optional[Mapping['types.AssetsLocationRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AssetsLocationKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AssetsLocation_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AssetsLocation_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AssetsLocation_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AssetsLocation_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "AssetsLocation" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AssetsLocation / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AssetsLocation',
            }
        )
        _created_partial_types.add(name)


class AssetsSite(bases.BaseAssetsSite):
    """Represents a AssetsSite record"""

    id: _str
    name: _str
    description: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AssetsSiteKeys']] = None,
        exclude: Optional[Iterable['types.AssetsSiteKeys']] = None,
        required: Optional[Iterable['types.AssetsSiteKeys']] = None,
        optional: Optional[Iterable['types.AssetsSiteKeys']] = None,
        relations: Optional[Mapping['types.AssetsSiteRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AssetsSiteKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AssetsSite_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AssetsSite_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AssetsSite_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AssetsSite_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "AssetsSite" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AssetsSite / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AssetsSite',
            }
        )
        _created_partial_types.add(name)


class AssetsDepartment(bases.BaseAssetsDepartment):
    """Represents a AssetsDepartment record"""

    id: _str
    name: _str
    description: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AssetsDepartmentKeys']] = None,
        exclude: Optional[Iterable['types.AssetsDepartmentKeys']] = None,
        required: Optional[Iterable['types.AssetsDepartmentKeys']] = None,
        optional: Optional[Iterable['types.AssetsDepartmentKeys']] = None,
        relations: Optional[Mapping['types.AssetsDepartmentRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AssetsDepartmentKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AssetsDepartment_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AssetsDepartment_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AssetsDepartment_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AssetsDepartment_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "AssetsDepartment" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AssetsDepartment / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AssetsDepartment',
            }
        )
        _created_partial_types.add(name)


class InventoryItem(bases.BaseInventoryItem):
    """Represents a InventoryItem record"""

    id: _str
    itemCode: _str
    name: _str
    description: Optional[_str] = None
    category: Optional[_str] = None
    unit: Optional[_str] = None
    currentStock: decimal.Decimal
    minStockLevel: Optional[decimal.Decimal] = None
    maxStockLevel: Optional[decimal.Decimal] = None
    unitCost: Optional[decimal.Decimal] = None
    location: Optional[_str] = None
    supplier: Optional[_str] = None
    brand: Optional[_str] = None
    model: Optional[_str] = None
    sku: Optional[_str] = None
    barcode: Optional[_str] = None
    remarks: Optional[_str] = None
    deletedAt: Optional[datetime.datetime] = None
    isDeleted: _bool
    transactions: Optional[List['models.InventoryTransaction']] = None
    maintenanceUsages: Optional[List['models.MaintenanceInventoryItem']] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.InventoryItemKeys']] = None,
        exclude: Optional[Iterable['types.InventoryItemKeys']] = None,
        required: Optional[Iterable['types.InventoryItemKeys']] = None,
        optional: Optional[Iterable['types.InventoryItemKeys']] = None,
        relations: Optional[Mapping['types.InventoryItemRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.InventoryItemKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _InventoryItem_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _InventoryItem_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _InventoryItem_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _InventoryItem_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _InventoryItem_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _InventoryItem_relational_fields:
                        raise errors.UnknownRelationalFieldError('InventoryItem', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid InventoryItem / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'InventoryItem',
            }
        )
        _created_partial_types.add(name)


class InventoryTransaction(bases.BaseInventoryTransaction):
    """Represents a InventoryTransaction record"""

    id: _str
    inventoryItemId: _str
    inventoryItem: Optional['models.InventoryItem'] = None
    transactionType: _str
    quantity: decimal.Decimal
    unitCost: Optional[decimal.Decimal] = None
    reference: Optional[_str] = None
    notes: Optional[_str] = None
    actionBy: _str
    transactionDate: datetime.datetime
    relatedTransactionId: Optional[_str] = None
    relatedTransaction: Optional['models.InventoryTransaction'] = None
    transferTransactions: Optional[List['models.InventoryTransaction']] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.InventoryTransactionKeys']] = None,
        exclude: Optional[Iterable['types.InventoryTransactionKeys']] = None,
        required: Optional[Iterable['types.InventoryTransactionKeys']] = None,
        optional: Optional[Iterable['types.InventoryTransactionKeys']] = None,
        relations: Optional[Mapping['types.InventoryTransactionRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.InventoryTransactionKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _InventoryTransaction_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _InventoryTransaction_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _InventoryTransaction_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _InventoryTransaction_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _InventoryTransaction_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _InventoryTransaction_relational_fields:
                        raise errors.UnknownRelationalFieldError('InventoryTransaction', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid InventoryTransaction / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'InventoryTransaction',
            }
        )
        _created_partial_types.add(name)


class CompanyInfo(bases.BaseCompanyInfo):
    """Represents a CompanyInfo record"""

    id: _str
    companyName: _str
    contactEmail: Optional[_str] = None
    contactPhone: Optional[_str] = None
    address: Optional[_str] = None
    zipCode: Optional[_str] = None
    country: Optional[_str] = None
    website: Optional[_str] = None
    primaryLogoUrl: Optional[_str] = None
    secondaryLogoUrl: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.CompanyInfoKeys']] = None,
        exclude: Optional[Iterable['types.CompanyInfoKeys']] = None,
        required: Optional[Iterable['types.CompanyInfoKeys']] = None,
        optional: Optional[Iterable['types.CompanyInfoKeys']] = None,
        relations: Optional[Mapping['types.CompanyInfoRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.CompanyInfoKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _CompanyInfo_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _CompanyInfo_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _CompanyInfo_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _CompanyInfo_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "CompanyInfo" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid CompanyInfo / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'CompanyInfo',
            }
        )
        _created_partial_types.add(name)


class AssetSchedule(bases.BaseAssetSchedule):
    """Represents a AssetSchedule record"""

    id: _str
    assetId: _str
    asset: Optional['models.Assets'] = None
    scheduleType: _str
    scheduledDate: datetime.datetime
    scheduledTime: Optional[_str] = None
    title: _str
    notes: Optional[_str] = None
    status: _str
    assignedTo: Optional[_str] = None
    location: Optional[_str] = None
    employeeId: Optional[_str] = None
    createdBy: Optional[_str] = None
    completedAt: Optional[datetime.datetime] = None
    cancelledAt: Optional[datetime.datetime] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AssetScheduleKeys']] = None,
        exclude: Optional[Iterable['types.AssetScheduleKeys']] = None,
        required: Optional[Iterable['types.AssetScheduleKeys']] = None,
        optional: Optional[Iterable['types.AssetScheduleKeys']] = None,
        relations: Optional[Mapping['types.AssetScheduleRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AssetScheduleKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AssetSchedule_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AssetSchedule_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AssetSchedule_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AssetSchedule_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _AssetSchedule_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _AssetSchedule_relational_fields:
                        raise errors.UnknownRelationalFieldError('AssetSchedule', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AssetSchedule / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AssetSchedule',
            }
        )
        _created_partial_types.add(name)


class AutomatedReportSchedule(bases.BaseAutomatedReportSchedule):
    """Represents a AutomatedReportSchedule record"""

    id: _str
    reportName: _str
    reportType: _str
    frequency: _str
    frequencyDay: Optional[_int] = None
    frequencyMonth: Optional[_int] = None
    scheduledTime: _str
    emailRecipients: List[_str]
    filters: Optional['fields.Json'] = None
    format: _str
    includeList: _bool
    isActive: _bool
    lastSentAt: Optional[datetime.datetime] = None
    nextRunAt: Optional[datetime.datetime] = None
    createdBy: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('emailRecipients', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AutomatedReportScheduleKeys']] = None,
        exclude: Optional[Iterable['types.AutomatedReportScheduleKeys']] = None,
        required: Optional[Iterable['types.AutomatedReportScheduleKeys']] = None,
        optional: Optional[Iterable['types.AutomatedReportScheduleKeys']] = None,
        relations: Optional[Mapping['types.AutomatedReportScheduleRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AutomatedReportScheduleKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AutomatedReportSchedule_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AutomatedReportSchedule_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AutomatedReportSchedule_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AutomatedReportSchedule_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "AutomatedReportSchedule" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AutomatedReportSchedule / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AutomatedReportSchedule',
            }
        )
        _created_partial_types.add(name)



_Assets_relational_fields: Set[str] = {
        'category',
        'subCategory',
        'checkouts',
        'checkins',
        'moves',
        'reservations',
        'leases',
        'leaseReturns',
        'disposals',
        'maintenances',
        'auditHistory',
        'historyLogs',
        'schedules',
    }
_Assets_fields: Dict['types.AssetsKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('assetTagId', {
            'name': 'assetTagId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('purchasedFrom', {
            'name': 'purchasedFrom',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('purchaseDate', {
            'name': 'purchaseDate',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('brand', {
            'name': 'brand',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('cost', {
            'name': 'cost',
            'is_list': False,
            'optional': True,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('model', {
            'name': 'model',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('serialNo', {
            'name': 'serialNo',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('additionalInformation', {
            'name': 'additionalInformation',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('xeroAssetNo', {
            'name': 'xeroAssetNo',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('owner', {
            'name': 'owner',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('pbiNumber', {
            'name': 'pbiNumber',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('issuedTo', {
            'name': 'issuedTo',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('poNumber', {
            'name': 'poNumber',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('paymentVoucherNumber', {
            'name': 'paymentVoucherNumber',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('assetType', {
            'name': 'assetType',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('deliveryDate', {
            'name': 'deliveryDate',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('unaccountedInventory', {
            'name': 'unaccountedInventory',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('remarks', {
            'name': 'remarks',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('qr', {
            'name': 'qr',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('oldAssetTag', {
            'name': 'oldAssetTag',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('depreciableAsset', {
            'name': 'depreciableAsset',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('depreciableCost', {
            'name': 'depreciableCost',
            'is_list': False,
            'optional': True,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('salvageValue', {
            'name': 'salvageValue',
            'is_list': False,
            'optional': True,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('assetLifeMonths', {
            'name': 'assetLifeMonths',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('depreciationMethod', {
            'name': 'depreciationMethod',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('dateAcquired', {
            'name': 'dateAcquired',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('categoryId', {
            'name': 'categoryId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('category', {
            'name': 'category',
            'is_list': False,
            'optional': True,
            'type': 'models.Category',
            'is_relational': True,
            'documentation': None,
        }),
        ('subCategoryId', {
            'name': 'subCategoryId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('subCategory', {
            'name': 'subCategory',
            'is_list': False,
            'optional': True,
            'type': 'models.SubCategory',
            'is_relational': True,
            'documentation': None,
        }),
        ('department', {
            'name': 'department',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('site', {
            'name': 'site',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('location', {
            'name': 'location',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('isDeleted', {
            'name': 'isDeleted',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('checkouts', {
            'name': 'checkouts',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AssetsCheckout\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('checkins', {
            'name': 'checkins',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AssetsCheckin\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('moves', {
            'name': 'moves',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AssetsMove\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('reservations', {
            'name': 'reservations',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AssetsReserve\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('leases', {
            'name': 'leases',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AssetsLease\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('leaseReturns', {
            'name': 'leaseReturns',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AssetsLeaseReturn\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('disposals', {
            'name': 'disposals',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AssetsDispose\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('maintenances', {
            'name': 'maintenances',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AssetsMaintenance\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('auditHistory', {
            'name': 'auditHistory',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AssetsAuditHistory\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('historyLogs', {
            'name': 'historyLogs',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AssetsHistoryLogs\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('schedules', {
            'name': 'schedules',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AssetSchedule\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_AssetsImage_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_AssetsImage_fields: Dict['types.AssetsImageKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('assetTagId', {
            'name': 'assetTagId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('imageUrl', {
            'name': 'imageUrl',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('imageType', {
            'name': 'imageType',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('imageSize', {
            'name': 'imageSize',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_AssetsDocument_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_AssetsDocument_fields: Dict['types.AssetsDocumentKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('assetTagId', {
            'name': 'assetTagId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('documentUrl', {
            'name': 'documentUrl',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('documentType', {
            'name': 'documentType',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('documentSize', {
            'name': 'documentSize',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('fileName', {
            'name': 'fileName',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('mimeType', {
            'name': 'mimeType',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Category_relational_fields: Set[str] = {
        'subCategories',
        'assets',
    }
_Category_fields: Dict['types.CategoryKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('subCategories', {
            'name': 'subCategories',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.SubCategory\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('assets', {
            'name': 'assets',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Assets\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_SubCategory_relational_fields: Set[str] = {
        'category',
        'assets',
    }
_SubCategory_fields: Dict['types.SubCategoryKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('categoryId', {
            'name': 'categoryId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('category', {
            'name': 'category',
            'is_list': False,
            'optional': True,
            'type': 'models.Category',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('assets', {
            'name': 'assets',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Assets\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_EmployeeUser_relational_fields: Set[str] = {
        'checkouts',
        'checkins',
        'moves',
        'reservations',
        'returnForms',
        'accountabilityForms',
    }
_EmployeeUser_fields: Dict['types.EmployeeUserKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('department', {
            'name': 'department',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('checkouts', {
            'name': 'checkouts',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AssetsCheckout\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('checkins', {
            'name': 'checkins',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AssetsCheckin\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('moves', {
            'name': 'moves',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AssetsMove\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('reservations', {
            'name': 'reservations',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AssetsReserve\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('returnForms', {
            'name': 'returnForms',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ReturnForm\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('accountabilityForms', {
            'name': 'accountabilityForms',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AccountabilityForm\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_AssetsCheckout_relational_fields: Set[str] = {
        'asset',
        'employeeUser',
        'checkins',
    }
_AssetsCheckout_fields: Dict['types.AssetsCheckoutKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('assetId', {
            'name': 'assetId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('asset', {
            'name': 'asset',
            'is_list': False,
            'optional': True,
            'type': 'models.Assets',
            'is_relational': True,
            'documentation': None,
        }),
        ('employeeUserId', {
            'name': 'employeeUserId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('employeeUser', {
            'name': 'employeeUser',
            'is_list': False,
            'optional': True,
            'type': 'models.EmployeeUser',
            'is_relational': True,
            'documentation': None,
        }),
        ('checkoutDate', {
            'name': 'checkoutDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('expectedReturnDate', {
            'name': 'expectedReturnDate',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('checkins', {
            'name': 'checkins',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AssetsCheckin\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_AssetsCheckin_relational_fields: Set[str] = {
        'asset',
        'checkout',
        'employeeUser',
    }
_AssetsCheckin_fields: Dict['types.AssetsCheckinKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('assetId', {
            'name': 'assetId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('asset', {
            'name': 'asset',
            'is_list': False,
            'optional': True,
            'type': 'models.Assets',
            'is_relational': True,
            'documentation': None,
        }),
        ('checkoutId', {
            'name': 'checkoutId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('checkout', {
            'name': 'checkout',
            'is_list': False,
            'optional': True,
            'type': 'models.AssetsCheckout',
            'is_relational': True,
            'documentation': None,
        }),
        ('employeeUserId', {
            'name': 'employeeUserId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('employeeUser', {
            'name': 'employeeUser',
            'is_list': False,
            'optional': True,
            'type': 'models.EmployeeUser',
            'is_relational': True,
            'documentation': None,
        }),
        ('checkinDate', {
            'name': 'checkinDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('condition', {
            'name': 'condition',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_AssetsMove_relational_fields: Set[str] = {
        'asset',
        'employeeUser',
    }
_AssetsMove_fields: Dict['types.AssetsMoveKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('assetId', {
            'name': 'assetId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('asset', {
            'name': 'asset',
            'is_list': False,
            'optional': True,
            'type': 'models.Assets',
            'is_relational': True,
            'documentation': None,
        }),
        ('moveType', {
            'name': 'moveType',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('moveDate', {
            'name': 'moveDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('employeeUserId', {
            'name': 'employeeUserId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('employeeUser', {
            'name': 'employeeUser',
            'is_list': False,
            'optional': True,
            'type': 'models.EmployeeUser',
            'is_relational': True,
            'documentation': None,
        }),
        ('reason', {
            'name': 'reason',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_AssetsReserve_relational_fields: Set[str] = {
        'asset',
        'employeeUser',
    }
_AssetsReserve_fields: Dict['types.AssetsReserveKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('assetId', {
            'name': 'assetId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('asset', {
            'name': 'asset',
            'is_list': False,
            'optional': True,
            'type': 'models.Assets',
            'is_relational': True,
            'documentation': None,
        }),
        ('reservationType', {
            'name': 'reservationType',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('reservationDate', {
            'name': 'reservationDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('purpose', {
            'name': 'purpose',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('employeeUserId', {
            'name': 'employeeUserId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('employeeUser', {
            'name': 'employeeUser',
            'is_list': False,
            'optional': True,
            'type': 'models.EmployeeUser',
            'is_relational': True,
            'documentation': None,
        }),
        ('department', {
            'name': 'department',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_AssetsLease_relational_fields: Set[str] = {
        'asset',
        'returns',
    }
_AssetsLease_fields: Dict['types.AssetsLeaseKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('assetId', {
            'name': 'assetId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('asset', {
            'name': 'asset',
            'is_list': False,
            'optional': True,
            'type': 'models.Assets',
            'is_relational': True,
            'documentation': None,
        }),
        ('lessee', {
            'name': 'lessee',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('leaseStartDate', {
            'name': 'leaseStartDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('leaseEndDate', {
            'name': 'leaseEndDate',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('conditions', {
            'name': 'conditions',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('returns', {
            'name': 'returns',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AssetsLeaseReturn\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_AssetsLeaseReturn_relational_fields: Set[str] = {
        'asset',
        'lease',
    }
_AssetsLeaseReturn_fields: Dict['types.AssetsLeaseReturnKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('assetId', {
            'name': 'assetId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('asset', {
            'name': 'asset',
            'is_list': False,
            'optional': True,
            'type': 'models.Assets',
            'is_relational': True,
            'documentation': None,
        }),
        ('leaseId', {
            'name': 'leaseId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('lease', {
            'name': 'lease',
            'is_list': False,
            'optional': True,
            'type': 'models.AssetsLease',
            'is_relational': True,
            'documentation': None,
        }),
        ('returnDate', {
            'name': 'returnDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('condition', {
            'name': 'condition',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_AssetsDispose_relational_fields: Set[str] = {
        'asset',
    }
_AssetsDispose_fields: Dict['types.AssetsDisposeKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('assetId', {
            'name': 'assetId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('asset', {
            'name': 'asset',
            'is_list': False,
            'optional': True,
            'type': 'models.Assets',
            'is_relational': True,
            'documentation': None,
        }),
        ('disposeDate', {
            'name': 'disposeDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('disposalMethod', {
            'name': 'disposalMethod',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('disposeReason', {
            'name': 'disposeReason',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('disposeValue', {
            'name': 'disposeValue',
            'is_list': False,
            'optional': True,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_AssetsMaintenance_relational_fields: Set[str] = {
        'asset',
        'inventoryItems',
    }
_AssetsMaintenance_fields: Dict['types.AssetsMaintenanceKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('assetId', {
            'name': 'assetId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('asset', {
            'name': 'asset',
            'is_list': False,
            'optional': True,
            'type': 'models.Assets',
            'is_relational': True,
            'documentation': None,
        }),
        ('title', {
            'name': 'title',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('details', {
            'name': 'details',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('dueDate', {
            'name': 'dueDate',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('maintenanceBy', {
            'name': 'maintenanceBy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('dateCompleted', {
            'name': 'dateCompleted',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('dateCancelled', {
            'name': 'dateCancelled',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('cost', {
            'name': 'cost',
            'is_list': False,
            'optional': True,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('isRepeating', {
            'name': 'isRepeating',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('inventoryItems', {
            'name': 'inventoryItems',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.MaintenanceInventoryItem\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_MaintenanceInventoryItem_relational_fields: Set[str] = {
        'maintenance',
        'inventoryItem',
    }
_MaintenanceInventoryItem_fields: Dict['types.MaintenanceInventoryItemKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('maintenanceId', {
            'name': 'maintenanceId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('maintenance', {
            'name': 'maintenance',
            'is_list': False,
            'optional': True,
            'type': 'models.AssetsMaintenance',
            'is_relational': True,
            'documentation': None,
        }),
        ('inventoryItemId', {
            'name': 'inventoryItemId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('inventoryItem', {
            'name': 'inventoryItem',
            'is_list': False,
            'optional': True,
            'type': 'models.InventoryItem',
            'is_relational': True,
            'documentation': None,
        }),
        ('quantity', {
            'name': 'quantity',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('unitCost', {
            'name': 'unitCost',
            'is_list': False,
            'optional': True,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_AssetsAuditHistory_relational_fields: Set[str] = {
        'asset',
    }
_AssetsAuditHistory_fields: Dict['types.AssetsAuditHistoryKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('assetId', {
            'name': 'assetId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('asset', {
            'name': 'asset',
            'is_list': False,
            'optional': True,
            'type': 'models.Assets',
            'is_relational': True,
            'documentation': None,
        }),
        ('auditType', {
            'name': 'auditType',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('auditDate', {
            'name': 'auditDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('auditor', {
            'name': 'auditor',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_AssetsHistoryLogs_relational_fields: Set[str] = {
        'asset',
    }
_AssetsHistoryLogs_fields: Dict['types.AssetsHistoryLogsKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('assetId', {
            'name': 'assetId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('asset', {
            'name': 'asset',
            'is_list': False,
            'optional': True,
            'type': 'models.Assets',
            'is_relational': True,
            'documentation': None,
        }),
        ('eventDate', {
            'name': 'eventDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('eventType', {
            'name': 'eventType',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('field', {
            'name': 'field',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('changeFrom', {
            'name': 'changeFrom',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('changeTo', {
            'name': 'changeTo',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('actionBy', {
            'name': 'actionBy',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_AssetUser_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_AssetUser_fields: Dict['types.AssetUserKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('role', {
            'name': 'role',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('canDeleteAssets', {
            'name': 'canDeleteAssets',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('canManageImport', {
            'name': 'canManageImport',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('canManageExport', {
            'name': 'canManageExport',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('canCreateAssets', {
            'name': 'canCreateAssets',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('canEditAssets', {
            'name': 'canEditAssets',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('canViewAssets', {
            'name': 'canViewAssets',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('canManageEmployees', {
            'name': 'canManageEmployees',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('canManageSetup', {
            'name': 'canManageSetup',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('canCheckout', {
            'name': 'canCheckout',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('canCheckin', {
            'name': 'canCheckin',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('canReserve', {
            'name': 'canReserve',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('canMove', {
            'name': 'canMove',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('canLease', {
            'name': 'canLease',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('canDispose', {
            'name': 'canDispose',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('canManageMaintenance', {
            'name': 'canManageMaintenance',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('canAudit', {
            'name': 'canAudit',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('canManageMedia', {
            'name': 'canManageMedia',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('canManageTrash', {
            'name': 'canManageTrash',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('canManageUsers', {
            'name': 'canManageUsers',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('canManageReturnForms', {
            'name': 'canManageReturnForms',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('canViewReturnForms', {
            'name': 'canViewReturnForms',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('canManageAccountabilityForms', {
            'name': 'canManageAccountabilityForms',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('canViewAccountabilityForms', {
            'name': 'canViewAccountabilityForms',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('canManageReports', {
            'name': 'canManageReports',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('canManageInventory', {
            'name': 'canManageInventory',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('isApproved', {
            'name': 'isApproved',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_FileHistory_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_FileHistory_fields: Dict['types.FileHistoryKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('operationType', {
            'name': 'operationType',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('fileName', {
            'name': 'fileName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('filePath', {
            'name': 'filePath',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('fileSize', {
            'name': 'fileSize',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('mimeType', {
            'name': 'mimeType',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('recordsProcessed', {
            'name': 'recordsProcessed',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('recordsCreated', {
            'name': 'recordsCreated',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('recordsSkipped', {
            'name': 'recordsSkipped',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('recordsFailed', {
            'name': 'recordsFailed',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('recordsExported', {
            'name': 'recordsExported',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('fieldsExported', {
            'name': 'fieldsExported',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('errorMessage', {
            'name': 'errorMessage',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('metadata', {
            'name': 'metadata',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_ReturnForm_relational_fields: Set[str] = {
        'employeeUser',
    }
_ReturnForm_fields: Dict['types.ReturnFormKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('employeeUserId', {
            'name': 'employeeUserId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('employeeUser', {
            'name': 'employeeUser',
            'is_list': False,
            'optional': True,
            'type': 'models.EmployeeUser',
            'is_relational': True,
            'documentation': None,
        }),
        ('dateReturned', {
            'name': 'dateReturned',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('department', {
            'name': 'department',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('ctrlNo', {
            'name': 'ctrlNo',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('returnType', {
            'name': 'returnType',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('formData', {
            'name': 'formData',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_AccountabilityForm_relational_fields: Set[str] = {
        'employeeUser',
    }
_AccountabilityForm_fields: Dict['types.AccountabilityFormKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('employeeUserId', {
            'name': 'employeeUserId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('employeeUser', {
            'name': 'employeeUser',
            'is_list': False,
            'optional': True,
            'type': 'models.EmployeeUser',
            'is_relational': True,
            'documentation': None,
        }),
        ('dateIssued', {
            'name': 'dateIssued',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('department', {
            'name': 'department',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('accountabilityFormNo', {
            'name': 'accountabilityFormNo',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('formData', {
            'name': 'formData',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_AssetsLocation_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_AssetsLocation_fields: Dict['types.AssetsLocationKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_AssetsSite_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_AssetsSite_fields: Dict['types.AssetsSiteKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_AssetsDepartment_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_AssetsDepartment_fields: Dict['types.AssetsDepartmentKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_InventoryItem_relational_fields: Set[str] = {
        'transactions',
        'maintenanceUsages',
    }
_InventoryItem_fields: Dict['types.InventoryItemKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('itemCode', {
            'name': 'itemCode',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('category', {
            'name': 'category',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('unit', {
            'name': 'unit',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('currentStock', {
            'name': 'currentStock',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('minStockLevel', {
            'name': 'minStockLevel',
            'is_list': False,
            'optional': True,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('maxStockLevel', {
            'name': 'maxStockLevel',
            'is_list': False,
            'optional': True,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('unitCost', {
            'name': 'unitCost',
            'is_list': False,
            'optional': True,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('location', {
            'name': 'location',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('supplier', {
            'name': 'supplier',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('brand', {
            'name': 'brand',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('model', {
            'name': 'model',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('sku', {
            'name': 'sku',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('barcode', {
            'name': 'barcode',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('remarks', {
            'name': 'remarks',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('isDeleted', {
            'name': 'isDeleted',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('transactions', {
            'name': 'transactions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.InventoryTransaction\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('maintenanceUsages', {
            'name': 'maintenanceUsages',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.MaintenanceInventoryItem\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_InventoryTransaction_relational_fields: Set[str] = {
        'inventoryItem',
        'relatedTransaction',
        'transferTransactions',
    }
_InventoryTransaction_fields: Dict['types.InventoryTransactionKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('inventoryItemId', {
            'name': 'inventoryItemId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('inventoryItem', {
            'name': 'inventoryItem',
            'is_list': False,
            'optional': True,
            'type': 'models.InventoryItem',
            'is_relational': True,
            'documentation': None,
        }),
        ('transactionType', {
            'name': 'transactionType',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('quantity', {
            'name': 'quantity',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('unitCost', {
            'name': 'unitCost',
            'is_list': False,
            'optional': True,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('reference', {
            'name': 'reference',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('actionBy', {
            'name': 'actionBy',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('transactionDate', {
            'name': 'transactionDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('relatedTransactionId', {
            'name': 'relatedTransactionId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('relatedTransaction', {
            'name': 'relatedTransaction',
            'is_list': False,
            'optional': True,
            'type': 'models.InventoryTransaction',
            'is_relational': True,
            'documentation': None,
        }),
        ('transferTransactions', {
            'name': 'transferTransactions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.InventoryTransaction\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_CompanyInfo_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_CompanyInfo_fields: Dict['types.CompanyInfoKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('companyName', {
            'name': 'companyName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('contactEmail', {
            'name': 'contactEmail',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('contactPhone', {
            'name': 'contactPhone',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('address', {
            'name': 'address',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('zipCode', {
            'name': 'zipCode',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('country', {
            'name': 'country',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('website', {
            'name': 'website',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('primaryLogoUrl', {
            'name': 'primaryLogoUrl',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('secondaryLogoUrl', {
            'name': 'secondaryLogoUrl',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_AssetSchedule_relational_fields: Set[str] = {
        'asset',
    }
_AssetSchedule_fields: Dict['types.AssetScheduleKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('assetId', {
            'name': 'assetId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('asset', {
            'name': 'asset',
            'is_list': False,
            'optional': True,
            'type': 'models.Assets',
            'is_relational': True,
            'documentation': None,
        }),
        ('scheduleType', {
            'name': 'scheduleType',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('scheduledDate', {
            'name': 'scheduledDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('scheduledTime', {
            'name': 'scheduledTime',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('title', {
            'name': 'title',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('assignedTo', {
            'name': 'assignedTo',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('location', {
            'name': 'location',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('employeeId', {
            'name': 'employeeId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdBy', {
            'name': 'createdBy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('completedAt', {
            'name': 'completedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('cancelledAt', {
            'name': 'cancelledAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_AutomatedReportSchedule_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_AutomatedReportSchedule_fields: Dict['types.AutomatedReportScheduleKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('reportName', {
            'name': 'reportName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('reportType', {
            'name': 'reportType',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('frequency', {
            'name': 'frequency',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('frequencyDay', {
            'name': 'frequencyDay',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('frequencyMonth', {
            'name': 'frequencyMonth',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('scheduledTime', {
            'name': 'scheduledTime',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('emailRecipients', {
            'name': 'emailRecipients',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('filters', {
            'name': 'filters',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('format', {
            'name': 'format',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('includeList', {
            'name': 'includeList',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('lastSentAt', {
            'name': 'lastSentAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('nextRunAt', {
            'name': 'nextRunAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdBy', {
            'name': 'createdBy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(Assets)
model_rebuild(AssetsImage)
model_rebuild(AssetsDocument)
model_rebuild(Category)
model_rebuild(SubCategory)
model_rebuild(EmployeeUser)
model_rebuild(AssetsCheckout)
model_rebuild(AssetsCheckin)
model_rebuild(AssetsMove)
model_rebuild(AssetsReserve)
model_rebuild(AssetsLease)
model_rebuild(AssetsLeaseReturn)
model_rebuild(AssetsDispose)
model_rebuild(AssetsMaintenance)
model_rebuild(MaintenanceInventoryItem)
model_rebuild(AssetsAuditHistory)
model_rebuild(AssetsHistoryLogs)
model_rebuild(AssetUser)
model_rebuild(FileHistory)
model_rebuild(ReturnForm)
model_rebuild(AccountabilityForm)
model_rebuild(AssetsLocation)
model_rebuild(AssetsSite)
model_rebuild(AssetsDepartment)
model_rebuild(InventoryItem)
model_rebuild(InventoryTransaction)
model_rebuild(CompanyInfo)
model_rebuild(AssetSchedule)
model_rebuild(AutomatedReportSchedule)
